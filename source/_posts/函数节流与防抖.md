---
title: 函数节流与防抖
date: 2023-09-12 16:39:29
tags:
categories: web前端
---

### 1. 初步了解函数节流与防抖

>函数节流与防抖是优化高频执行js代码的一种手段，js中的一些事件，如浏览器的: resize、scroll、鼠标的mousemove、mouseover、input输入框的keypress等事件
>在触发时，会不断的调用绑定的回调函数，极大的浪费了资源，降低前端性能，为了优化体验，需要对这类事件进行调用次数的限制。即: 限制函数的执行次数

>节流: 减少一段时间的触发频率(控制触发次数)
>防抖: 通过setTimeout的方式，在一定时间间隔内，将多次触发变为最后一次触发

### 2. 函数防抖

1. 为什么需要防抖

>前端开发过程中，有一些事件，常见的例如，onresize，scroll，mousemove ,mousehover等，会被频繁触发（短时间内多次触发），不做限制的话，有可能一秒之内执
>行几十次、几百次，如果在这些函数内部执行了其他函 数，尤其是执行了操作DOM 的函数（浏览器操作 DOM 是很耗费性能的），那不仅会浪费计算机资源，还会降低程
>序运行速度，甚至造成浏览器卡死、崩溃。

2. 概念与应用

>概念：函数防抖（debounce），就是指触发事件后，在 n 秒内函数只能执行一次，如果触发事件后在 n 秒内又触发了事件，则会重新计算函数延执行时间。

```javascript
<input type="text" id="test" />
<script>
  const test = document.querySelector('#test')
  let timer = null
  test.oninput = function () {
    if(timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      console.log(this.value)
    }, 400)
  }
</script>
```

3. 进行封装

>对函数进行封装，封装后：

```javascript
<input type="text" id="test" />
<script>
  const test = document.querySelector('#test')
  let timer = null
  test.oninput = debounce(function() {
    console.log(this.value)
  })

  function debounce(fn, time = 500) {
    let timer = null
    return function () {
      if(timer) {
        clearTimeout(timer)
      }
      timer = setTimeout(() => {
        fn.call(this)
      }, time)
    }
  }
</script>
```

4. 函数防抖应用场景

- 搜索框搜索输入。只需用户最后一次输入完，再发送请求；
- 用户名、手机号、邮箱输入验证；
- 浏览器窗口大小改变后，只需窗口调整完后，再执行 resize 事件中的代码，防止重复渲染

### 3. 函数节流

1. 函数节流概念与应用

>概念： 限制一个函数在一定时间内只能执行一次。

```javascript
<body style="height: 2000px;"></body>
<script>
    let flag = true
    window.onscroll= function() {
      if(flag){
          setTimeout(() => {
              console.log('@')
              flag = true
          },500)  
      }
      flag = false
    }
</script>
```

2. 函数封装

>对函数进行封装，封装后：

```javascript
<body style="height: 2000px;"></body>
<script>
    let flag = true
    window.onscroll= throttle(() => {
      console.log('@')
    })

    function throttle(fn, time = 500) {
      let flag = true
      return function() {
        if(flag) {
           flag = false
          setTimeout(() => {
             fn.call(this)
             flag = true
          }, time)
        }
      }
    }
</script>
```

3. 节流的应用场景
   
- 懒加载、滚动加载、加载更多或监听滚动条位置；
- 百度搜索框，搜索联想功能；
- 防止高频点击提交，防止表单重复提交；

### 4. 函数防抖和节流的比较

1. 相同点

>都可以通过使用 setTimeout 实现。
>目的都是，降低回调执行频率，节省计算资源。

2. 不同点

>函数防抖: 在一段连续操作结束后，处理回调，关注一定时间连续触发的事件只在最后执行一次。
>函数节流: 在一段连续操作中，每一段时间只执行一次，侧重于一段时间内只执行一次。