<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript总结</title>
    <link href="/2024/05/09/JavaScript%E6%80%BB%E7%BB%93/"/>
    <url>/2024/05/09/JavaScript%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4 id="1-介绍-js-的基本数据类型。"><a href="#1-介绍-js-的基本数据类型。" class="headerlink" title="1. 介绍 js 的基本数据类型。"></a>1. 介绍 js 的基本数据类型。</h4><p>&nbsp;&nbsp;<code>js</code>一共有七种基本数据类型，分别是<code>Undefined、Null、Boolean、Number、String</code>，还有在 <code>ES6</code> 中新增的 <code>Symbol</code> 和 <code>ES10</code> 中新增的 <code>BigInt</code> 类型。<br>&nbsp;&nbsp;<code>Symbol</code> 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。<br>&nbsp;&nbsp;<code>BigInt</code> 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 <code>BigInt</code> 可以安全地存储和操作大整数，即使这个数已经超出了 <code>Number</code> 能够表示的安全整数范围。</p><h4 id="2-JavaScript-有几种类型的值？你能画一下他们的内存图吗？"><a href="#2-JavaScript-有几种类型的值？你能画一下他们的内存图吗？" class="headerlink" title="2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？"></a>2. JavaScript 有几种类型的值？你能画一下他们的内存图吗？</h4><p><strong>涉及知识点：</strong></p><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><p>两种类型的区别是：存储位置不同。<br>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</p><p>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p><p><strong>回答：</strong></p><ul><li>js 可以分为两种类型的值，一种是基本数据类型，一种是引用数据类型。</li><li>基本数据类型….（参考1）</li><li>引用数据类型指的是 Object 类型，所有其他的如 Array、Date 等数据类型都可以理解为 Object 类型的子类。</li><li>两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值。</li></ul><p>详细资料可以参考：<br>  <a href="https://blog.csdn.net/lxcao/article/details/52749421">《JavaScript 有几种类型的值？》</a><br>  <a href="https://blog.csdn.net/jiangjuanjaun/article/details/80327342">《JavaScript 有几种类型的值？能否画一下它们的内存图；》</a></p><h4 id="3-什么是堆？什么是栈？它们之间有什么区别和联系？"><a href="#3-什么是堆？什么是栈？它们之间有什么区别和联系？" class="headerlink" title="3. 什么是堆？什么是栈？它们之间有什么区别和联系？"></a>3. 什么是堆？什么是栈？它们之间有什么区别和联系？</h4><ul><li>堆和栈的概念存在于数据结构中和操作系统内存中。</li><li>在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全二叉树是堆的一种实现方式。</li><li>在操作系统中，内存被分为栈区和堆区。</li><li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li><li>堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。</li></ul><p>详细资料可以参考：<a href="https://www.zhihu.com/question/19729973">《什么是堆？什么是栈？他们之间有什么区别和联系？》</a></p><h4 id="4-内部属性-Class-是什么？"><a href="#4-内部属性-Class-是什么？" class="headerlink" title="4. 内部属性 [[Class]] 是什么？"></a><font color="red">4. 内部属性 [[Class]] 是什么？</font></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*所有 typeof 返回值为 &quot;object&quot; 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非</span><br><span class="hljs-comment">传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看。例如：*/</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] );<br><span class="hljs-comment">// &quot;[object Array]&quot;</span><br><br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>( <span class="hljs-regexp">/regex-literal/i</span> );<br><span class="hljs-comment">// &quot;[object RegExp]&quot;</span><br><br><span class="hljs-comment">// 我们自己创建的类就不会有这份特殊待遇，因为 toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签</span><br><span class="hljs-comment">// 默认情况类的[[Class]]返回[object Object]</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class1</span> &#123;&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class1</span>()); <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-comment">// 需要定制[[Class]]</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Class2</span> &#123;<br>  get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Class2&quot;</span>;<br>  &#125;<br>&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class2</span>()); <span class="hljs-comment">// &quot;[object Class2]&quot;</span><br></code></pre></td></tr></table></figure><h4 id="5-介绍-js-有哪些内置对象？"><a href="#5-介绍-js-有哪些内置对象？" class="headerlink" title="5. 介绍 js 有哪些内置对象？"></a>5. 介绍 js 有哪些内置对象？</h4><p><strong>涉及知识点：</strong></p><p>&nbsp;&nbsp;全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p><p>标准内置对象的分类:</p><ol><li>值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例: <code>Infinity、NaN、undefined、null</code> 字面量</li><li>函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例: <code>eval()、parseFloat()、parseInt()</code> 等</li><li>基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例: <code>Object、Function、Boolean、Symbol、Error</code> 等</li><li>数字和日期对象，用来表示数字、日期和执行数学计算的对象。例: <code>Number、Math、Date</code></li><li>字符串，用来表示和操作字符串的对象。例: <code>String、RegExp</code></li><li>可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例: <code>Array</code></li><li>使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。例: <code>Map、Set、WeakMap、WeakSet</code></li><li>矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。例: <code>SIMD</code> 等</li><li>结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例: <code>JSON</code> 等</li><li>控制抽象对象。例: <code>Promise、Generator</code> 等</li><li>反射。例: <code>Reflect、Proxy</code></li><li>国际化，为了支持多语言处理而加入 ECMAScript 的对象。例: <code>Intl、Intl.Collator</code> 等</li><li>WebAssembly。</li><li>其他。例: <code>arguments</code></li></ol><p><strong>回答：</strong></p><p>&nbsp;&nbsp;<code>js</code> 中的内置对象主要指的是在程序执行前存在全局作用域里的由 <code>js</code> 定义的一些全局值属性、函数和用来实例化其他对象的构造函<br>数对象。一般我们经常用到的如全局变量值 <code>NaN、undefined</code>，全局函数如 <code>parseInt()、parseFloat() </code>用来实例化对象的构<br>造函数如 <code>Date、Object</code> 等，还有提供数学计算的单体内置对象如 <code>Math</code> 对象。</p><p>详细资料可以参考：<br>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects">《标准内置对象的分类》</a><br>  <a href="https://segmentfault.com/a/1190000011467723#articleHeader24">《JS 所有内置对象属性和方法汇总》</a></p><h4 id="6-undefined-与-undeclared-的区别？"><a href="#6-undefined-与-undeclared-的区别？" class="headerlink" title="6. undefined 与 undeclared 的区别？"></a>6. undefined 与 undeclared 的区别？</h4><ul><li>已在作用域中声明但还没有赋值的变量，是 <code>undefined</code> 的。相反，还没有在作用域中声明过的变量，是 <code>undeclared</code> 的。</li><li>对于 <code>undeclared</code> 变量的引用，浏览器会报引用错误，如 <code>ReferenceError: b is not defined</code> 。</li><li>并且 <code>typeof</code> 对 <code>undefined</code> 和 <code>undeclared</code> 变量返回的都是<code>undefined</code>。其实<code>&quot;undefined&quot;</code> 和<code>&quot;is not defined&quot;</code>是两码事。</li></ul><h4 id="7-null-和-undefined-的区别？"><a href="#7-null-和-undefined-的区别？" class="headerlink" title="7. null 和 undefined 的区别？"></a>7. null 和 undefined 的区别？</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade">首先 <span class="hljs-literal">Undefined</span> 和 <span class="hljs-literal">Null</span> 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 <span class="hljs-literal">undefined</span> 和 <span class="hljs-literal">null</span>。<br><br><span class="hljs-literal">undefined</span> 代表的含义是未定义，<span class="hljs-literal">null</span> 代表的含义是空对象。一般变量声明了但还没有赋值的时候会返回 <span class="hljs-literal">undefined</span>，<span class="hljs-literal">null</span><br>主要用于赋值给一些可能会返回对象的变量，作为初始化。<br><br><span class="hljs-literal">undefined</span> 在 js 中不是一个保留字，这意味着我们可以使用 <span class="hljs-literal">undefined</span> 来作为一个变量名，这样的做法是非常危险的，它<br>会影响我们对 <span class="hljs-literal">undefined</span> 值的判断。但是我们可以通过一些方法获得安全的 <span class="hljs-literal">undefined</span> 值，比如说 <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>。<br><br>当我们对两种类型使用 <span class="hljs-built_in">typeof</span> 进行判断的时候，<span class="hljs-literal">Null</span> 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等<br>号对两种类型的值进行比较时会返回 <span class="hljs-literal">true</span>，使用三个等号时会返回 <span class="hljs-literal">false</span>。<br><span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>    <span class="hljs-comment">// true</span><br><span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>   <span class="hljs-comment">// false   数据类型不同</span><br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="http://cavszhouyou.top/">《JavaScript 深入理解之 undefined 与 null》</a></p><h4 id="8-如何获取安全的-undefined-值？"><a href="#8-如何获取安全的-undefined-值？" class="headerlink" title="8. 如何获取安全的 undefined 值？"></a>8. 如何获取安全的 undefined 值？</h4><p>&nbsp;&nbsp;因为 <code>undefined</code> 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 <code>undefined</code> 的正常判断。</p><p>&nbsp;&nbsp;表达式 <code>void ___</code> 没有返回值，因此返回结果是 <code>undefined。void</code> 并不改变表达式的结果，只是让表达式不返回值。</p><ul><li>按惯例我们用 <code>void 0</code> 来获得 <code>undefined</code>。</li><li>除了防止被重写外，还可以减少字节。<code>void 0</code> 代替 <code>undefined</code>省3个字节。（老司机常用）</li></ul><h4 id="9-说几条写-JavaScript-的基本规范？"><a href="#9-说几条写-JavaScript-的基本规范？" class="headerlink" title="9. 说几条写 JavaScript 的基本规范？"></a>9. 说几条写 JavaScript 的基本规范？</h4><p>在平常项目开发中，我们遵守一些这样的基本规范，比如说：</p><ol><li>一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 <code>var</code> 声明，不允许出现两个连续的 <code>var</code> 声明，声明时如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。</li><li>代码中出现地址、时间等字符串时需要使用常量代替。</li><li>在进行比较的时候吧，尽量使用<code>&#39;===&#39;, &#39;!==&#39;</code>代替<code>&#39;==&#39;, &#39;!=&#39;</code>。</li><li>不要在内置对象的原型上添加方法，如 <code>Array, Date</code>。</li><li><code>switch</code> 语句必须带有 <code>default</code> 分支。</li><li><code>for</code> 循环必须使用大括号。</li><li><code>if</code> 语句必须使用大括号。</li></ol><h4 id="10-JavaScript-原型，原型链？-有什么特点？"><a href="#10-JavaScript-原型，原型链？-有什么特点？" class="headerlink" title="10. JavaScript 原型，原型链？ 有什么特点？"></a>10. JavaScript 原型，原型链？ 有什么特点？</h4><p><strong>什么是原型对象:</strong></p><ol><li>每个函数都有一个<code>prototype</code>属性，该属性指向的是原型对象(显示原型对象)</li><li>每个实例对象身上都有一个<code>__proto__</code>属性，该属性指向的也是原型对象(隐式原型对象)</li><li>构造函数的显示原型 <code>===</code> 当前构造函数实例对象的隐式原型对象</li><li>原型对象的本质： 普通的<code>Object</code>实例</li></ol><p><strong>什么是原型链：</strong></p><ol><li>查找对象的属性的时候现在自身找，如果自身没有沿着<code>__proto__</code>找原型对象</li><li>如果原型对象上还没有，继续沿着<code>__proto__</code>,直到找到<code>Object</code>的原型对象</li><li>如果还没有找到返回<code>undefined</code></li><li>原型链：沿着<code>__proto__</code>查找属性(方法)的这条链就是原型链</li></ol><p>详细资料可以参考：<a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE.html">《JavaScript 深入理解之原型与原型链》</a></p><h4 id="11-js-获取原型的方法？"><a href="#11-js-获取原型的方法？" class="headerlink" title="11. js 获取原型的方法？"></a>11. js 获取原型的方法？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">R</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-keyword">var</span> one = <span class="hljs-keyword">new</span> <span class="hljs-title function_">R</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(one));<span class="hljs-comment">//官方推荐，规范写法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(one.<span class="hljs-property">proto</span>);<span class="hljs-comment">//不报错，不推荐</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(one.<span class="hljs-property">constructor</span>.<span class="hljs-property">proto</span>)<span class="hljs-comment">//同上</span><br></code></pre></td></tr></table></figure><h4 id="12-在-js-中不同进制数字的表示方式"><a href="#12-在-js-中不同进制数字的表示方式" class="headerlink" title="12. 在 js 中不同进制数字的表示方式"></a>12. 在 js 中不同进制数字的表示方式</h4><ul><li><p>以 0X、0x 开头的表示为十六进制。</p></li><li><p>以 0、0O、0o 开头的表示为八进制。</p></li><li><p>以 0B、0b 开头的表示为二进制格式。</p></li></ul><h4 id="13-js-中整数的安全范围是多少？"><a href="#13-js-中整数的安全范围是多少？" class="headerlink" title="13. js 中整数的安全范围是多少？"></a>13. js 中整数的安全范围是多少？</h4><p>&nbsp;&nbsp;安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数是 <code>2^53 - 1</code>，即<code>9007199254740991</code>，在 <code>ES6</code> 中被定义为 <code>Number.MAX_SAFE_INTEGER</code>。最小整数是<code>-9007199254740991</code>，在 ES6 中被定义为 <code>Number.MIN_SAFE_INTEGER</code>。</p><p>&nbsp;&nbsp;如果某次计算的结果得到了一个超过 <code>JavaScript</code> 数值范围的值，那么这个值会被自动转换为特殊的 <code>Infinity</code> 值。如果某次计算返回了正或负的 <code>Infinity</code> 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 <code>isFinite</code> 函数来判断。</p><h4 id="14-typeof-NaN-的结果是什么？"><a href="#14-typeof-NaN-的结果是什么？" class="headerlink" title="14. typeof NaN 的结果是什么？"></a><font color="red">14. typeof NaN 的结果是什么？</font></h4><p>&nbsp;&nbsp;<code>NaN</code> 意指“不是一个数字”（not a number），<code>NaN</code> 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出<br>数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p><p><code>typeof NaN; // &quot;number&quot;</code><br><code>NaN</code> 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x &#x3D;&#x3D;&#x3D; x 不成立）的值。而 <code>NaN != NaN</code>为 <code>true</code>。</p><h2 id="15-isNaN-和-Number-isNaN-函数的区别？"><a href="#15-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="15. isNaN 和 Number.isNaN 函数的区别？"></a>15. isNaN 和 Number.isNaN 函数的区别？</h2><p>&nbsp;&nbsp;函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</p><p>&nbsp;&nbsp;函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为准确。</p><h4 id="16-Array-构造函数只有一个参数值时的表现？"><a href="#16-Array-构造函数只有一个参数值时的表现？" class="headerlink" title="16. Array 构造函数只有一个参数值时的表现？"></a>16. Array 构造函数只有一个参数值时的表现？</h4><p>&nbsp;&nbsp;<code>Array</code> 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度<code>length</code>，而非只充当数组中的一个元素。这样<br>创建出来的只是一个空数组，只不过它的 <code>length</code> 属性被设置成了指定的值。</p><p>&nbsp;&nbsp;构造函数 <code>Array(..)</code> 不要求必须带 <code>new</code> 关键字。不带时，它会被自动补上。</p><h4 id="17-其他值到字符串的转换规则？"><a href="#17-其他值到字符串的转换规则？" class="headerlink" title="17. 其他值到字符串的转换规则？"></a>17. 其他值到字符串的转换规则？</h4><p><strong>规范的 9.8 节中定义了抽象操作 ToString ，它负责处理非字符串到字符串的强制类型转换:</strong></p><ol><li><code>Null</code> 和 <code>Undefined</code> 类型 ，<code>null</code> 转换为 <code>&quot;null&quot;</code>，<code>undefined</code> 转换为 <code>&quot;undefined&quot;</code>。</li><li><code>Boolean</code> 类型，<code>true</code> 转换为 <code>&quot;true&quot;</code>，<code>false</code> 转换为 <code>&quot;false&quot;</code>。</li><li><code>Number</code> 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</li><li><code>Symbol</code> 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</li><li>对普通对象来说，除非自行定义 <code>toString()</code> 方法，否则会调用 <code>toString(): Object.prototype.toString()</code>来返回内部属性 <code>[[Class]]</code> 的值，如<code>&quot;[object Object]&quot;</code>。如果对象有自己的 <code>toString()</code> 方法，字符串化时就会调用该方法并使用其返回值。</li></ol><h4 id="18-其他值到数字值的转换规则？"><a href="#18-其他值到数字值的转换规则？" class="headerlink" title="18. 其他值到数字值的转换规则？"></a>18. 其他值到数字值的转换规则？</h4><p>&nbsp;&nbsp;有时我们需要将非数字值当作数字来使用，比如数学运算。为此 ES5 规范在 9.3 节定义了抽象操作 ToNumber。</p><ol><li><code>Undefined</code> 类型的值转换为 <code>NaN</code>。</li><li><code>Null</code> 类型的值转换为 <code>0</code>。</li><li><code>Boolean</code> 类型的值，<code>true</code> 转换为 <code>1</code>，<code>false</code> 转换为 <code>0</code>。</li><li><code>String</code> 类型的值转换如同使用 <code>Number()</code> 函数进行转换，如果包含非数字值则转换为 <code>NaN</code>，空字符串为 <code>0</code>。</li><li><code>Symbol</code> 类型的值不能转换为数字，会报错。</li><li>对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</li></ol><p>&nbsp;&nbsp;为了将值转换为相应的基本类型值，抽象操作 <code>ToPrimitive</code> 会首先（通过内部操作 DefaultValue）检查该值是否有<code>valueOf()</code> 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 <code>toString()</code> 的返回值（如果存在）来进行强制类型转换。</p><p>&nbsp;&nbsp;如果 <code>valueOf()</code> 和 <code>toString()</code> 均不返回基本类型值，会产生 <code>TypeError</code> 错误。</p><h4 id="19-其他值到布尔类型的值的转换规则？"><a href="#19-其他值到布尔类型的值的转换规则？" class="headerlink" title="19. 其他值到布尔类型的值的转换规则？"></a>19. 其他值到布尔类型的值的转换规则？</h4><p>  ES5 规范 9.2 节中定义了抽象操作 ToBoolean，列举了布尔强制类型转换所有可能出现的结果。<br>  <strong>以下这些是假值：</strong></p><ul><li>undefined</li><li>null</li><li>false</li><li>+0、-0 和 NaN</li><li>“”(空串)<br>  假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</li></ul><h4 id="20-和-的-valueOf-和-toString-的结果是什么？"><a href="#20-和-的-valueOf-和-toString-的结果是什么？" class="headerlink" title="20. {} 和 [] 的 valueOf 和 toString 的结果是什么？"></a><font color="red">20. {} 和 [] 的 valueOf 和 toString 的结果是什么？</font></h4><p><code>&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;</code></p><p><code>[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot; （空串）</code></p><h4 id="21-什么是假值对象？"><a href="#21-什么是假值对象？" class="headerlink" title="21. 什么是假值对象？"></a>21. 什么是假值对象？</h4><p>&nbsp;&nbsp;浏览器在某些特定情况下，在常规 <code>JavaScript</code> 语法基础上自己创建了一些外来值，这些就是“假值对象”。假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 <code>false</code> 最常见的例子是 <code>document.all</code>，它是一个类数组对象，包含了页面上的所有元素，由 <code>DOM(而不是 JavaScript 引擎)</code>提供给 <code>JavaScript</code> 程序使用。</p><h4 id="22-操作符的作用？"><a href="#22-操作符的作用？" class="headerlink" title="22. ~ 操作符的作用？"></a>22. ~ 操作符的作用？</h4><p>&nbsp;&nbsp;这是js中的一元操作符：按位取反。<br>&nbsp;&nbsp;~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。</p><p>&nbsp;&nbsp;~x 大致等同于 -(x+1)。</p><h4 id="23-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"><a href="#23-解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？" class="headerlink" title="23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？"></a>23. 解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字，它们之间的区别是什么？</h4><p>&nbsp;&nbsp;解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如 Number ()）不允许出现非数字字符，否则会失败并返回 NaN。</p><h4 id="24-操作符什么时候用于字符串的拼接？"><a href="#24-操作符什么时候用于字符串的拼接？" class="headerlink" title="24. + 操作符什么时候用于字符串的拼接？"></a>24. <code>+</code> 操作符什么时候用于字符串的拼接？</h4><p>&nbsp;&nbsp;根据 ES5 规范 11.6.1 节，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</p><p>&nbsp;&nbsp;简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。</p><p>&nbsp;&nbsp;那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p><h4 id="25-什么情况下会发生布尔值的隐式强制类型转换？"><a href="#25-什么情况下会发生布尔值的隐式强制类型转换？" class="headerlink" title="25. 什么情况下会发生布尔值的隐式强制类型转换？"></a>25. 什么情况下会发生布尔值的隐式强制类型转换？</h4><ol><li>if (..) 语句中的条件判断表达式。</li><li>for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。</li><li>while (..) 和 do..while(..) 循环中的条件判断表达式。</li><li>? : 中的条件判断表达式。</li><li>逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</li></ol><h4 id="26-和-操作符的返回值？"><a href="#26-和-操作符的返回值？" class="headerlink" title="26. || 和 &amp;&amp; 操作符的返回值？"></a>26. || 和 &amp;&amp; 操作符的返回值？</h4><ul><li><code>||</code> 和 <code>&amp;&amp;</code> 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 <code>ToBoolean</code> 强制类型转换，然后再执行条件判断。</li><li>对于 <code>||</code> 来说，如果条件判断结果为 <code>true</code> 就返回第一个操作数的值，如果为 <code>false</code> 就返回第二个操作数的值。</li><li><code>&amp;&amp;</code>则相反，如果条件判断结果为 <code>true</code> 就返回第二个操作数的值，如果为 <code>false</code> 就返回第一个操作数的值。</li><li><code>||</code> 和 <code>&amp;&amp;</code> 返回它们其中一个操作数的值，而非条件判断的结果。</li></ul><h4 id="27-Symbol-值的强制类型转换？"><a href="#27-Symbol-值的强制类型转换？" class="headerlink" title="27. Symbol 值的强制类型转换？"></a>27. Symbol 值的强制类型转换？</h4><ul><li><code>ES6</code> 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。</li><li><code>Symbol</code> 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是 true ）。</li></ul><h4 id="28-操作符的强制类型转换规则？"><a href="#28-操作符的强制类型转换规则？" class="headerlink" title="28. &#x3D;&#x3D; 操作符的强制类型转换规则？"></a>28. &#x3D;&#x3D; 操作符的强制类型转换规则？</h4><ol><li>字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。</li><li>其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。</li><li><code>null</code> 和<code> undefined</code> 之间的相等比较，结果为真。其他值和它们进行比较都返回假值。</li><li>对象和非对象之间的相等比较，对象先调用 <code>ToPrimitive</code> 抽象操作后，再进行比较。</li><li>如果一个操作值为 <code>NaN</code> ，则相等比较返回 <code>false</code>（ <code>NaN</code> 本身也不等于 <code>NaN</code> ）。</li><li>如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。</li></ol><p>详细资料可以参考：<a href="https://www.jeffjade.com/2015/08/28/2015-09-02-js-string-compare/">《JavaScript 字符串间的比较》</a></p><h4 id="29-如何将字符串转化为数字，例如-‘12-3b’"><a href="#29-如何将字符串转化为数字，例如-‘12-3b’" class="headerlink" title="29. 如何将字符串转化为数字，例如 ‘12.3b’?"></a>29. 如何将字符串转化为数字，例如 ‘12.3b’?</h4><ol><li>使用 <code>Number()</code> 方法，前提是所包含的字符串不包含不合法字符。</li><li>使用 <code>parseInt()</code> 方法，<code>parseInt()</code> 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，<code>parseInt()</code> 会根据 <code>string</code> 来判断数字的基数。</li><li>使用 <code>parseFloat()</code> 方法，该函数解析一个字符串参数并返回一个浮点数。</li><li>使用 <code>+</code> 操作符的隐式转换。</li></ol><p>详细资料可以参考：<a href="https://blog.csdn.net/m0_38099607/article/details/72638678">《详解 JS 中 Number()、parseInt() 和 parseFloat() 的区别》</a></p><h4 id="30-如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』"><a href="#30-如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』" class="headerlink" title="30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?"></a>30. 如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 方法一</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">format</span>(<span class="hljs-params">number</span>) &#123;<br>    <span class="hljs-comment">// ?=这表示一个环视的语法，表示该位置后面的字符指定规则</span><br>  <span class="hljs-keyword">return</span> number &amp;&amp; number.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\d)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">$1, $2</span>) &#123;<br>        <span class="hljs-keyword">return</span> $2 + <span class="hljs-string">&#x27;,&#x27;</span>;<br>       &#125;)<br>&#125;<br><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">format1</span>(<span class="hljs-params">number</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Intl</span>.<span class="hljs-title class_">NumberFormat</span>().<span class="hljs-title function_">format</span>(number)<br>&#125;<br><span class="hljs-comment">// 方法三</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">format2</span>(<span class="hljs-params">number</span>) &#123;<br>  <span class="hljs-keyword">return</span> number.<span class="hljs-title function_">toLocaleString</span>(<span class="hljs-string">&#x27;en&#x27;</span>)   <span class="hljs-comment">// 换成当地的字符串格式</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="31-常用正则表达式"><a href="#31-常用正则表达式" class="headerlink" title="31. 常用正则表达式"></a>31. 常用正则表达式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// （1）匹配 16 进制颜色值</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;<br><br><span class="hljs-comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;<br><br><span class="hljs-comment">// （3）匹配 qq 号</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;<br><br><span class="hljs-comment">// （4）手机号码正则</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^1[345789]\d&#123;9&#125;$/g</span>;<br><br><span class="hljs-comment">// （5）用户名正则</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/</span>;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br>  <a href="http://caibaojian.com/form-regexp.html">《前端表单验证常用的 15 个 JS 正则表达式》</a><br>  <a href="https://www.jianshu.com/p/1cb5229325a7">《JS 常用正则汇总》</a></p><h4 id="32-生成随机数的各种方法？"><a href="#32-生成随机数的各种方法？" class="headerlink" title="32. 生成随机数的各种方法？"></a>32. 生成随机数的各种方法？</h4><p>Math.random() 生成0-1（包括0不包括1的随机数）</p><h4 id="33-如何实现数组的随机排序？"><a href="#33-如何实现数组的随机排序？" class="headerlink" title="33. 如何实现数组的随机排序？"></a>33. 如何实现数组的随机排序？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// （1）使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置。</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">randomSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &gt; <span class="hljs-number">0.5</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;  )      <br>&#125;<br><br><span class="hljs-comment">//  缺点：每个元素被派到新数组的位置不是随机的，原因是 sort() 方法是依次比较的。</span><br><br><span class="hljs-comment">// （2）随机从原数组抽取一个元素，加入到新数组</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">randomSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">var</span> result = [];<br><br>  <span class="hljs-keyword">while</span> (arr.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">var</span> randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * arr.<span class="hljs-property">length</span>);<br>    result.<span class="hljs-title function_">push</span>(arr[randomIndex]);<br>    arr.<span class="hljs-title function_">splice</span>(randomIndex, <span class="hljs-number">1</span>);   <span class="hljs-comment">// 删除原数组中随机下标位置的值</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// （3）随机交换数组内的元素（洗牌算法类似）</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">randomSort</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">var</span> index,<br>    randomIndex,<br>    temp,<br>    len = arr.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; len; index++) &#123;<br>      <span class="hljs-comment">// 向下取整（最大 - 最小 + 1） + 最小 （+1） // 避免自己跟自己交换</span><br>    randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (len - index)) + index (+ <span class="hljs-number">1</span>) ;<br><br>    temp = arr[index];<br>    arr[index] = arr[randomIndex];<br>    arr[randomIndex] = temp;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-comment">// es6</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">randomSort</span>(<span class="hljs-params">array</span>) &#123;<br>  <span class="hljs-keyword">let</span> length = array.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-comment">// 不是数组或者数组长度小于等于1，直接返回</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(array) || length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; length - <span class="hljs-number">1</span>; index++) &#123;<br>    <span class="hljs-keyword">let</span> randomIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (length - index)) + index;<br><br>    [array[index], array[randomIndex]] = [array[randomIndex], array[index]];<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br>  <a href="https://gaohaoyang.github.io/2016/10/16/shuffle-algorithm/#top">《Fisher and Yates 的原始版》</a><br>  <a href="https://www.zhihu.com/question/32303195">《javascript 实现数组随机排序?》</a><br>  <a href="https://www.w3cplus.com/javascript/how-to-randomize-shuffle-a-javascript-array.html">《JavaScript 学习笔记：数组随机排序》</a></p><h4 id="34-javascript-创建对象的几种方式？"><a href="#34-javascript-创建对象的几种方式？" class="headerlink" title="34. javascript 创建对象的几种方式？"></a>34. javascript 创建对象的几种方式？</h4><p>&nbsp;&nbsp;我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js<br>和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象<br>创建方式，我了解到的方式有这么几种：</p><ol><li><p>第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 工厂函数: 返回一个需要的数据的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">name</span>: name,<br>    <span class="hljs-attr">age</span>: age<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;kobe&#x27;</span>, <span class="hljs-number">43</span>);<br></code></pre></td></tr></table></figure></li><li><p>第二种是构造函数模式。<code>js</code> 中每一个函数都可以作为构造函数，只要一个函数是通过 <code>new</code> 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 <code>prototype</code> 属性，然后将执行上下文中的 <code>this</code> 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 <code>this</code> 的值指向了新建的对象，因此我们可以使用 <code>this</code> 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 <code>js</code> 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</p></li><li><p>第三种模式是原型模式，因为每一个函数都有一个 <code>prototype</code> 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 <code>Array</code> 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</p></li><li><p>第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</p></li><li><p>第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</p></li><li><p>第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</p></li></ol><p>详细资料可以参考：<a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.html">《JavaScript 深入理解之对象创建》</a></p><h4 id="35-JavaScript-继承的几种实现方式？"><a href="#35-JavaScript-继承的几种实现方式？" class="headerlink" title="35. JavaScript 继承的几种实现方式？"></a>35. JavaScript 继承的几种实现方式？</h4><p><strong>我了解的 js 中实现继承的几种方式有：</strong></p><ol><li><p>第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p></li><li><p>第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p></li><li><p>第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p></li><li><p>第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</p></li><li><p>第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</p></li><li><p>第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p></li></ol><p>详细资料可以参考：<a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E7%BB%A7%E6%89%BF.html">《JavaScript 深入理解之继承》</a></p><h4 id="36-寄生式组合继承的实现？"><a href="#36-寄生式组合继承的实现？" class="headerlink" title="36. 寄生式组合继承的实现？"></a>36. 寄生式组合继承的实现？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;My name is &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;.&quot;</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name, grade</span>) &#123;<br>  <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = grade;<br>&#125;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);  <span class="hljs-comment">// 子类的原型等价于父类的实例，指向父类的原型</span><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Student</span>;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayMyGrade</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;My grade is &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> + <span class="hljs-string">&quot;.&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="37-Javascript-的作用域链？"><a href="#37-Javascript-的作用域链？" class="headerlink" title="37. Javascript 的作用域链？"></a>37. Javascript 的作用域链？</h4><p>&nbsp;&nbsp;作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。</p><p>&nbsp;&nbsp;作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p><p>当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。</p><p>作用域链的创建过程跟执行上下文的建立有关….</p><p>详细资料可以参考：<a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html">《JavaScript 深入理解之作用域链》</a></p><h4 id="38-谈谈-This-对象的理解。"><a href="#38-谈谈-This-对象的理解。" class="headerlink" title="38. 谈谈 This 对象的理解。"></a>38. 谈谈 This 对象的理解。</h4><p>&nbsp;&nbsp;<code>this</code> 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，<code>this</code> 的指向可以通过四种调用模<br>式来判断。</p><ol><li>第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，<code>this</code> 指向全局对象。</li><li>第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，<code>this</code> 指向这个对象。</li><li>第三种是构造器调用模式，如果一个函数用 <code>new</code> 调用时，函数执行前会新创建一个对象，<code>this</code> 指向这个新创建的对象。</li><li>第四种是 <code>apply 、 call</code> 和 <code>bind</code> 调用模式，这三个方法都可以显示的指定调用函数的 <code>this</code> 指向。其中 <code>apply</code> 方法接收两个参数：一个是 <code>this</code> 绑定的对象，一个是参数数组。<code>call</code> 方法接收的参数，第一个是 <code>this</code> 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 <code>cal()</code> 方法时，传递给函数的参数必须逐个列举出来。<code>bind</code> 方法通过传入一个对象，返回一个 <code>this</code> 绑定了传入对象的新函数。这个函数的 <code>this</code> 指向除了使用 <code>new</code> 时会被改变，其他情况下都不会改变。</li></ol><p>&nbsp;&nbsp;这四种方式，使用构造器调用模式的优先级最高，然后是 <code>apply 、 call</code> 和 <code>bind</code> 调用模式，然后是方法调用模式，然后是函数调用模式。</p><p><a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8Bthis%E8%AF%A6%E8%A7%A3.html">《JavaScript 深入理解之 this 详解》</a></p><h4 id="39-eval-是做什么的？"><a href="#39-eval-是做什么的？" class="headerlink" title="39. eval 是做什么的？"></a>39. eval 是做什么的？</h4><p>它的功能是把对应的字符串解析成 JS 代码并运行。</p><p>应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。</p><p>详细资料可以参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval">《eval()》</a></p><h4 id="40-什么是-DOM-和-BOM？"><a href="#40-什么是-DOM-和-BOM？" class="headerlink" title="40. 什么是 DOM 和 BOM？"></a>40. 什么是 DOM 和 BOM？</h4><p>&nbsp;&nbsp;<code>DOM</code> 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</p><p>&nbsp;&nbsp;<code>BOM</code> 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的方法和接口。<code>BOM</code>的核心是<code>window</code>，而 <code>window</code> 对象具有双重角色，它既是通过 <code>js</code> 访问浏览器窗口的一个接口，又是一个 <code>Global</code>（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。<code>window</code> 对象含有 <code>location</code> 对象、<code>navigator</code> 对象、<code>screen</code> 对象、<code>history</code>对象等子对象，并且 <code>DOM</code> 的最根本的对象 <code>document</code> 对象也是 <code>BOM</code> 的 <code>window</code> 对象的子对象。</p><p>详细资料可以参考：<br>  <a href="https://www.zhihu.com/question/33453164">《DOM, DOCUMENT, BOM, WINDOW 有什么区别?》</a><br>  <a href="http://www.w3school.com.cn/jsref/dom_obj_window.asp">《Window 对象》</a><br>  <a href="https://www.zhihu.com/question/20724662">《DOM 与 BOM 分别是什么，有何关联？》</a><br>  <a href="https://segmentfault.com/a/1190000000654274#articleHeader21">《JavaScript 学习总结（三）BOM 和 DOM 详解》</a></p><h4 id="41-写一个通用的事件侦听器函数。"><a href="#41-写一个通用的事件侦听器函数。" class="headerlink" title="41. 写一个通用的事件侦听器函数。"></a>41. 写一个通用的事件侦听器函数。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EventUtils</span> = &#123;<br>  <span class="hljs-comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span><br>  <span class="hljs-comment">// 添加事件</span><br>  <span class="hljs-attr">addEvent</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">element, type, handler</span>) &#123;<br>    <span class="hljs-keyword">if</span> (element.<span class="hljs-property">addEventListener</span>) &#123;<br>      element.<span class="hljs-title function_">addEventListener</span>(type, handler, <span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.<span class="hljs-property">attachEvent</span>) &#123;<br>      element.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">&quot;on&quot;</span> + type, handler);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      element[<span class="hljs-string">&quot;on&quot;</span> + type] = handler;<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-comment">// 移除事件</span><br>  <span class="hljs-attr">removeEvent</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">element, type, handler</span>) &#123;<br>    <span class="hljs-keyword">if</span> (element.<span class="hljs-property">removeEventListener</span>) &#123;<br>      element.<span class="hljs-title function_">removeEventListener</span>(type, handler, <span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.<span class="hljs-property">detachEvent</span>) &#123;<br>      element.<span class="hljs-title function_">detachEvent</span>(<span class="hljs-string">&quot;on&quot;</span> + type, handler);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      element[<span class="hljs-string">&quot;on&quot;</span> + type] = <span class="hljs-literal">null</span>;<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-comment">// 获取事件目标</span><br>  <span class="hljs-attr">getTarget</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">return</span> event.<span class="hljs-property">target</span> || event.<span class="hljs-property">srcElement</span>;<br>  &#125;,<br><br>  <span class="hljs-comment">// 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span><br>  <span class="hljs-attr">getEvent</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">return</span> event || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>;<br>  &#125;,<br><br>  <span class="hljs-comment">// 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span><br>  <span class="hljs-attr">stopPropagation</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">stopPropagation</span>) &#123;<br>      event.<span class="hljs-title function_">stopPropagation</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      event.<span class="hljs-property">cancelBubble</span> = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-comment">// 取消事件的默认行为</span><br>  <span class="hljs-attr">preventDefault</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">preventDefault</span>) &#123;<br>      event.<span class="hljs-title function_">preventDefault</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      event.<span class="hljs-property">returnValue</span> = <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://segmentfault.com/a/1190000006934031#articleHeader6">《JS 事件模型》</a></p><h4 id="42-事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#42-事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>42. 事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h4><ul><li><p>1.事件是用户操作网页时发生的交互动作，比如 <code>click/move</code>， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 <code>event</code> 对象，包含了该事件发生时的所有相关信息（ <code>event</code> 的属性）以及可以对事件进行的操作（ <code>event</code> 的方法）。</p></li><li><p>2.事件处理机制：<code>IE</code> 支持事件冒泡、<code>Firefox</code> 同时支持两种事件模型，也就是：事件冒泡和事件捕获。</p></li><li><p>3.<code>event.stopPropagation()</code> 或者 <code>ie</code> 下的方法 <code>event.cancelBubble = true</code>;</p></li></ul><p>详细资料可以参考：<br>  <a href="https://www.cnblogs.com/lvdabao/p/3265870.html">《Javascript 事件模型系列（一）事件及事件的三种模型》</a><br>  <a href="https://blog.csdn.net/wuseyukui/article/details/13771493">《Javascript 事件模型：事件捕获和事件冒泡》</a></p><h4 id="43-三种事件模型是什么？"><a href="#43-三种事件模型是什么？" class="headerlink" title="43. 三种事件模型是什么？"></a>43. 三种事件模型是什么？</h4><p>&nbsp;&nbsp;事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。</p><p>&nbsp;&nbsp;第一种事件模型是最早的 <code>DOM0</code> 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 <code>js</code> 属性来指定监听函数。这种方式是所有浏览器都兼容的。</p><p>&nbsp;&nbsp;第二种事件模型是 <code>IE</code> 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 <code>document</code>，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 <code>attachEvent</code> 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</p><p>&nbsp;&nbsp;第三种是 <code>DOM2</code> 级事件模型，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 <code>document</code> 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 <code>IE</code> 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是 <code>addEventListener</code>，其中第三个参数可以指定事件是否在捕获阶段执行（默认值为<code>false</code>）。</p><p>详细资料可以参考：<a href="https://blog.csdn.net/u013217071/article/details/77613706">《一个 DOM 元素绑定多个事件时，先执行冒泡还是捕获》</a></p><h4 id="44-事件委派是什么？"><a href="#44-事件委派是什么？" class="headerlink" title="44. 事件委派是什么？"></a>44. 事件委派是什么？</h4><p>&nbsp;&nbsp;事件委派本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委派。</p><p>&nbsp;&nbsp;使用事件委派我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件委派我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</p><p>详细资料可以参考：<a href="https://zhuanlan.zhihu.com/p/26536815">《JavaScript 事件委托详解》</a></p><h4 id="45-“1”-“2”-“3”-map-parseInt-答案是多少？"><a href="#45-“1”-“2”-“3”-map-parseInt-答案是多少？" class="headerlink" title="45. [“1”, “2”, “3”].map(parseInt) 答案是多少？"></a>45. [“1”, “2”, “3”].map(parseInt) 答案是多少？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">parseInt</span>() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数(即按什么进制来解析)。（该值介于 <span class="hljs-number">2</span> ~ <span class="hljs-number">36</span> 之间，如果省略该参数或其值为 ‘<span class="hljs-number">0</span>‘，则数字将以 <span class="hljs-number">10</span> 进制来解析。如果该参数小于 <span class="hljs-number">2</span> 或者大于 <span class="hljs-number">36</span>，则 ‘<span class="hljs-built_in">parseInt</span>()‘ 将返回 ‘<span class="hljs-literal">NaN</span>‘）。<br><br><br>此处 map 传了 <span class="hljs-number">3</span> 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 <span class="hljs-string">&quot;1-0&quot;</span>, <span class="hljs-string">&quot;2-1&quot;</span>, <span class="hljs-string">&quot;3-2&quot;</span><br><br>因为字符串的值不能大于进制数，因此后面两次调用均失败，返回 <span class="hljs-literal">NaN</span> ，第一次基数为 <span class="hljs-number">0</span> ，按十进制解析返回 <span class="hljs-number">1</span>。、<br><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>  <span class="hljs-literal">NaN</span>  <span class="hljs-literal">NaN</span> <br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://blog.csdn.net/justjavac/article/details/19473199">《为什么 [“1”, “2”, “3”].map(parseInt) 返回 [1,NaN,NaN]？》</a></p><h4 id="46-什么是闭包，为什么要用它？"><a href="#46-什么是闭包，为什么要用它？" class="headerlink" title="46. 什么是闭包，为什么要用它？"></a>46. 什么是闭包，为什么要用它？</h4><p><strong>什么是闭包：</strong></p><ul><li>闭包是一个存在内部函数的引用关系</li><li>该引用指向的是外部函数的局部变量对象(前提是内部函数使用了外部函数的局部变量)</li></ul><p><strong>闭包的作用：</strong></p><ul><li>延长外部函数变量对象的生命周期</li><li>使用闭包能够间接的从函数外部访问函数内部的私有变量</li></ul><p>详细资料可以参考：<a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E9%97%AD%E5%8C%85.html">《JavaScript 深入理解之闭包》</a></p><h4 id="47-javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？"><a href="#47-javascript-代码中的-“use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？"></a>47. javascript 代码中的 “use strict”; 是什么意思 ? 使用它区别是什么？</h4><p><strong>相关知识点：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">use</span> strict 是一种 ECMAscript5 添加的（严格）运行模式，这种模式使得 Javascript 在更严格的条件下运行。<br><br>**设立<span class="hljs-string">&quot;严格模式&quot;</span>的目的，主要有以下几个：**<br></code></pre></td></tr></table></figure><ul><li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的 Javascript 做好铺垫。</li></ul><p><strong>区别：</strong></p><ul><li>1.声明定义变量必须用var</li><li>2.禁止自定义的函数中的this关键字指向全局对象</li><li>创建eval作用域, 更安全</li></ul><p><strong>回答：</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">use <span class="hljs-built_in">strict</span> 指的是严格运行模式，在这种模式对 <span class="hljs-keyword">js</span> 的使用添加了一些限制。比如说禁止 this 指向全局对象，还有声明定义<br>变量必须用var等。设立严格模式的目的，主要是为了消除代码使用中的一些不安全的使用方式，也是为了消除 <span class="hljs-keyword">js</span> 语法本身的一<br>些不合理的地方，以此来减少一些运行时的怪异的行为。同时使用严格运行模式也能够提高编译的效率，从而提高代码的运行速度。<br>我认为严格模式代表了 <span class="hljs-keyword">js</span> 一种更合理、更安全、更严谨的发展方向。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html">《Javascript 严格模式详解》</a></p><h4 id="48-如何判断一个对象是否属于某个类？"><a href="#48-如何判断一个对象是否属于某个类？" class="headerlink" title="48. 如何判断一个对象是否属于某个类？"></a>48. 如何判断一个对象是否属于某个类？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">第一种方式是使用 <span class="hljs-selector-tag">A</span> instanceof <span class="hljs-selector-tag">B</span> 运算符来判断<span class="hljs-selector-tag">B</span>构造函数的 prototype 属性是否出现在<span class="hljs-selector-tag">A</span>对象的原型链中的任何位置。<br><br>第二种方式，如果需要判断的是某个内置的引用类型的话，可以使用 <span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.prototype</span><span class="hljs-selector-class">.toString</span>() 方法来打印对象的<br><span class="hljs-selector-attr">[[Class]</span>] 属性来进行判断。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://blog.csdn.net/haitunmin/article/details/78418522">《js 判断一个对象是否属于某一类》</a></p><h4 id="49-instanceof-的作用？"><a href="#49-instanceof-的作用？" class="headerlink" title="49. instanceof 的作用？"></a>49. instanceof 的作用？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</span><br><span class="hljs-comment">// 实现：</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-params">left, right</span>) &#123;<br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(left), <span class="hljs-comment">// 获取对象的原型</span><br>    prototype = right.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// 获取构造函数的 prototype 对象</span><br><br>  <span class="hljs-comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!proto) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (proto === prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof">《instanceof》</a></p><h4 id="50-new-操作符具体干了什么呢？如何实现？"><a href="#50-new-操作符具体干了什么呢？如何实现？" class="headerlink" title="50. new 操作符具体干了什么呢？如何实现？"></a><font color="red">50. new 操作符具体干了什么呢？如何实现？</font></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// （1）首先创建了一个新的空对象</span><br><span class="hljs-comment">// （2）设置原型，将对象的原型设置为函数的 prototype 对象。</span><br><span class="hljs-comment">// （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</span><br><span class="hljs-comment">// （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</span><br><br><span class="hljs-comment">// 实现:</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectFactory</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-literal">null</span>,<br>    constructor = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>),  <span class="hljs-comment">// 拿到构造函数</span><br>    result = <span class="hljs-literal">null</span>;   <br><br>  <span class="hljs-comment">// 参数判断</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> constructor !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br>  newObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br>  <span class="hljs-comment">// 将 this 指向新建对象，并执行函数</span><br>  result = constructor.<span class="hljs-title function_">apply</span>(newObject, <span class="hljs-variable language_">arguments</span>);<br><br>  <span class="hljs-comment">// 判断返回对象</span><br>  <span class="hljs-keyword">let</span> flag =<br>    result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;function&quot;</span>);<br><br>  <span class="hljs-comment">// 判断返回结果</span><br>  <span class="hljs-keyword">return</span> flag ? result : newObject;<br>&#125;<br><br><span class="hljs-comment">// 使用方法</span><br><span class="hljs-comment">// objectFactory(构造函数, 初始化参数);</span><br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br>  <a href="https://segmentfault.com/a/1190000008576048">《new 操作符具体干了什么？》</a><br>  <a href="https://github.com/mqyqingfeng/Blog/issues/13">《JavaScript 深入之 new 的模拟实现》</a></p><h4 id="51-Javascript-中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是？"><a href="#51-Javascript-中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是？" class="headerlink" title="51. Javascript 中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是？"></a>51. Javascript 中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">hasOwnProperty<br><br>所有继承了 <span class="hljs-built_in">Object</span> 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性，和<br><span class="hljs-keyword">in</span> 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty">《Object.prototype.hasOwnProperty()》</a></p><h4 id="52-对于-JSON-的了解？"><a href="#52-对于-JSON-的了解？" class="headerlink" title="52. 对于 JSON 的了解？"></a>52. 对于 JSON 的了解？</h4><p><strong>相关知识点：</strong></p><p>&nbsp;&nbsp;<code>JSON</code> 是一种数据交换格式，基于文本，优于轻量，用于交换数据。</p><p>&nbsp;&nbsp;<code>JSON</code> 可以表示<code>数字、布尔值、字符串、null、数组（值的有序序列）</code>，以及由这些值（或数组、对象）所组成的对象（字符串与值的映射）。</p><p>&nbsp;&nbsp;<code>JSON</code> 使用 <code>JavaScript</code> 语法，但是 <code>JSON</code> 格式仅仅是一个文本。文本可以被任何编程语言读取及作为数据格式传递。</p><p><strong>回答：</strong></p><p>&nbsp;&nbsp;<code>JSON</code> 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p><p>&nbsp;&nbsp;在项目开发中，我们使用 <code>JSON</code> 作为前后端数据交换的方式。在前端我们通过将一个符合 <code>JSON</code> 格式的数据结构序列化为 <code>JSON</code> 字符串，然后将它传递到后端，后端通过 <code>JSON</code> 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p><p>&nbsp;&nbsp;因为 <code>JSON</code> 的语法是基于 <code>js</code> 的，因此很容易将 <code>JSON</code> 和 <code>js</code> 中的对象弄混，但是我们应该注意的是 <code>JSON</code> 和 <code>js</code> 中的对象不是一回事，<code>JSON</code> 中对象格式更加严格，比如说在 <code>JSON</code> 中属性值不能为函数，不能出现 <code>NaN</code> 这样的属性值等，因此大多数的 <code>js</code> 对象是不符合 <code>JSON</code> 对象的格式的。</p><p>&nbsp;&nbsp;在 <code>js</code> 中提供了两个函数来实现 <code>js</code> 数据结构和 <code>JSON</code> 格式的转换处理，一个是 <code>JSON.stringify</code> 函数，通过传入一个符合 <code>JSON</code> 格式的数据结构，将其转换为一个 <code>JSON</code> 字符串。如果传入的数据结构不符合 <code>JSON</code> 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，我们可以调用这个函数将数据对象转化为 <code>JSON</code> 格式的字符串。</p><p>&nbsp;&nbsp;另一个函数 <code>JSON.parse()</code> 函数，这个函数用来将 <code>JSON</code> 格式的字符串转换为一个 <code>js</code> 数据结构，如果传入的字符串不是标准的 <code>JSON</code> 格式的字符串的话，将会抛出错误。当我们从后端接收到 <code>JSON</code> 格式的字符串时，我们可以通过这个方法来将其解析为一个 <code>js</code> 数据结构，以此来进行数据的访问。</p><p>详细资料可以参考：<a href="https://my.oschina.net/u/3284240/blog/874368">《深入了解 JavaScript 中的 JSON 》</a></p><h4 id="53-forEach-call-““-function-a-a-style-outline-”1px-solid-”-Math-random-1"><a href="#53-forEach-call-““-function-a-a-style-outline-”1px-solid-”-Math-random-1" class="headerlink" title="53. [].forEach.call($$(““),function(a){a.style.outline&#x3D;”1px solid #”+(~~(Math.random()(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？"></a>53. [].forEach.call($$(“<em>“),function(a){a.style.outline&#x3D;”1px solid #”+(~~(Math.random()</em>(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？</h4><ol><li><p>选取页面所有 <code>DOM</code> 元素。在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素，这是现代浏览器提供的一个命令行 API 相当于<code>document.querySelectorAll</code> 方法。</p></li><li><p>循环遍历 <code>DOM</code> 元素</p></li><li><p>给元素添加 <code>outline</code> 。由于渲染的 <code>outline</code> 是不在 <code>CSS</code> 盒模型中的，所以为元素添加 <code>outline</code> 并不会影响元素的大小和页面的布局。</p></li><li><p>生成随机颜色函数。<code>Math.random()*(1&lt;&lt;24)</code> 可以得到 <code>0~2^24 - 1</code> 之间的随机数，因为得到的是一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 <code>toString(16)</code> 的方式，转换为一个十六进制的字符串。</p></li></ol><p>详细资料可以参考：<a href="https://2008winstar.iteye.com/blog/2128290">《通过一行代码学 JavaScript》</a></p><h4 id="54-js-延迟加载的方式有哪些？"><a href="#54-js-延迟加载的方式有哪些？" class="headerlink" title="54. js 延迟加载的方式有哪些？"></a><font color="blue">54. js 延迟加载的方式有哪些？</font></h4><p><strong>相关知识点：</strong></p><p>js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</p><p><strong>一般有以下几种方式：</strong></p><ul><li>defer 属性</li><li>async 属性</li><li>动态创建 DOM 方式</li><li>使用 setTimeout 延迟方法</li><li>让 JS 最后加载</li></ul><p><strong>回答：</strong></p><p>&nbsp;&nbsp;<code>js</code> 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 <code>js</code> 脚本能够尽可能的延迟加载，提高页面的渲染速度。</p><p><strong>我了解到的几种方式是：</strong></p><p>&nbsp;&nbsp;第一种方式是我们一般采用的是将 <code>js</code> 脚本放在文档的底部，来使 <code>js</code> 脚本尽可能的在最后来加载执行。</p><p>&nbsp;&nbsp;第二种方式是给 <code>js</code> 脚本添加 <code>defer</code> 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 <code>defer</code> 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</p><p>&nbsp;&nbsp;第三种方式是给 <code>js</code> 脚本添加 <code>async</code> 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 <code>js</code> 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 <code>async</code> 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</p><p>&nbsp;&nbsp;第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 <code>script</code> 标签来引入 <code>js</code> 脚本。</p><p>详细资料可以参考：<br>  <a href="https://blog.csdn.net/meijory/article/details/76389762">《JS 延迟加载的几种方式》</a><br>  <a href="http://www.w3school.com.cn/html5/att_script_async.asp">《HTML 5 <code>&lt;script&gt;</code> <code>async</code> 属性》</a></p><h4 id="55-Ajax-是什么-如何创建一个-Ajax？"><a href="#55-Ajax-是什么-如何创建一个-Ajax？" class="headerlink" title="55. Ajax 是什么? 如何创建一个 Ajax？"></a>55. Ajax 是什么? 如何创建一个 Ajax？</h4><p><strong>相关知识点：</strong></p><p>&nbsp;&nbsp;2005 年 2 月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>具体来说，AJAX 包括以下几个步骤。</p><ul><li>1.创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</li><li>2.创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</li><li>3.设置响应 HTTP 请求状态变化的函数</li><li>4.发送 HTTP 请求</li><li>5.获取异步调用返回的数据</li><li>6.使用 JavaScript 和 DOM 实现局部刷新</li></ul><p><strong>一般实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SERVER_URL</span> = <span class="hljs-string">&quot;/server&quot;</span>;<br><br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><br><span class="hljs-comment">// 创建 Http 请求</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-variable constant_">SERVER_URL</span>, <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 设置状态监听函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// 当请求成功时</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-title function_">handle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 设置请求失败时的监听函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>&#125;;<br><br><span class="hljs-comment">// 设置请求头信息</span><br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><br><span class="hljs-comment">// 发送 Http 请求</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// promise 封装实现：</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getJSON</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-comment">// 创建一个 promise 对象</span><br>  <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><br>    <span class="hljs-comment">// 新建一个 http 请求</span><br>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br><br>    <span class="hljs-comment">// 设置状态的监听函数</span><br>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br><br>      <span class="hljs-comment">// 当请求成功或失败时，改变 promise 的状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 设置错误监听函数</span><br>    xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>    &#125;;<br><br>    <span class="hljs-comment">// 设置响应的数据类型</span><br>    xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br><br>    <span class="hljs-comment">// 设置请求头信息</span><br>    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><br>    <span class="hljs-comment">// 发送 http 请求</span><br>    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>回答：</strong></p><p>&nbsp;&nbsp;我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。</p><p>创建一个 ajax 有这样几个步骤</p><p>首先是创建一个 XMLHttpRequest 对象。</p><p>然后在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</p><p>&nbsp;&nbsp;在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。</p><p>当对象的属性和监听函数设置完成后，最后我们调用 send 方法来向服务器发起请求，可以传入参数作为发送的数据体。</p><p>详细资料可以参考：<br>  <a href="https://wangdoc.com/javascript/bom/xmlhttprequest.html">《XMLHttpRequest 对象》</a><br>  <a href="https://juejin.im/post/5acde23c5188255cb32e7e76">《从 ajax 到 fetch、axios》</a><br>  <a href="https://juejin.im/post/5c160937f265da61180199b2">《Fetch 入门》</a><br>  <a href="https://segmentfault.com/a/1190000003810652">《传统 Ajax 已死，Fetch 永生》</a></p><h4 id="56-谈一谈浏览器的缓存机制？"><a href="#56-谈一谈浏览器的缓存机制？" class="headerlink" title="56. 谈一谈浏览器的缓存机制？"></a>56. 谈一谈浏览器的缓存机制？</h4><p>&nbsp;&nbsp;浏览器的缓存机制指的是通过在一段时间内保留已接收到的 <code>web</code> 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。使用 <code>web</code> 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。</p><p><code>web</code> 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。</p><p>&nbsp;&nbsp;使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 <code>http</code> 头信息中的 <code>Expires</code> 属性和 <code>Cache-Control</code> 属性。</p><p>&nbsp;&nbsp;服务器通过在响应头中添加 <code>Expires</code> 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。</p><p>&nbsp;&nbsp;<code>Expires</code> 是 <code>http1.0</code> 中的方式，因为它的一些缺点，在 <code>http 1.1</code> 中提出了一个新的头部属性就是 <code>Cache-Control</code> 属性，<br>它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 <code>max-age</code> 来指定资源能够被缓存的时间的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 <code>Expires</code> 来说，这种方式更加有效一些。常用的还有比如 <code>private</code> ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 <code>no-store</code> ，用来指定资源不能够被缓存，<code>no-cache</code> 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。</p><p>一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，<code>Cache-Control</code> 的优先级要高于 <code>Expires</code> 。</p><p>&nbsp;&nbsp;使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 <code>304</code> 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 <code>http</code> 头信息中的 <code>Etag</code> 和 <code>Last-Modified</code> 属性。</p><p>&nbsp;&nbsp;服务器通过在响应头中添加 <code>Last-Modified</code> 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 <code>If-Modified-Since</code> 的属性，属性值为上一次资源返回时的 <code>Last-Modified</code> 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 <code>Last-Modified</code> 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已经改变了但是 <code>Last-Modified</code> 却没有改变，这样会造成缓存命中的不准确。</p><p>&nbsp;&nbsp;因为 <code>Last-Modified</code> 的这种可能发生的不准确性，<code>http</code> 中提供了另外一种方式，那就是 <code>Etag</code> 属性。服务器在返回资源的时候，在头信息中添加了 <code>Etag</code> 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 <code>If-None-Match</code> 属性，这个属性的值就是上次返回的资源的 <code>Etag</code> 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 <code>Last-Modified</code> 的方式更加精确。</p><p>&nbsp;&nbsp;当 <code>Last-Modified</code> 和 <code>Etag</code> 属性同时出现的时候，<code>Etag</code> 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 <code>Last-Modified</code> 应该保持一致，因为每个服务器上 <code>Etag</code> 的值都不一样，因此在考虑负载平衡时，最好不要设置 <code>Etag</code> 属性。</p><p>&nbsp;&nbsp;强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则服务器返回最新的资源给浏览器。</p><p>详细资料可以参考：<br>  <a href="https://segmentfault.com/a/1190000012573337">《浅谈浏览器缓存》</a><br>  <a href="https://juejin.im/post/5b9346dcf265da0aac6fbe57#heading-3">《前端优化：浏览器缓存技术介绍》</a><br>  <a href="https://www.web-tinker.com/article/21221.html">《请求头中的 Cache-Control》</a><br>  <a href="https://juejin.im/post/5c2d6c9ae51d450cf4195a08">《Cache-Control 字段值详解》</a></p><h4 id="57-Ajax-解决浏览器缓存问题？"><a href="#57-Ajax-解决浏览器缓存问题？" class="headerlink" title="57. Ajax 解决浏览器缓存问题？"></a>57. Ajax 解决浏览器缓存问题？</h4><ul><li><ol><li>在 <code>ajax</code> 发送请求前加上 <code>anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)</code>。</li></ol></li><li><ol start="2"><li>在 <code>ajax</code> 发送请求前加上 <code>anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)</code>。</li></ol></li><li><ol start="3"><li>在 <code>URL</code> 后面加上一个随机数： <code>&quot;fresh=&quot; + Math.random()</code>;。</li></ol></li><li><ol start="4"><li>在 <code>URL</code> 后面加上时间戳：<code>&quot;nowtime=&quot; + new Date().getTime();</code>。</li></ol></li><li><ol start="5"><li>如果是使用 <code>jQuery</code>，直接这样就可以了<code>\$.ajaxSetup(&#123;cache:false&#125;)</code>。这样页面的所有 <code>ajax</code> 都会执行这条语句就是不需要保存缓存记录。</li></ol></li></ul><p>详细资料可以参考：<br>  <a href="https://www.cnblogs.com/cwzqianduan/p/8632009.html">《Ajax 中浏览器的缓存问题解决方法》</a><br>  <a href="https://segmentfault.com/a/1190000012573337">《浅谈浏览器缓存》</a></p><h4 id="58-同步和异步的区别？"><a href="#58-同步和异步的区别？" class="headerlink" title="58. 同步和异步的区别？"></a>58. 同步和异步的区别？</h4><p><strong>相关知识点：</strong></p><p>&nbsp;&nbsp;同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是处于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。  </p><p>&nbsp;&nbsp;异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 </p><p><strong>回答：</strong></p><p>&nbsp;&nbsp;同步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。</p><p>&nbsp;&nbsp;异步指的是当一个进程在执行某个请求的时候，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。</p><p>详细资料可以参考：<a href="https://blog.csdn.net/tennysonsky/article/details/45111623">《同步和异步的区别》</a></p><h4 id="59-什么是浏览器的同源政策？"><a href="#59-什么是浏览器的同源政策？" class="headerlink" title="59. 什么是浏览器的同源政策？"></a>59. 什么是浏览器的同源政策？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">我对浏览器的同源政策的理解是，一个域下的 <span class="hljs-keyword">js </span>脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源的指的是两个<br>域的协议、域名、端口号必须相同，否则则不属于同一个域。<br><br>同源政策主要限制了三个方面<br><br>第一个是当前域下的 <span class="hljs-keyword">js </span>脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。<br><br>第二个是当前域下的 <span class="hljs-keyword">js </span>脚本不能够操作访问操作其他域下的 DOM。<br><br>第三个是当前域下 ajax 无法发送跨域请求。<br><br>同源政策的目的主要是为了保证用户的信息安全，它只是对 <span class="hljs-keyword">js </span>脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者<br><span class="hljs-keyword">script </span>脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。<br></code></pre></td></tr></table></figure><h4 id="60-如何解决跨域问题？"><a href="#60-如何解决跨域问题？" class="headerlink" title="60. 如何解决跨域问题？"></a>60. 如何解决跨域问题？</h4><p><strong>相关知识点：</strong></p><ul><li><ol><li>通过 jsonp 跨域</li></ol></li><li><ol start="2"><li>document.domain + iframe 跨域</li></ol></li><li><ol start="3"><li>location.hash + iframe</li></ol></li><li><ol start="4"><li>window.name + iframe 跨域</li></ol></li><li><ol start="5"><li>postMessage 跨域</li></ol></li><li><ol start="6"><li>跨域资源共享(CORS)</li></ol></li><li><ol start="7"><li>nginx 代理跨域</li></ol></li><li><ol start="8"><li>nodejs 中间件代理跨域</li></ol></li><li><ol start="9"><li>WebSocket 协议跨域</li></ol></li></ul><p><strong>回答：</strong></p><p>解决跨域的方法我们可以根据我们想要实现的目的来划分。</p><p>首先我们如果只是想要实现主域名下的不同子域名的跨域操作，我们可以使用设置 <code>document.domain</code> 来解决。</p><ol><li>将 <code>document.domain</code> 设置为主域名，来实现相同子域名的跨域操作，这个时候主域名下的 <code>cookie</code> 就能够被子域名所访问。同时如果文档中含有主域名相同，子域名不同的 <code>iframe</code> 的话，我们也可以对这个 <code>iframe</code> 进行操作。</li></ol><p>如果是想要解决不同跨域窗口间的通信问题，比如说一个页面想要和页面的中的不同源的 <code>iframe</code> 进行通信的问题，我们可以使用 <code>location.hash</code> 或者 <code>window.name</code> 或者 <code>postMessage</code> 来解决。</p><ol start="2"><li><p>使用 <code>location.hash</code> 的方法，我们可以在主页面动态的修改 <code>iframe</code> 窗口的 <code>hash</code> 值，然后在 <code>iframe</code> 窗口里实现监听函数来实现这样一个单向的通信。因为在 <code>iframe</code> 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 <code>hash</code> 值来实现通信，我们可以在 <code>iframe</code> 中再加入一个 <code>iframe</code> ，这个 <code>iframe</code> 的内容是和父级页面同源的，所以我们可以 <code>window.parent.parent</code> 来修改最顶级页面的 <code>src</code>，以此来实现双向通信。</p></li><li><p>使用 <code>window.name</code> 的方法，主要是基于同一个窗口中设置了 <code>window.name</code> 后不同源的页面也可以访问，所以不同源的子页面可以首先在 <code>window.name</code> 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 <code>window.name</code> 中的数据了，这种方式的好处是可以传输的数据量大。</p></li><li><p>使用 <code>postMessage</code> 来解决的方法，这是一个 <code>h5</code> 中新增的一个 <code>api</code>。通过它我们可以实现多窗口间的信息传递，通过获取到指定窗口的引用，然后调用 <code>postMessage</code> 来发送信息，在窗口中我们通过对 <code>message</code> 信息的监听来接收信息，以此来实现不同源间的信息交换。</p></li></ol><p>如果是像解决 <code>ajax</code> 无法提交跨域请求的问题，我们可以使用 <code>jsonp、cors、websocket</code> 协议、服务器代理来解决问题。</p><ol start="5"><li><p>使用 <code>jsonp</code> 来实现跨域请求，它的主要原理是通过动态构建 <code>script</code>  标签来实现跨域请求，因为浏览器对 <code>script</code> 标签的引入没有跨域的访问限制 。通过在请求的 <code>url</code> 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 <code>json</code> 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于 <code>get</code> 请求。</p></li><li><p>使用 <code>CORS</code> 的方式，<code>CORS</code> 是一个 W3C 标准，全称是”跨域资源共享”。<code>CORS</code> 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 <code>CORS</code> 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 <code>CORS</code> 请求。具体来说，就是会在头信息之中，增加一个 <code>Origin</code> 字段。<code>Origin</code> 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 <code>Origin</code> 指定的源，不在许可范围内，服务器会返回一个正常的 <code>HTTP</code> 回应。浏览器发现，这个回应的头信息没有包含 <code>Access-Control-Allow-Origin</code> 字段，就知道出错了，从而抛出一个错误，<code>ajax</code> 不会收到响应信息。如果成功的话会包含一些以 <code>Access-Control-</code> 开头的字段。</p></li></ol><p>非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。</p><ol start="7"><li><p>使用 <code>websocket</code> 协议，这个协议没有同源限制。</p></li><li><p>使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果返回。</p></li></ol><p>详细资料可以参考：<br>  <a href="https://segmentfault.com/a/1190000011145364">《前端常见跨域解决方案（全）》</a><br>  <a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">《浏览器同源政策及其规避方法》</a><br>  <a href="https://juejin.im/entry/59feae9df265da43094488f6">《跨域，你需要知道的全在这里》</a><br>  <a href="https://www.zhihu.com/question/31592553">《为什么 form 表单提交没有跨域问题，但 ajax 提交有跨域问题？》</a></p><h4 id="61-服务器代理转发时，该如何处理-cookie？"><a href="#61-服务器代理转发时，该如何处理-cookie？" class="headerlink" title="61. 服务器代理转发时，该如何处理 cookie？"></a>61. 服务器代理转发时，该如何处理 cookie？</h4><p>详细资料可以参考：<a href="https://www.jianshu.com/p/5eab0f83e3b4">《深入浅出 Nginx》</a></p><h4 id="62-简单谈一下-cookie-？"><a href="#62-简单谈一下-cookie-？" class="headerlink" title="62. 简单谈一下 cookie ？"></a>62. 简单谈一下 cookie ？</h4><p>&nbsp;&nbsp;我的理解是 <code>cookie</code> 是服务器提供的一种用于维护会话状态信息的数据，通过服务器发送到浏览器，浏览器保存在本地，当下一次有同源的请求时，将保存的 <code>cookie</code> 值添加到请求头部，发送给服务端。这可以用来实现记录用户登录状态等功能。<code>cookie</code> 一般可以存储 4k 大小的数据，并且只能够被同源的网页所共享访问。</p><p>&nbsp;&nbsp;服务器端可以使用 <code>Set-Cookie</code> 的响应头部来配置 <code>cookie</code> 信息。一条 <code>cookie</code> 包括了5个属性值 <code>expires、domain、path、secure、HttpOnly</code>。其中 <code>expires</code> 指定了 <code>cookie</code> 失效的时间，<code>domain</code> 是域名、<code>path</code>是路径，<code>domain</code> 和 <code>path</code> 一起限制了 <code>cookie</code> 能够被哪些 <code>url</code> 访问。<code>secure</code> 规定了 <code>cookie</code> 只能在确保安全的情况下传输，<code>HttpOnly</code> 规定了这个 <code>cookie</code> 只能被服务器访问，不能使用 <code>js</code> 脚本访问。</p><p>在发生 <code>xhr</code> 的跨域请求的时候，即使是同源下的 <code>cookie</code>，也不会被自动添加到请求头部，除非显示地规定。</p><p>详细资料可以参考：<br>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies">《HTTP cookies》 </a><br>  <a href="https://segmentfault.com/a/1190000004556040">《聊一聊 cookie》 </a></p><h4 id="63-模块化开发怎么做？-——参考JS模块化"><a href="#63-模块化开发怎么做？-——参考JS模块化" class="headerlink" title="63. 模块化开发怎么做？  ——参考JS模块化"></a>63. 模块化开发怎么做？  ——参考JS模块化</h4><p>&nbsp;&nbsp;我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</p><ol><li><p><strong>全局function模式：</strong> 由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。</p></li><li><p><strong>namespace模式：</strong> 后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的模块成员，外部代码可以修改内部属性的值。</p></li><li><p><strong>IIFE模式（闭包）：</strong> 之后发展为立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。但是这种方法无法解决当前这个模块依赖另一个模块的问题。</p></li><li><p><strong>IIFE增强模式：</strong> 通过在IIFE模式中引入依赖，这就是现代模块实现的基石</p></li></ol><p>详细资料可以参考：<br>  <a href="https://juejin.im/post/5ab378c46fb9a028ce7b824f">《浅谈模块化开发》</a><br>  <a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html">《Javascript 模块化编程（一）：模块的写法》</a><br>  <a href="https://juejin.im/post/5aaa37c8f265da23945f365c">《前端模块化：CommonJS，AMD，CMD，ES6》</a><br>  <a href="http://es6.ruanyifeng.com/#docs/module">《Module 的语法》</a></p><h4 id="64-js-的几种模块规范？"><a href="#64-js-的几种模块规范？" class="headerlink" title="64. js 的几种模块规范？"></a>64. js 的几种模块规范？</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">js 中现在比较成熟的有四种模块加载方案。<br><br>第一种是 CommonJS 方案，它通过 <span class="hljs-built_in">require</span> 来引入模块，通过 module.<span class="hljs-built_in">exports</span> 定义模块的输出接口。这种模块加载方案是<br>服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式<br>加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。<br><br>第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定<br>义在一个回调函数里，等到加载完成后再执行回调函数。<span class="hljs-built_in">require</span>.js 实现了 AMD 规范。<br><br>第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 <span class="hljs-built_in">require</span>.js<br>的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。参考<span class="hljs-number">65</span><br><br>第四种方案是 ES6 提出的方案，使用 <span class="hljs-keyword">import</span> 和 <span class="hljs-keyword">export</span> 的形式来导入导出模块。这种方案和上面三种方案都不同。参考 <span class="hljs-number">66</span>。<br></code></pre></td></tr></table></figure><h4 id="65-AMD-和-CMD-规范的区别？"><a href="#65-AMD-和-CMD-规范的区别？" class="headerlink" title="65. AMD 和 CMD 规范的区别？"></a>65. AMD 和 CMD 规范的区别？</h4><p><strong>它们之间的主要区别有两个方面:</strong></p><ol><li><p>第一个方面是在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。</p></li><li><p>第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// AMD 默认推荐</span><br><span class="hljs-title function_">define</span>([<span class="hljs-string">&quot;./a&quot;</span>, <span class="hljs-string">&quot;./b&quot;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-comment">// 依赖必须一开始就写好</span><br>  a.<span class="hljs-title function_">doSomething</span>();<br>  <span class="hljs-comment">// 此处略去 100 行</span><br>  b.<span class="hljs-title function_">doSomething</span>();<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br><br><span class="hljs-comment">// CMD</span><br><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./a&quot;</span>);<br>  a.<span class="hljs-title function_">doSomething</span>();<br>  <span class="hljs-comment">// 此处略去 100 行</span><br>  <span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./b&quot;</span>); <span class="hljs-comment">// 依赖可以就近书写</span><br>  b.<span class="hljs-title function_">doSomething</span>();<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br><br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://juejin.im/post/5a422b036fb9a045211ef789">《前端模块化，AMD 与 CMD 的区别》</a></p><h4 id="66-ES6-模块与-CommonJS-模块、AMD、CMD-的差异。"><a href="#66-ES6-模块与-CommonJS-模块、AMD、CMD-的差异。" class="headerlink" title="66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。"></a>66. ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h4><ul><li><ol><li><code>CommonJS</code> 模块输出的是一个值的拷贝，<code>ES6</code> 模块输出的是值的引用。<code>CommonJS</code> 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。<code>ES6</code> 模块的运行机制与 <code>CommonJS</code> 不一样。<code>JS</code> 引擎对脚本静态分析的时候，遇到模块加载命令 <code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li></ol></li><li><ol start="2"><li><code>CommonJS</code> 模块是运行时加载，<code>ES6</code> 模块是编译时输出接口。<code>CommonJS</code> 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 <code>ES6</code> 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li></ol></li></ul><h4 id="67-requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）"><a href="#67-requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）" class="headerlink" title="67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）"></a>67. requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</h4><p>&nbsp;&nbsp;<code>require.js</code> 的核心原理是通过动态创建 <code>script</code> 脚本来异步引入模块，然后对每个脚本的 <code>load</code> 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</p><p>详细资料可以参考：<br>  <a href="https://github.com/HRFE/blog/issues/10">《requireJS 的用法和原理分析》</a><br>  <a href="https://zhuanlan.zhihu.com/p/55039478">《requireJS 的核心原理是什么？》</a><br>  <a href="https://www.cnblogs.com/dong-xu/p/7160919.html">《从 RequireJs 源码剖析脚本加载原理》</a><br>  <a href="https://www.jianshu.com/p/5a39535909e4">《requireJS 原理分析》</a></p><h4 id="68-JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"><a href="#68-JS-模块加载器的轮子怎么造，也就是如何实现一个模块加载器？" class="headerlink" title="68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？"></a>68. JS 模块加载器的轮子怎么造，也就是如何实现一个模块加载器？</h4><p>详细资料可以参考：<a href="https://www.zhihu.com/question/21157540">《JS 模块加载器加载原理是怎么样的？》</a></p><h4 id="69-ECMAScript6-怎么写-class，为什么会出现-class-这种东西"><a href="#69-ECMAScript6-怎么写-class，为什么会出现-class-这种东西" class="headerlink" title="69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?"></a>69. ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">在我看来 ES6 新添加的 <span class="hljs-keyword">class</span> 只是为了补充 <span class="hljs-symbol">js</span> 中缺少的一些面向对象语言的特性，但本质上来说它只是一种语法糖，不是一个新的东西，其背后还是原型继承的思想。通过加入 <span class="hljs-symbol">class</span> 可以有利于我们更好的组织代码。<br><br>在 <span class="hljs-symbol">class</span> 中添加的方法，其实是添加在类的原型上的。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br>  <a href="https://www.zhihu.com/question/29789315">《ECMAScript 6 实现了 class，对 JavaScript 前端开发有什么意义？》</a><br>  <a href="http://es6.ruanyifeng.com/#docs/class">《Class 的基本语法》</a></p><h4 id="70-documen-write-和-innerHTML-的区别？"><a href="#70-documen-write-和-innerHTML-的区别？" class="headerlink" title="70. documen.write 和 innerHTML 的区别？"></a>70. documen.write 和 innerHTML 的区别？</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">document.<span class="hljs-built_in">write</span> 的内容会代替整个文档内容，会重写整个页面。<br><br>innerHTML 的内容只是替代指定元素的内容，只会重写页面中的部分内容。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://www.nowcoder.com/questionTerminal/2c5d8105b2694d85b06eff85e871cf50">《简述 document.write 和 innerHTML 的区别。》</a></p><h4 id="71-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><a href="#71-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？"></a>71. DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h4><ol><li>创建新节点</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">以下方法都是<span class="hljs-variable language_">document</span>调用：<br><span class="hljs-title function_">createDocumentFragment</span>(node);<br><span class="hljs-title function_">createElement</span>(node);<br><span class="hljs-title function_">createTextNode</span>(text);<br></code></pre></td></tr></table></figure><ol start="2"><li>添加、移除、替换、插入</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">以下方法都是父元素调用，操作子元素：<br><span class="hljs-title function_">appendChild</span>(node)<br><span class="hljs-title function_">removeChild</span>(node)<br><span class="hljs-title function_">replaceChild</span>(<span class="hljs-keyword">new</span>,old)<br><span class="hljs-title function_">insertBefore</span>(<span class="hljs-keyword">new</span>,old)<br></code></pre></td></tr></table></figure><ol start="3"><li>查找</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getElementById</span>();<br><span class="hljs-title function_">getElementsByTagName</span>();<br><span class="hljs-title function_">getElementsByClassName</span>();<br><span class="hljs-title function_">querySelector</span>();<br><span class="hljs-title function_">querySelectorAll</span>();<br></code></pre></td></tr></table></figure><ol start="4"><li>属性操作</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getAttribute</span>(key);<br><span class="hljs-title function_">setAttribute</span>(key, value);<br><span class="hljs-title function_">hasAttribute</span>(key);<br><span class="hljs-title function_">removeAttribute</span>(key);<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction#DOM_interfaces">《DOM 概述》</a><br>  <a href="https://harttle.land/2015/10/01/javascript-dom-api.html">《原生 JavaScript 的 DOM 操作汇总》</a><br>  <a href="https://microzz.com/2017/04/06/jsdom/">《原生 JS 中 DOM 节点相关 API 合集》</a></p><h4 id="72-innerHTML-与-outerHTML-的区别？"><a href="#72-innerHTML-与-outerHTML-的区别？" class="headerlink" title="72. innerHTML 与 outerHTML 的区别？"></a>72. innerHTML 与 outerHTML 的区别？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">对于这样一个 <span class="hljs-selector-tag">HTML</span> 元素：&lt;<span class="hljs-selector-tag">div</span>&gt;<span class="hljs-attribute">content</span>&lt;br/&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;。<br><br>innerHTML：内部 <span class="hljs-selector-tag">HTML</span>，<span class="hljs-attribute">content</span>&lt;br/&gt;；<br>outerHTML：外部 <span class="hljs-selector-tag">HTML</span>，&lt;<span class="hljs-selector-tag">div</span>&gt;<span class="hljs-attribute">content</span>&lt;br/&gt;&lt;/<span class="hljs-selector-tag">div</span>&gt;；<br>innerText：内部文本，<span class="hljs-attribute">content</span> ；<br>outerText：内部文本，<span class="hljs-attribute">content</span> ；<br></code></pre></td></tr></table></figure><h4 id="73-call-、-apply-和-bind-的区别？"><a href="#73-call-、-apply-和-bind-的区别？" class="headerlink" title="73. call() 、 apply() 和 bind() 的区别？"></a>73. call() 、 apply() 和 bind() 的区别？</h4><p><code>call,apply,bind()</code>三者都用于改变函数的<code>this</code>对象的指向: </p><ul><li><code>bind</code> 是返回对应函数，便于稍后调用；<code>apply 、call</code> 则是立即调用。</li><li><code>call</code>和<code>apply</code>的作用一模一样，区别仅在于传入参数的形式的不同。</li><li><code>apply</code> 接受两个参数，第一个参数指定了函数体内 <code>this</code> 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，<code>apply</code> 方法把这个集合中的元素作为参数传递给被调用的函数。</li><li><code>call</code> 传入的参数数量不固定，跟 <code>apply</code> 相同的是，第一个参数也是代表函数体内的 <code>this</code> 指向，从第二个参数开始往后，每个参数被依次传入函数。</li></ul><p>详细资料可以参考：<a href="https://juejin.im/entry/58d0a7b22f301e007e5a15ae">《apply、call 的区别和用途》</a></p><h4 id="74-JavaScript-类数组对象的定义？"><a href="#74-JavaScript-类数组对象的定义？" class="headerlink" title="74. JavaScript 类数组对象的定义？"></a>74. JavaScript 类数组对象的定义？</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">一个拥有 <span class="hljs-built_in">length</span> 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。<br><br>常见的类数组对象有 <span class="hljs-keyword">arguments</span> 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 <span class="hljs-built_in">length</span><br>属性值，代表可接收的参数个数。<br></code></pre></td></tr></table></figure><p><strong>常见的类数组转换为数组的方法有这样几种：</strong></p><ol><li>通过 call 调用数组的 slice 方法来实现转换</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(arrayLike);<br></code></pre></td></tr></table></figure><ol start="2"><li>通过 call 调用数组的 splice 方法来实现转换</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">splice</span>.<span class="hljs-title function_">call</span>(arrayLike, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ol start="3"><li>通过 apply 调用数组的 concat 方法来实现转换</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>([], arrayLike);<br></code></pre></td></tr></table></figure><ol start="4"><li>通过 Array.from 方法来实现转换</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike);<br></code></pre></td></tr></table></figure><p>详细的资料可以参考：<br>  <a href="https://github.com/mqyqingfeng/Blog/issues/14">《JavaScript 深入之类数组对象与 arguments》</a><br>  <a href="https://segmentfault.com/a/1190000000415572">《javascript 类数组》</a><br>  <a href="https://blog.lxxyx.cn/2016/05/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E7%B1%BB%E6%95%B0%E7%BB%84/">《深入理解 JavaScript 类数组》</a></p><h4 id="75-数组和对象有哪些原生方法，列举一下？"><a href="#75-数组和对象有哪些原生方法，列举一下？" class="headerlink" title="75. 数组和对象有哪些原生方法，列举一下？"></a>75. 数组和对象有哪些原生方法，列举一下？</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">数组和字符串的转换方法：<span class="hljs-built_in">toString</span>()、<span class="hljs-built_in">toLocalString</span>()、<span class="hljs-built_in">join</span>() 其中 <span class="hljs-built_in">join</span>() 方法可以指定转换为字符串时的分隔符。<br><br>数组尾部操作的方法 <span class="hljs-built_in">pop</span>() 和 <span class="hljs-built_in">push</span>()，push 方法可以传入多个参数。<br><br>数组首部操作的方法 <span class="hljs-built_in">shift</span>() 和 <span class="hljs-built_in">unshift</span>() 重排序的方法 <span class="hljs-built_in">reverse</span>() 和 <span class="hljs-built_in">sort</span>()，<span class="hljs-built_in">sort</span>() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。<br><br>数组连接的方法 <span class="hljs-built_in">concat</span>() ，返回的是拼接好的数组，不影响原数组。<br><br>数组截取办法 <span class="hljs-built_in">slice</span>()，用于截取数组中的一部分返回，不影响原数组。<br><br>数组插入方法 <span class="hljs-built_in">splice</span>()，影响原数组查找特定项的索引的方法，<span class="hljs-built_in">indexOf</span>() 和 <span class="hljs-built_in">lastIndexOf</span>() 迭代方法 <span class="hljs-built_in">every</span>()、<span class="hljs-built_in">some</span>()、<span class="hljs-attribute">filter</span>()、<span class="hljs-built_in">map</span>() 和 <span class="hljs-built_in">forEach</span>() 方法<br><br>数组归并方法 <span class="hljs-built_in">reduce</span>() 和 <span class="hljs-built_in">reduceRight</span>() 方法<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8BArray%E8%AF%A6%E8%A7%A3.html">《JavaScript 深入理解之 Array 类型详解》</a></p><h4 id="76-数组的-fill-方法？"><a href="#76-数组的-fill-方法？" class="headerlink" title="76. 数组的 fill 方法？"></a>76. 数组的 fill 方法？</h4><p><code>fill()</code> 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。<br><code>fill</code> 方法接受三个参数 <code>value，start</code> 以及 <code>end，start</code> 和 <code>end</code> 参数是可选的，其默认值分别为 <code>0</code> 和 <code>this</code> 对象的 <code>length</code> 属性值。</p><p>详细资料可以参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">《Array.prototype.fill()》</a></p><h4 id="77-的长度？"><a href="#77-的长度？" class="headerlink" title="77. [,,,] 的长度？"></a>77. [,,,] 的长度？</h4><p>&nbsp;&nbsp;尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。</p><p>&nbsp;&nbsp;JavaScript 一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript 5）中添加了尾后逗号。最近（ECMAScript 2017），又将其添加到函数参数中。但是 JSON 不支持尾后逗号。</p><p>&nbsp;&nbsp;如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数<br>量。</p><p>详细资料可以参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Trailing_commas">《尾后逗号》</a></p><h4 id="78-JavaScript-中的作用域与变量声明提升？"><a href="#78-JavaScript-中的作用域与变量声明提升？" class="headerlink" title="78. JavaScript 中的作用域与变量声明提升？"></a>78. JavaScript 中的作用域与变量声明提升？</h4><p>&nbsp;&nbsp;变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。</p><p>&nbsp;&nbsp;造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。</p><p>详细资料可以参考：<a href="http://cavszhouyou.top/JavaScript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1.html">《JavaScript 深入理解之变量对象》</a></p><h4 id="79-如何编写高性能的-Javascript-？"><a href="#79-如何编写高性能的-Javascript-？" class="headerlink" title="79. 如何编写高性能的 Javascript ？"></a>79. 如何编写高性能的 Javascript ？</h4><ul><li>1.使用位运算代替一些简单的四则运算。</li><li>2.避免使用过深的嵌套循环。</li><li>3.不要使用未定义的变量。</li><li>4.当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找。</li></ul><p>详细资料可以参考：<a href="https://zhuanlan.zhihu.com/p/34780474">《如何编写高性能的 Javascript？》</a></p><h4 id="80-简单介绍一下-V8-引擎的垃圾回收机制"><a href="#80-简单介绍一下-V8-引擎的垃圾回收机制" class="headerlink" title="80. 简单介绍一下 V8 引擎的垃圾回收机制"></a>80. 简单介绍一下 V8 引擎的垃圾回收机制</h4><p>&nbsp;&nbsp;v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</p><p>&nbsp;&nbsp;新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</p><p>&nbsp;&nbsp;新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：</p><ol><li><p>首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。</p></li><li><p>如果对象不存活，则释放对象的空间。</p></li><li><p>最后将 From 空间和 To 空间角色进行交换。</p></li></ol><p><strong>新生代对象晋升到老生代有两个条件：</strong></p><ol><li><p>第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。</p></li><li><p>第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</p></li></ol><p>&nbsp;&nbsp;老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</p><p>&nbsp;&nbsp;由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</p><p>详细资料可以参考：<br>  <a href="https://www.jianshu.com/p/b8ed21e8a4fb">《深入理解 V8 的垃圾回收原理》</a><br>  <a href="https://zhuanlan.zhihu.com/p/23992332">《JavaScript 中的垃圾回收》</a></p><h4 id="81-哪些操作会造成内存泄漏？"><a href="#81-哪些操作会造成内存泄漏？" class="headerlink" title="81. 哪些操作会造成内存泄漏？"></a>81. 哪些操作会造成内存泄漏？</h4><p><strong>相关知识点：</strong></p><ul><li>1.意外的全局变量</li><li>2.被遗忘的计时器或回调函数</li><li>3.脱离 DOM 的引用</li><li>4.闭包</li></ul><p><strong>回答：</strong></p><p>&nbsp;&nbsp;第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</p><p>&nbsp;&nbsp;第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</p><p>&nbsp;&nbsp;第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</p><p>&nbsp;&nbsp;第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</p><p>详细资料可以参考：<br>  <a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html">《JavaScript 内存泄漏教程》</a><br>  <a href="https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/">《4 类 JavaScript 内存泄漏及如何避免》</a><br>  <a href="https://juejin.im/entry/5a64366c6fb9a01c9332c706">《杜绝 js 中四种内存泄漏类型的发生》</a><br>  <a href="https://segmentfault.com/a/1190000008901861">《javascript 典型内存泄漏及 chrome 的排查方法》</a></p><h4 id="82-需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"><a href="#82-需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？" class="headerlink" title="82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？"></a>82. 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？</h4><p>&nbsp;&nbsp;通过使用 <code>pushState + ajax</code> 实现浏览器无刷新前进后退，当一次 <code>ajax</code> 调用成功后我们将一条 <code>state</code> 记录加入到 <code>history</code><br>对象中。一条 <code>state</code> 记录包含了 <code>url、title</code> 和 <code>content</code> 属性，在 <code>popstate</code> 事件中可以获取到这个 <code>state</code> 对象，我们可以使用 <code>content</code> 来传递数据。最后我们通过对 <code>window.onpopstate</code> 事件监听来响应浏览器的前进后退操作。</p><p>&nbsp;&nbsp;使用 <code>pushState</code> 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 <code>replaceState</code> 来将首页的记录替换，另一个问题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 <code>url</code> 需要后端的配合将其重定向到一个页面。</p><p>详细资料可以参考：<br>  <a href="http://blog.chenxu.me/post/detail?id=ed4f0732-897f-48e4-9d4f-821e82f17fad">《pushState + ajax 实现浏览器无刷新前进后退》</a><br>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History_API">《Manipulating the browser history》</a></p><h4 id="83-如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）"><a href="#83-如何判断当前脚本运行在浏览器还是-node-环境中？（阿里）" class="headerlink" title="83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）"></a>83. 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）</h4><p><code>this === window ? &#39;browser&#39; : &#39;node&#39;;</code><br>通过判断 <code>Global</code> 对象是否为 <code>window</code>，如果不为 <code>window</code>，当前脚本没有运行在浏览器中。</p><h4 id="84-把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"><a href="#84-把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别？浏览器会如何解析它们？" class="headerlink" title="84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？"></a>84. 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？</h4><p>详细资料可以参考：<br>  <a href="https://www.zhihu.com/question/20027966">《为什么把 script 标签放在 body 结束标签之后 html 结束标签之前？》</a><br>  <a href="https://zhuanlan.zhihu.com/p/30558018">《从 Chrome 源码看浏览器如何加载资源》</a></p><h4 id="85-移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？"><a href="#85-移动端的点击事件的有延迟，时间是多久，为什么会有？-怎么解决这个延时？" class="headerlink" title="85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？"></a>85. 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？</h4><p>&nbsp;&nbsp;移动端点击有 300ms 的延迟是因为移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。</p><p><strong>有三种办法来解决这个问题：</strong></p><ul><li>1.通过 meta 标签禁用网页的缩放。</li><li>2.通过 meta 标签将网页的 viewport 设置为 ideal viewport。</li><li>3.调用一些 js 库，比如 FastClick</li></ul><p>&nbsp;&nbsp;click 延时问题还可能引起点击穿透的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，我们发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件，这就是点击穿透。</p><p>详细资料可以参考：<a href="https://juejin.im/post/5b3cc9836fb9a04f9a5cb0e0">《移动端 300ms 点击延迟和点击穿透》</a></p><h4 id="86-什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"><a href="#86-什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？" class="headerlink" title="86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？"></a>86. 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？</h4><ol><li>什么是前端路由？</li></ol><p> 前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。</p><ol start="2"><li>什么时候使用前端路由？</li></ol><p>  在单页面应用，大部分页面结构不变，只改变部分内容的使用</p><ol start="3"><li>前端路由有什么优点和缺点？</li></ol><p>  优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户</p><p>  缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置</p><p>  前端路由一共有两种实现方式，一种是通过 hash 的方式，一种是通过使用 pushState 的方式。</p><p>详细资料可以参考：<br>  <a href="https://segmentfault.com/q/1010000005336260">《什么是“前端路由”》</a><br>  <a href="https://github.com/kaola-fed/blog/issues/137">《浅谈前端路由》 </a><br>  <a href="https://www.zhihu.com/question/53064386">《前端路由是什么东西？》</a></p><h4 id="87-如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？"><a href="#87-如何测试前端代码么？-知道-BDD-TDD-Unit-Test-么？-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qUnit-？" class="headerlink" title="87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？"></a>87. 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？</h4><p>详细资料可以参考：<a href="https://juejin.im/post/5b2da89cf265da597f1c7cab">《浅谈前端单元测试》</a></p><h4 id="88-检测浏览器版本有哪些方式？"><a href="#88-检测浏览器版本有哪些方式？" class="headerlink" title="88. 检测浏览器版本有哪些方式？"></a>88. 检测浏览器版本有哪些方式？</h4><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">检测浏览器版本一共有两种方式：<br><br>一种是检测 window.navigator.<span class="hljs-keyword">user</span>Agent 的值，但这种方式很不可靠，因为 <span class="hljs-keyword">user</span>Agent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 <span class="hljs-keyword">user</span>Agent 的值为 Mozilla 来躲过服务器的检测。<br><br>第二种方式是功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://www.jianshu.com/p/d99f4ca385ac">《JavaScript 判断浏览器类型》</a></p><h4 id="89-什么是-Polyfill-？"><a href="#89-什么是-Polyfill-？" class="headerlink" title="89. 什么是 Polyfill ？"></a>89. 什么是 Polyfill ？</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。<br><br>比如说 <span class="hljs-built_in">querySelectorAll</span> 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。<br><br>一个 shim 是一个库，有自己的 API，而不是单纯实现原生不支持的 API。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br>  <a href="https://segmentfault.com/a/1190000002593432">《Web 开发中的“黑话”》</a><br>  <a href="https://juejin.im/post/5a579bc7f265da3e38496ba1">《Polyfill 为何物》</a></p><h4 id="90-使用-JS-实现获取文件扩展名？"><a href="#90-使用-JS-实现获取文件扩展名？" class="headerlink" title="90. 使用 JS 实现获取文件扩展名？"></a>90. 使用 JS 实现获取文件扩展名？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// String.lastIndexOf() 方法返回指定值（本例中的&#x27;.&#x27;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</span><br><br><span class="hljs-comment">// 对于 &#x27;filename&#x27; 和 &#x27;.hiddenfile&#x27; ，lastIndexOf 的返回值分别为 -1 和 0， 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。</span><br><br><span class="hljs-comment">// String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFileExtension</span>(<span class="hljs-params">filename</span>) &#123;<br>  <span class="hljs-keyword">return</span> filename.<span class="hljs-title function_">slice</span>(((filename.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&quot;.&quot;</span>) - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://segmentfault.com/a/1190000004993946">《如何更有效的获取文件扩展名》</a></p><h4 id="91-介绍一下-js-的节流与防抖？"><a href="#91-介绍一下-js-的节流与防抖？" class="headerlink" title="91. 介绍一下 js 的节流与防抖？"></a>91. 介绍一下 js 的节流与防抖？</h4><p>相关知识点：参考性能优化中的函数防抖与节流</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</span><br><br><span class="hljs-comment">// 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</span><br><br><span class="hljs-comment">// 函数防抖的实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>  <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>,<br>      args = <span class="hljs-variable language_">arguments</span>;<br><br>    <span class="hljs-comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>      timer = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置定时器，使事件间隔指定时间后执行</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;, wait);<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 函数节流的实现;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">var</span> preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>,<br>      args = <span class="hljs-variable language_">arguments</span>,<br>      nowTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>    <span class="hljs-comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span><br>    <span class="hljs-keyword">if</span> (nowTime - preTime &gt;= delay) &#123;<br>      preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>回答：</strong></p><p>&nbsp;&nbsp;函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p><p>&nbsp;&nbsp;函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p><p>详细资料可以参考：<br>  <a href="https://juejin.im/post/5a35ed25f265da431d3cc1b1">《轻松理解 JS 函数节流和函数防抖》</a><br>  <a href="https://juejin.im/post/5aa60b0e518825556b6c6d1a">《JavaScript 事件节流和事件防抖》</a><br>  <a href="https://juejin.im/entry/5b1d2d54f265da6e2545bfa4">《JS 的防抖与节流》</a></p><h4 id="92-Object-is-与原来的比较操作符-“-”、“-”-的区别？"><a href="#92-Object-is-与原来的比较操作符-“-”、“-”-的区别？" class="headerlink" title="92. Object.is() 与原来的比较操作符 “&#x3D; &#x3D; &#x3D; &#x3D;&#x3D;”、“&#x3D;&#x3D;&#x3D; &#x3D;” 的区别？"></a>92. Object.is() 与原来的比较操作符 “&#x3D; &#x3D; &#x3D; &#x3D;&#x3D;”、“&#x3D;&#x3D;&#x3D; &#x3D;” 的区别？</h4><p>相关知识点：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">两等号判等，会在比较时进行类型转换。<br>三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回<span class="hljs-literal">false</span>）。<br><br><span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span> 在三等号判等的基础上特别处理了 <span class="hljs-literal">NaN</span> 、<span class="hljs-number">-0</span> 和 +<span class="hljs-number">0</span> ，保证 <span class="hljs-number">-0</span> 和 +<span class="hljs-number">0</span> 不再相同，但 <span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span>(<span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>) 会返回 <span class="hljs-literal">true</span>.<br><br><span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span> 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。<br><br>使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 <span class="hljs-literal">false</span>。<br><br>使用 <span class="hljs-built_in">Object</span>.<span class="hljs-keyword">is</span> 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 <span class="hljs-number">-0</span> 和 +<span class="hljs-number">0</span> 不再相等，两个 <span class="hljs-literal">NaN</span> 认定为是相等的。<br></code></pre></td></tr></table></figure><h4 id="93-escape-encodeURI-encodeURIComponent-有什么区别？"><a href="#93-escape-encodeURI-encodeURIComponent-有什么区别？" class="headerlink" title="93. escape,encodeURI,encodeURIComponent 有什么区别？"></a>93. escape,encodeURI,encodeURIComponent 有什么区别？</h4><p><strong>相关知识点：</strong></p><p>&nbsp;&nbsp;<code>escape</code> 和 <code>encodeURI</code> 都属于 <code>Percent-encoding</code>，基本功能都是把 <code>URI</code> 非法字符转化成合法字符，转化后形式类似<code>「%*」</code>。它们的根本区别在于，<code>escape</code> 在处理 <code>0xff</code> 之外字符的时候，是直接使用字符的 <code>unicode</code> 在前面加上一个<code>「%u」</code>，而 <code>encode URI</code> 则是先进行 <code>UTF-8</code>，再在 <code>UTF-8</code> 的每个字节码前加上一个<code>「%」</code>；在处理 <code>0xff</code> 以内字符时，编码方式是一样的（都是<code>「%XX」</code>，XX 为字符的 16 进制 <code>unicode</code>，同时也是字符的 <code>UTF-8</code>），只是范围（即哪些字符编码哪些字符不编码）不一样。</p><p><strong>回答：</strong></p><p>&nbsp;&nbsp;<code>encodeURI</code> 是对整个 <code>URI</code> 进行转义，将 <code>URI</code> 中的非法字符转换为合法字符，所以对于一些在 <code>URI</code> 中有特殊意义的字符不会进行转义。</p><p><code>encodeURIComponent</code> 是对 <code>URI</code> 的组成部分进行转义，所以一些特殊字符也会得到转义。</p><p>&nbsp;&nbsp;<code>escape</code> 和 <code>encodeURI</code> 的作用相同，不过它们对于 <code>unicode</code> 编码为 <code>0xff</code> 之外字符的时候会有区别，<code>escape</code> 是直接在字符的 <code>unicode</code> 编码前加上 <code>%u</code>，而 <code>encodeURI</code> 首先会将字符转换为 <code>UTF-8</code> 的格式，再在每个字节前加上 <code>%</code>。</p><p>详细资料可以参考：<a href="https://www.zhihu.com/question/21861899">《escape,encodeURI,encodeURIComponent 有什么区别?》</a></p><h4 id="94-Unicode-和-UTF-8-之间的关系？"><a href="#94-Unicode-和-UTF-8-之间的关系？" class="headerlink" title="94. Unicode 和 UTF-8 之间的关系？"></a>94. Unicode 和 UTF-8 之间的关系？</h4><p>&nbsp;&nbsp;<code>Unicode</code> 是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。</p><p><code>UTF-8</code> 是一种对 <code>Unicode</code> 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。</p><p>详细资料可以参考：<br>  <a href="https://blog.51cto.com/polaris/377468">《字符编码详解》</a><br>  <a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">《字符编码笔记：ASCII，Unicode 和 UTF-8》</a></p><h4 id="95-js-的事件循环是什么？"><a href="#95-js-的事件循环是什么？" class="headerlink" title="95. js 的事件循环是什么？"></a>95. js 的事件循环是什么？</h4><p><strong>相关知识点：</strong></p><p>&nbsp;&nbsp;事件队列是一个存储着待执行任务的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果不为空的话，事件队列便将第一个任务压入执行栈中运行。</p><p><strong>回答：</strong></p><p>&nbsp;&nbsp;因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</p><p>微任务包括了 promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</p><p>宏任务包括了 script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I&#x2F;O 操作、UI 渲染等。</p><p>详细资料可以参考：<br>  <a href="https://juejin.im/post/5afbc62151882542af04112d">《浏览器事件循环机制（event loop）》</a><br>  <a href="https://zhuanlan.zhihu.com/p/33058983">《详解 JavaScript 中的 Event Loop（事件循环）机制》</a><br>  <a href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html">《什么是 Event Loop？》</a><br>  <a href="https://juejin.im/post/59e85eebf265da430d571f89">《这一次，彻底弄懂 JavaScript 执行机制》</a></p><h4 id="96-js-中的深浅拷贝实现？"><a href="#96-js-中的深浅拷贝实现？" class="headerlink" title="96. js 中的深浅拷贝实现？"></a>96. js 中的深浅拷贝实现？</h4><p>相关资料：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 浅拷贝的实现;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">shallowCopy</span>(<span class="hljs-params">object</span>) &#123;<br>  <span class="hljs-comment">// 只拷贝对象</span><br>  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// 根据 object 的类型判断是新建一个数组还是对象</span><br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(object) ? [] : &#123;&#125;;<br><br>  <span class="hljs-comment">// 遍历 object，并且判断是 object 的属性才拷贝</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) &#123;<br>    <span class="hljs-keyword">if</span> (object.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      newObject[key] = object[key];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> newObject;<br>&#125;<br><br><span class="hljs-comment">// 深拷贝的实现;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">object</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(object) ? [] : &#123;&#125;;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) &#123;<br>    <span class="hljs-keyword">if</span> (object.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      newObject[key] =<br>        <span class="hljs-keyword">typeof</span> object[key] === <span class="hljs-string">&quot;object&quot;</span> ? <span class="hljs-title function_">deepCopy</span>(object[key]) : object[key];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> newObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  <span class="hljs-built_in">Object</span>.assign 和展开运算符来实现。<br><br>深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 <span class="hljs-built_in">JSON</span> 的两个函数来实现，但是由于 <span class="hljs-built_in">JSON</span> 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 <span class="hljs-built_in">Symbol</span> 类型的值时，会转换失败。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br>  <a href="https://github.com/mqyqingfeng/Blog/issues/32">《JavaScript 专题之深浅拷贝》</a><br>  <a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bed40d951882545f73004f6">《前端面试之道》</a></p><h4 id="97-手写-call、apply-及-bind-函数"><a href="#97-手写-call、apply-及-bind-函数" class="headerlink" title="97. 手写 call、apply 及 bind 函数"></a>97. 手写 call、apply 及 bind 函数</h4><p>相关资料：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// call函数实现</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>    result = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 判断 context 是否传入，如果未传入则设置为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br><br>  <span class="hljs-comment">// 将调用函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br><br>  <span class="hljs-comment">// 调用函数</span><br>  result = context.<span class="hljs-title function_">fn</span>(...args);<br><br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br><span class="hljs-comment">// apply 函数实现</span><br><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 判断 context 是否存在，如果未传入则为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br><br>  <span class="hljs-comment">// 将函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br><br>  <span class="hljs-comment">// 调用方法</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]) &#123;<br>    result = context.<span class="hljs-title function_">fn</span>(...<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    result = context.<span class="hljs-title function_">fn</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br><span class="hljs-comment">// bind 函数实现</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">var</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>    fn = <span class="hljs-variable language_">this</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 根据调用方式，传入不同绑定值</span><br>    <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<br>      <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Fn</span> ? <span class="hljs-variable language_">this</span> : context,<br>      args.<span class="hljs-title function_">concat</span>(...<span class="hljs-variable language_">arguments</span>)<br>    );<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>回答：</p><p>call 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>3.处理传入的参数，截取第一个参数后的所有参数。</li><li>4.将函数作为上下文对象的一个属性。</li><li>5.使用上下文对象来调用这个方法，并保存返回结果。</li><li>6.删除刚才新增的属性。</li><li>7.返回结果。</li></ul><p>apply 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>3.将函数作为上下文对象的一个属性。</li><li>4.判断参数值是否传入</li><li>4.使用上下文对象来调用这个方法，并保存返回结果。</li><li>5.删除刚才新增的属性</li><li>6.返回结果</li></ul><p>bind 函数的实现步骤：</p><ul><li>1.判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>2.保存当前函数的引用，获取其余传入参数值。</li><li>3.创建一个函数返回</li><li>4.函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul><p>详细资料可以参考：<br><a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdd0d8e6fb9a04a044073fe">《手写 call、apply 及 bind 函数》</a><br><a href="https://github.com/mqyqingfeng/Blog/issues/11">《JavaScript 深入之 call 和 apply 的模拟实现》</a></p><h4 id="98-函数柯里化的实现"><a href="#98-函数柯里化的实现" class="headerlink" title="98. 函数柯里化的实现"></a>98. 函数柯里化的实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn, args</span>) &#123;<br>  <span class="hljs-comment">// 获取函数需要的参数长度</span><br>  <span class="hljs-keyword">let</span> length = fn.<span class="hljs-property">length</span>;<br><br>  args = args || [];<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> subArgs = args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 拼接得到现有的所有参数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;<br>      subArgs.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">arguments</span>[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 判断参数的长度是否已经满足函数所需参数的长度</span><br>    <span class="hljs-keyword">if</span> (subArgs.<span class="hljs-property">length</span> &gt;= length) &#123;<br>      <span class="hljs-comment">// 如果满足，执行函数</span><br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, subArgs);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span><br>      <span class="hljs-keyword">return</span> curry.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, fn, subArgs);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// es6 实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn, ...args</span>) &#123;<br>  <span class="hljs-keyword">return</span> fn.<span class="hljs-property">length</span> &lt;= args.<span class="hljs-property">length</span> ? <span class="hljs-title function_">fn</span>(...args) : curry.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, fn, ...args);<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://github.com/mqyqingfeng/Blog/issues/42">《JavaScript 专题之函数柯里化》</a></p><h4 id="99-为什么-0-1-0-2-0-3？如何解决这个问题？"><a href="#99-为什么-0-1-0-2-0-3？如何解决这个问题？" class="headerlink" title="99. 为什么 0.1 + 0.2 !&#x3D; 0.3？如何解决这个问题？"></a>99. 为什么 0.1 + 0.2 !&#x3D; 0.3？如何解决这个问题？</h4><p>&nbsp;&nbsp;当计算机计算 <code>0.1+0.2</code> 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，<code>0.1</code> 和 <code>0.2</code> 在转换为二进制表示的时候会出现位数无限循环的情况。<code>js</code> 中是以 <code>64</code> 位双精度格式来存储数字的，只有 <code>53</code> 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 <code>64</code> 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 <code>53</code> 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。</p><p>对于这样的情况，我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数，以这种方式来解决这个问题。</p><p>&nbsp;&nbsp;我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以<br>使用 es6 的 Number.EPSILON</p><p>详细资料可以参考：<br>  <a href="https://blog.csdn.net/Lixuanshengchao/article/details/82049191">《十进制的 0.1 为什么不能用二进制很好的表示？》</a><br>  <a href="https://blog.csdn.net/zhengyanan815/article/details/78550073">《十进制浮点数转成二进制》</a><br>  <a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">《浮点数的二进制表示》</a><br>  <a href="https://juejin.im/post/5b372f106fb9a00e6714aa21">《js 浮点数存储精度丢失原理》</a><br>  <a href="https://juejin.im/post/594a31d0a0bb9f006b0b2624">《浮点数精度之谜》</a><br>  <a href="https://github.com/camsong/blog/issues/9">《JavaScript 浮点数陷阱及解法》</a><br>  <a href="https://juejin.im/post/5bd2f10a51882555e072d0c4">《0.1+0.2 !&#x3D;&#x3D; 0.3？》</a><br>  <a href="https://juejin.im/entry/59cdd7fb6fb9a00a600f8eef">《JavaScript 中奇特的~运算符》</a></p><h4 id="100-原码、反码和补码的介绍"><a href="#100-原码、反码和补码的介绍" class="headerlink" title="100. 原码、反码和补码的介绍"></a>100. 原码、反码和补码的介绍</h4><p>原码是计算机中对数字的二进制的定点表示方法，最高位表示符号位，其余位表示数值位。优点是易于分辨，缺点是不能够直接参与运算。</p><p>正数的反码和其原码一样；负数的反码，符号位为1，数值部分按原码取反。<br>如 <code>[+7]原 = 00000111，[+7]反 = 00000111； [-7]原 = 10000111，[-7]反 = 11111000。</code></p><p>正数的补码和其原码一样；负数的补码为其反码加1。</p><p>例如 <code>[+7]原 = 00000111，[+7]反 = 00000111，[+7]补 = 00000111；</code><br>     <code>[-7]原 = 10000111，[-7]反 = 11111000，[-7]补 = 11111001</code></p><p>&nbsp;&nbsp;之所以在计算机中使用补码来表示负数的原因是，这样可以将加法运算扩展到所有的数值计算上，因此在数字电路中我们只需要考虑加法器的设计就行了，而不用再为减法设置新的数字电路。</p><p>详细资料可以参考：<a href="http://www.ruanyifeng.com/blog/2009/08/twos_complement.html">《关于 2 的补码》</a></p><h4 id="101-toPrecision-和-toFixed-和-Math-round-的区别？"><a href="#101-toPrecision-和-toFixed-和-Math-round-的区别？" class="headerlink" title="101. toPrecision 和 toFixed 和 Math.round 的区别？"></a>101. toPrecision 和 toFixed 和 Math.round 的区别？</h4><p><code>toPrecision</code> 用于处理精度，精度是从左至右第一个不为 0 的数开始数起。<br><code>toFixed</code> 是对小数点后指定位数取整，从小数点开始数起。<br><code>Math.round</code> 是将一个数字四舍五入到一个整数。</p><h4 id="102-什么是-XSS-攻击？如何防范-XSS-攻击？"><a href="#102-什么是-XSS-攻击？如何防范-XSS-攻击？" class="headerlink" title="102. 什么是 XSS 攻击？如何防范 XSS 攻击？"></a>102. 什么是 XSS 攻击？如何防范 XSS 攻击？</h4><p>&nbsp;&nbsp;<code>XSS</code> 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 <code>cookie</code> 等。</p><p>&nbsp;&nbsp;<code>XSS</code> 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p><p>&nbsp;&nbsp;<code>XSS</code> 一般分为<code>存储型、反射型和 DOM 型</code>。</p><p>&nbsp;&nbsp;存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 <code>HTML</code> 后返回给了用户，从而导致了恶意代码的执行。</p><p>&nbsp;&nbsp;反射型指的是攻击者构建了特殊的 <code>URL</code>，当服务器接收到请求后，从 <code>URL</code> 中获取数据，拼接到 <code>HTML</code> 后返回，从而导致了恶意代码的执行。</p><p>&nbsp;&nbsp;<code>DOM</code> 型指的是攻击者构建了特殊的 <code>URL</code>，用户打开网站后，<code>js</code> 脚本从 <code>URL</code> 中获取数据，从而导致了恶意代码的执行。</p><p>&nbsp;&nbsp;<code>XSS</code> 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。</p><p>&nbsp;&nbsp;对于第一个方面，如果我们对存入数据库的数据都进行的转义处理，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。</p><p>&nbsp;&nbsp;因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对需要插入到 <code>HTML</code> 中的代码做好充分的转义。对于 <code>DOM</code> 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</p><p>&nbsp;&nbsp;还有一些方式，比如使用 <code>CSP</code> ，<code>CSP</code> 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</p><p>&nbsp;&nbsp;还可以对一些敏感信息进行保护，比如 <code>cookie</code> 使用 <code>http-only</code> ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</p><p>详细资料可以参考：<a href="https://juejin.im/post/5bad9140e51d450e935c6d64">《前端安全系列（一）：如何防止 XSS 攻击？》</a></p><h4 id="103-什么是-CSP？"><a href="#103-什么是-CSP？" class="headerlink" title="103. 什么是 CSP？"></a>103. 什么是 CSP？</h4><p>&nbsp;&nbsp;<code>CSP</code> 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</p><p>&nbsp;&nbsp;通常有两种方式来开启 <code>CSP</code>，一种是设置 <code>HTTP</code> 首部中的 <code>Content-Security-Policy</code>，一种是设置 <code>meta</code> 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></p><p>详细资料可以参考：<br>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">《内容安全策略（CSP）》</a><br>  <a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc721851882516c33430a2">《前端面试之道》</a></p><h4 id="104-什么是-CSRF-攻击？如何防范-CSRF-攻击？"><a href="#104-什么是-CSRF-攻击？如何防范-CSRF-攻击？" class="headerlink" title="104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？"></a>104. 什么是 CSRF 攻击？如何防范 CSRF 攻击？</h4><p>&nbsp;&nbsp;<code>CSRF</code> 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被<br>攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p><p>&nbsp;&nbsp;<code>CSRF</code> 攻击的本质是利用了 <code>cookie</code> 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</p><p><strong>一般的 CSRF 攻击类型有三种：</strong></p><ol><li>是 <code>GET</code> 类型的 <code>CSRF</code> 攻击，比如在网站中的一个 <code>img</code> 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</li><li>是 <code>POST</code> 类型的 <code>CSRF</code> 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</li><li>是链接类型的 <code>CSRF</code> 攻击，比如说在 <code>a</code> 标签的 <code>href</code> 属性里构建一个请求，然后诱导用户去点击。</li></ol><p><strong>CSRF 可以用下面几种方法来防护：</strong></p><ol><li><p>是同源检测的方法，服务器根据 <code>http</code> 请求头中 <code>origin</code> 或者 <code>referer</code> 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 <code>origin</code> 或者 <code>referer</code> 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 <code>referer</code> 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。</p></li><li><p>是使用 <code>CSRF Token</code> 来进行验证，服务器向用户返回一个随机数 <code>Token</code> ，当网站再次发起请求时，在请求参数中加入服务器端返回的 <code>token</code>，然后服务器对这个 <code>token</code> 进行验证。这种方法解决了使用 <code>cookie</code> 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 <code>token</code>，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 <code>session</code> 中没有保留这个 <code>token</code> 的话，就没有办法验证了。这种情况我们可以通过改变 <code>token</code> 的构建方式来解决。</p></li><li><p>使用双重 <code>Cookie</code> 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个 <code>Cookie</code>，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 <code>Cookie</code> 中取出这个字符串，添加到 <code>URL</code> 参数中，然后服务器通过对 <code>Cookie</code> 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 <code>Cookie</code>，但是不能访问获取 <code>Cookie</code> 的特点。并且这种方法比 <code>CSRF Token</code> 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</p></li><li><p>是使用在设置 <code>Cookie</code> 属性的时候设置 <code>Samesite</code> ，限制 <code>Cookie</code> 不能作为被第三方使用，从而可以避免被攻击者利用。<code>Samesite</code> 一共有两种模式，一种是严格模式，在严格模式下 <code>Cookie</code> 在任何情况下都不可能作为第三方 <code>Cookie</code> 使用，在宽松模式下，<code>Cookie</code> 可以被请求是 <code>GET</code> 请求，且会发生页面跳转的请求所使用。</p></li></ol><p>详细资料可以参考：<br>  <a href="https://juejin.im/post/5bc009996fb9a05d0a055192">《前端安全系列之二：如何防止 CSRF 攻击？》</a><br>  <a href="https://www.jianshu.com/p/1f9c71850299">《[ HTTP 趣谈] origin, referer 和 host 区别》</a></p><h4 id="105-什么是-Samesite-Cookie-属性？"><a href="#105-什么是-Samesite-Cookie-属性？" class="headerlink" title="105. 什么是 Samesite Cookie 属性？"></a>105. 什么是 Samesite Cookie 属性？</h4><p>&nbsp;&nbsp;<code>Samesite Cookie</code> 表示同站 <code>cookie</code>，避免 <code>cookie</code> 被第三方所利用。</p><p>&nbsp;&nbsp;将 <code>Samesite</code> 设为 <code>strict</code> ，这种称为严格模式，表示这个 <code>cookie</code> 在任何情况下都不可能作为第三方 <code>cookie</code>。</p><p>&nbsp;&nbsp;将 <code>Samesite</code> 设为 <code>Lax</code> ，这种模式称为宽松模式，如果这个请求是个 <code>GET</code> 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 <code>cookie</code> 可以作为第三方 <code>cookie</code>，其余情况下都不能作为第三方 <code>cookie</code>。</p><p>&nbsp;&nbsp;使用这种方法的缺点是，因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都回重新登录。还有一个问题就是它的兼容性不够好。</p><h4 id="106-什么是点击劫持？如何防范点击劫持？"><a href="#106-什么是点击劫持？如何防范点击劫持？" class="headerlink" title="106. 什么是点击劫持？如何防范点击劫持？"></a>106. 什么是点击劫持？如何防范点击劫持？</h4><p>&nbsp;&nbsp;点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 <code>iframe</code> 嵌套的方式嵌入自己的网页中，并将 <code>iframe</code> 设置为透明，在页面中透出一个按钮诱导用户点击。</p><p>&nbsp;&nbsp;我们可以在 <code>http</code> 相应头中设置 <code>X-FRAME-OPTIONS</code> 来防御用 <code>iframe</code> 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特<br>定的一些情况才能作为 <code>iframe</code> 来使用。</p><p>详细资料可以参考：<a href="https://www.jianshu.com/p/251704d8ff18">《web 安全之–点击劫持攻击与防御技术简介》</a></p><h4 id="107-SQL-注入攻击？"><a href="#107-SQL-注入攻击？" class="headerlink" title="107. SQL 注入攻击？"></a>107. SQL 注入攻击？</h4><p>&nbsp;&nbsp;<code>SQL</code> 注入攻击指的是攻击者在 <code>HTTP</code> 请求中注入恶意的 <code>SQL</code> 代码，服务器使用参数构建数据库 <code>SQL</code> 命令时，恶意 <code>SQL</code> 被一起构造，破坏原有 <code>SQL</code> 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。</p><p>详细资料可以参考：<br>  <a href="https://juejin.im/post/5bd5b820e51d456f72531fa8">《Web 安全漏洞之 SQL 注入》</a><br>  <a href="http://blog.720ui.com/2016/security_web/#SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB">《如何防范常见的 Web 攻击》</a></p><h4 id="108-什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？"><a href="#108-什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？" class="headerlink" title="108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？"></a>108. 什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</h4><p>&nbsp;&nbsp;<code>MVC、MVP 和 MVVM</code> 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化我们的开发效率。</p><p>&nbsp;&nbsp;比如说我们实验室在以前项目开发的时候，使用单页应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，当时一旦项目变得复杂，那么整个文件就会变得冗长，混乱，这样对我们的项目开发和后期的项目维护是非常不利的。</p><p>&nbsp;&nbsp;<code>MVC</code> 通过分离 <code>Model、View 和 Controller</code> 的方式来组织代码结构。其中 <code>View</code> 负责页面的显示逻辑，<code>Model</code> 负责存储页面的业务数据，以及对相应数据的操作。并且 <code>View 和 Model</code> 应用了观察者模式，当 <code>Model</code> 层发生改变的时候它会通知有关 <code>View</code> 层更新页面。<code>Controller</code> 层是 <code>View 层和 Model 层</code>的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，<code>Controller</code> 中的事件触发器就开始工作了，通过调用 <code>Model</code> 层，来完成对 <code>Model</code> 的修改，然后 <code>Model</code> 层再去通知 <code>View</code> 层更新。</p><p>&nbsp;&nbsp;<code>MVP</code> 模式与 <code>MVC</code> 唯一不同的在于 <code>Presenter 和 Controller</code>。在 MVC 模式中我们使用观察者模式，来实现当 <code>Model</code> 层数据发生变化的时候，通知 <code>View</code> 层的更新。这样 <code>View 层和 Model 层</code>耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。<code>MVP</code> 的模式通过使用 <code>Presenter</code> 来实现对 <code>View 层和 Model 层</code>的解耦。<code>MVC</code> 中的<code>Controller</code> 只知道 <code>Model</code> 的接口，因此它没有办法控制 <code>View</code> 层的更新，<code>MVP</code> 模式中，<code>View</code> 层的接口暴露给了 <code>Presenter</code> 因此我们可以在 <code>Presenter</code> 中将 <code>Model</code> 的变化和 <code>View</code> 的变化绑定在一起，以此来实现 <code>View 和 Model</code> 的同步更新。这样就实现了对 <code>View 和 Model</code> 的解耦，<code>Presenter</code> 还包含了其他的响应逻辑。</p><p>&nbsp;&nbsp;<code>MVVM</code> 模式中的 <code>VM</code>，指的是 <code>ViewModel</code>，它和 <code>MVP</code> 的思想其实是相同的，不过它通过双向的数据绑定，将 <code>View 和 Model</code>的同步更新给自动化了。当 <code>Model</code> 发生变化的时候，<code>ViewModel</code> 就会自动更新；<code>ViewModel</code> 变化了，<code>View</code> 也会更新。这样就将 <code>Presenter</code> 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如 <code>vue</code> 是通过使用数据劫持和发布订阅者模式来实现的这一功能。</p><p>详细资料可以参考：<br>  <a href="https://juejin.im/post/593021272f301e0058273468">《浅析前端开发中的 MVC&#x2F;MVP&#x2F;MVVM 模式》</a><br>  <a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">《MVC，MVP 和 MVVM 的图示》</a><br>  <a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf">《MVVM》</a><br>  <a href="https://segmentfault.com/a/1190000015310674">《一篇文章了解架构模式：MVC&#x2F;MVP&#x2F;MVVM》</a></p><h4 id="109-vue-双向数据绑定原理？"><a href="#109-vue-双向数据绑定原理？" class="headerlink" title="109. vue 双向数据绑定原理？"></a>109. vue 双向数据绑定原理？</h4><p>&nbsp;&nbsp;<code>vue</code> 通过使用双向数据绑定，来实现了 <code>View 和 Model</code> 的同步更新。<code>vue</code> 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。</p><p>&nbsp;&nbsp;首先我们通过 <code>Object.defineProperty()</code> 方法来对 <code>Model</code> 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 <code>Model</code> 中的数据发生变化的时候，我们可以通过配置的 <code>setter 和 getter</code> 方法来实现对 <code>View</code> 层数据更新的通知。</p><p>&nbsp;&nbsp;数据在 <code>html</code> 模板中一共有两种绑定情况，一种是使用 <code>v-model</code> 来对 <code>value</code> 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中。</p><p>&nbsp;&nbsp;如果遇到元素节点，并且属性值包含 <code>v-model</code> 的话，我们就从 <code>Model</code> 中去获取 <code>v-model</code> 所对应的属性的值，并赋值给元素的 <code>value</code> 值。然后给这个元素设置一个监听事件，当 <code>View</code> 中元素的数据发生变化的时候触发该事件，通知 <code>Model</code> 中的对应的属性的值进行更新。</p><p>&nbsp;&nbsp;如果遇到了绑定的文本节点，我们使用 <code>Model</code> 中对应的属性的值来替换这个文本。对于文本节点的更新，我们使用了发布订阅者模式，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 <code>Model</code> 层数据发生改变的时候，<code>Model</code> 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数据。</p><p>详细资料可以参考：<a href="http://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension">《Vue.js 双向绑定的实现原理》</a></p><h4 id="110-Object-defineProperty-介绍？"><a href="#110-Object-defineProperty-介绍？" class="headerlink" title="110. Object.defineProperty 介绍？"></a>110. Object.defineProperty 介绍？</h4><p>&nbsp;&nbsp;<code>Object.defineProperty</code> 函数一共有三个参数，第一个参数是需要定义属性的对象，第二个参数是需要定义的属性，第三个是该属性描述符。</p><p>&nbsp;&nbsp;一个属性的描述符有四个属性，分别是 <code>value</code> 属性的值，<code>writable</code> 属性是否可写，<code>enumerable</code> 属性是否可枚举，<code>configurable</code> 属性是否可配置修改。</p><p>详细资料可以参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">《Object.defineProperty()》</a></p><h4 id="111-使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#111-使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>111. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h4><p>&nbsp;&nbsp;有一些对属性的操作，使用这种方法无法拦截，比如说通过下标方式修改数组数据或者给对象新增属性，<code>vue</code> 内部通过重写函数解决了这个问题。在 <code>Vue3.0</code> 中已经不使用这种方式了，而是通过使用 <code>Proxy</code> 对对象进行代理，从而实现数据劫持。使用 <code>Proxy</code> 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为这是 <code>ES6</code> 的语法。</p><h4 id="112-什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？"><a href="#112-什么是-Virtual-DOM？为什么-Virtual-DOM-比原生-DOM-快？" class="headerlink" title="112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？"></a>112. 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？</h4><p><strong>我对 Virtual DOM 的理解是:</strong></p><p>&nbsp;&nbsp;首先对我们将要插入到文档中的 DOM 树结构进行分析，使用 <code>js</code> 对象将其表示出来，比如一个元素对象，包含 <code>TagName、props 和 Children</code> 这些属性。然后我们将这个 <code>js</code> 对象树给保存下来，最后再将 <code>DOM </code>片段插入到文档中。</p><p>&nbsp;&nbsp;当页面的状态发生改变，我们需要对页面的 <code>DOM</code> 的结构进行调整的时候，我们首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</p><p>&nbsp;&nbsp;最后将记录的有差异的地方应用到真正的 <code>DOM</code> 树中去，这样视图就更新了。</p><p>&nbsp;&nbsp;我认为 <code>Virtual DOM</code> 这种方法对于我们需要有大量的 <code>DOM</code> 操作的时候，能够很好的提高我们的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 <code>DOM</code> 操作带来的重流和重绘的影响。其实 <code>Virtual DOM</code> 并不一定比我们真实的操作 <code>DOM</code> 要快，这种方法的目的是为了提高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。</p><p>详细资料可以参考：<br>  <a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc72e6e51d45054f664dbf">《Virtual DOM》</a><br>  <a href="https://github.com/y8n/blog/issues/5">《理解 Virtual DOM》</a><br>  <a href="https://github.com/livoras/blog/issues/13">《深度剖析：如何实现一个 Virtual DOM 算法》</a><br>  <a href="https://www.zhihu.com/question/31809713/answer/53544875">《网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？》</a></p><h4 id="113-如何比较两个-DOM-树的差异？"><a href="#113-如何比较两个-DOM-树的差异？" class="headerlink" title="113. 如何比较两个 DOM 树的差异？"></a>113. 如何比较两个 DOM 树的差异？</h4><p>&nbsp;&nbsp;两个树的完全 <code>diff</code> 算法的时间复杂度为 <code>O(n^3)</code> ，但是在前端中，我们很少会跨层级的移动元素，所以我们只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 <code>O(n)</code>。</p><p>&nbsp;&nbsp;算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，我们就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。</p><p>&nbsp;&nbsp;在对列表元素进行对比的时候，由于 <code>TagName</code> 是重复的，所以我们不能使用这个来对比。我们需要给每一个子节点加上一个 <code>key</code>，列表对比的时候使用 <code>key</code> 来进行比较，这样我们才能够复用老的 <code>DOM</code> 树上的节点。</p><h4 id="114-什么是-requestAnimationFrame-？"><a href="#114-什么是-requestAnimationFrame-？" class="headerlink" title="114. 什么是 requestAnimationFrame ？"></a>114. 什么是 requestAnimationFrame ？</h4><p>详细资料可以参考：<br>  <a href="https://juejin.im/post/5a82f0626fb9a06358657c9c">《你需要知道的 requestAnimationFrame》</a><br>  <a href="https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/">《CSS3 动画那么强，requestAnimationFrame 还有毛线用？》</a></p><h4 id="115-谈谈你对-webpack-的看法"><a href="#115-谈谈你对-webpack-的看法" class="headerlink" title="115. 谈谈你对 webpack 的看法"></a>115. 谈谈你对 webpack 的看法</h4><p>&nbsp;&nbsp;我当时使用 <code>webpack</code> 的一个最主要原因是为了简化页面依赖的管理，并且通过将其打包为一个文件来降低页面加载时请求的资源数。</p><p>&nbsp;&nbsp;我认为 <code>webpack</code> 的主要原理是，它将所有的资源都看成是一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，<code>webpack</code> 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 <code>loader</code> 和 <code>plugins</code> 处理后，然后打包在一起，最后输出一个浏览器可识别的 <code>JS</code> 文件。</p><p><strong>Webpack:</strong> 具有五个核心的概念，分别是 <code>Entry（入口）、Output（输出）、loader 、 Plugins（插件）和mode（模式）</code>。</p><p><strong>Entry:</strong> 是 <code>webpack</code> 的入口起点，它指示 <code>webpack</code> 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。</p><p><strong>Output:</strong> 属性告诉 <code>webpack</code> 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 <code>./dist</code>。</p><p><strong>loader:</strong> 可以理解为 <code>webpack</code> 的编译器，它使得 <code>webpack</code> 可以处理一些非 <code>JavaScript</code> 文件。在对 <code>loader</code> 进行配置的时候，<code>test</code> 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。<code>use</code> 属性，指定 <code>test</code> 类型的文件应该使用哪个 <code>loader</code> 进行预处理。常用的 <code>loader</code> 有 <code>css-loader、style-loader</code> 等。</p><p>&nbsp;&nbsp;插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 <code>npm</code> 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 <code>plugins</code> 数组属性。</p><p>&nbsp;&nbsp;使用 <code>webpack</code> 的确能够提供我们对于项目的管理，但是它的缺点就是调试和配置起来太麻烦了。但现在<code> webpack4.0</code> 的免配置一定程度上解决了这个问题。但是我感觉对我来说，就是一个黑盒，很多时候出现了问题，没有办法很好的定位。</p><p>详细资料可以参考：<br>  <a href="https://juejin.im/post/5b38d27451882574d87aa5d5#heading-0">《不聊 webpack 配置，来说说它的原理》</a><br>  <a href="https://juejin.im/entry/5b5724d05188251aa01647fd">《前端工程化——构建工具选型：grunt、gulp、webpack》</a><br>  <a href="https://juejin.im/post/5afa9cd0f265da0b981b9af9#heading-0">《浅入浅出 webpack》</a><br>  <a href="https://juejin.im/entry/5ae5c8c9f265da0b9f400d8e">《前端构建工具发展及其比较》</a></p><h4 id="116-offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？"><a href="#116-offsetWidth-offsetHeight-clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？" class="headerlink" title="116. offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别？"></a>116. offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别？</h4><p><strong>clientWidth&#x2F;clientHeight:</strong> 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。<br><strong>clientTop:</strong> 返回的是上边框的宽度。<br><strong>clientLeft:</strong> 返回的左边框的宽度。</p><p><strong>offsetWidth&#x2F;offsetHeight:</strong> 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。<br>**offsetTop :**返回的是当前元素相对于其 offsetParent 元素的顶部的距离。（即元素的定位Top值）<br><strong>offsetLeft:</strong> 返回的是当前元素相对于其 offsetParent 元素的左部的距离。（即元素的定位Left值）</p><p><strong>scrollWidth&#x2F;scrollHeight:</strong> 返回值包含 content + padding + 溢出内容的尺寸。<br><strong>scrollTop:</strong> 属性返回的是一个元素的内容垂直滚动的像素数。<br><strong>scrollLeft:</strong> 属性返回的是元素滚动条到元素左边的距离。</p><p>详细资料可以参考：<br>  <a href="https://juejin.im/post/5bc9366d5188255c4834e75a">《最全的获取元素宽高及位置的方法》</a><br>  <a href="http://www.ruanyifeng.com/blog/2009/09/find_element_s_position_using_javascript.html">《用 Javascript 获取页面元素的位置》</a></p><h4 id="117-谈一谈你理解的函数式编程？"><a href="#117-谈一谈你理解的函数式编程？" class="headerlink" title="117. 谈一谈你理解的函数式编程？"></a>117. 谈一谈你理解的函数式编程？</h4><p>&nbsp;&nbsp;简单说，”函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论。</p><p>&nbsp;&nbsp;它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是”第一等公民”、只用”表达式”。</p><p>详细资料可以参考：<a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html">《函数式编程初探》</a></p><h4 id="118-异步编程的实现方式？"><a href="#118-异步编程的实现方式？" class="headerlink" title="118. 异步编程的实现方式？"></a>118. 异步编程的实现方式？</h4><p><strong>相关资料：</strong></p><p><strong>回调函数</strong></p><ul><li>优点：简单、容易理解</li><li>缺点：不利于维护，代码耦合高</li></ul><p><strong>事件监听（采用时间驱动模式，取决于某个事件是否发生）：</strong></p><ul><li>优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li><li>缺点：事件驱动型，流程不够清晰</li></ul><p><strong>发布&#x2F;订阅（观察者模式）</strong></p><ul><li>类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者</li></ul><p><strong>Promise 对象</strong></p><ul><li>优点：可以利用 then 方法，进行链式写法；可以书写错误时的回调函数；</li><li>缺点：编写和理解，相对比较难</li></ul><p><strong>Generator 函数</strong></p><ul><li>优点：函数体内外的数据交换、错误处理机制</li><li>缺点：流程管理不方便</li></ul><p><strong>async 函数</strong></p><ul><li>优点：内置执行器、更好的语义、更广的适用性、返回的是 Promise、结构清晰。</li><li>缺点：错误处理机制</li></ul><p><strong>回答：</strong></p><p><strong>js 中的异步机制可以分为以下几种：</strong></p><ol><li><p>最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</p></li><li><p>是 <code>Promise</code> 的方式，使用 <code>Promise</code> 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 <code>then</code> 的链式调用，可能会造成代码的语义不够明确。</p></li><li><p>是使用 <code>generator</code> 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部我们还可以将执行权转移回来。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来。因此我们在 <code>generator</code> 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 <code>generator</code> 的机制，比如说 <code>co</code> 模块等方式来实现 <code>generator</code> 的自动执行。</p></li><li><p>是使用 <code>async</code> 函数的形式，<code>async</code> 函数是 <code>generator</code> 和 <code>promise</code> 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 <code>await</code> 语句的时候，如果语句返回一个 <code>promise</code> 对象，那么函数将会等待 <code>promise</code> 对象的状态变为 <code>resolve</code> 后再继续向下执行。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</p></li></ol><h4 id="119-Js-动画与-CSS-动画区别及相应实现"><a href="#119-Js-动画与-CSS-动画区别及相应实现" class="headerlink" title="119. Js 动画与 CSS 动画区别及相应实现"></a>119. Js 动画与 CSS 动画区别及相应实现</h4><p><strong>CSS3 的动画的优点:</strong></p><ul><li>在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化代码相对简单</li></ul><p><strong>缺点:</strong></p><ul><li>在动画控制上不够灵活</li><li>兼容性不好</li></ul><p>&nbsp;&nbsp;<code>JavaScript</code> 的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。对于一些复杂控制的动画，使用 <code>javascript</code> 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 <code>CSS</code> 吧</p><h4 id="120-get-请求传参长度的误区"><a href="#120-get-请求传参长度的误区" class="headerlink" title="120. get 请求传参长度的误区"></a>120. get 请求传参长度的误区</h4><p><strong>误区：</strong> 我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。</p><p>&nbsp;&nbsp;实际上 HTTP 协议从未规定 GET&#x2F;POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:</p><ul><li>1.HTTP 协议未规定 GET 和 POST 的长度限制</li><li>2.GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度</li><li>3.不同的浏览器和 WEB 服务器，限制的最大长度不一样</li><li>4.要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte</li></ul><h4 id="121-URL-和-URI-的区别？"><a href="#121-URL-和-URI-的区别？" class="headerlink" title="121. URL 和 URI 的区别？"></a>121. URL 和 URI 的区别？</h4><ul><li>URI: Uniform Resource Identifier      指的是统一资源标识符</li><li>URL: Uniform Resource Location        指的是统一资源定位符</li><li>URN: Universal Resource Name          指的是统一资源名称</li></ul><p>&nbsp;&nbsp;URI 指的是统一资源标识符，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说，不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。</p><p>&nbsp;&nbsp;URL 指的是统一资源定位符，URN 指的是统一资源名称。URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源，URN 可以理解为使用名称来标识资源。</p><p>详细资料可以参考：<br>  <a href="https://www.zhihu.com/question/21950864">《HTTP 协议中 URI 和 URL 有什么区别？》</a><br>  <a href="http://web.jobbole.com/83452/">《你知道 URL、URI 和 URN 三者之间的区别吗？》</a><br>  <a href="https://segmentfault.com/a/1190000006081973">《URI、URL 和 URN 的区别》</a></p><h4 id="122-get-和-post-请求在缓存方面的区别"><a href="#122-get-和-post-请求在缓存方面的区别" class="headerlink" title="122. get 和 post 请求在缓存方面的区别"></a>122. get 和 post 请求在缓存方面的区别</h4><p><strong>相关知识点：</strong></p><ul><li><p>get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</p></li><li><p>post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。</p></li></ul><p><strong>回答：</strong></p><p>&nbsp;&nbsp;缓存一般只适用于那些不会更新服务端数据的请求。一般 get 请求都是查找请求，不会对服务器资源数据造成修改，而 post 请求一般都会对服务器数据造成修改，所以，一般会对 get 请求进行缓存，很少会对 post 请求进行缓存。</p><p>详细资料可以参考：<a href="https://blog.csdn.net/qq_27093465/article/details/50479289">《HTML 关于 post 和 get 的区别以及缓存问题的理解》</a></p><h4 id="123-图片的懒加载和预加载"><a href="#123-图片的懒加载和预加载" class="headerlink" title="123. 图片的懒加载和预加载"></a>123. 图片的懒加载和预加载</h4><p><strong>相关知识点：</strong></p><ul><li><p>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</p></li><li><p>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。</p></li></ul><p>&nbsp;&nbsp;两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p><p><strong>回答：</strong></p><p>&nbsp;&nbsp;懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。</p><p>&nbsp;&nbsp;预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。</p><p>&nbsp;&nbsp;这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p><p>详细资料可以参考：<br>  <a href="https://juejin.im/post/5b0c3b53f265da09253cbed0">《懒加载和预加载》</a><br>  <a href="https://juejin.im/entry/5a73f38cf265da4e99575be3">《网页图片加载优化方案》</a><br>  <a href="https://www.zhangxinxu.com/wordpress/2016/06/image-preload-based-on-user-behavior/">《基于用户行为的图片等资源预加载》</a></p><h4 id="124-mouseover-和-mouseenter-的区别？"><a href="#124-mouseover-和-mouseenter-的区别？" class="headerlink" title="124. mouseover 和 mouseenter 的区别？"></a>124. mouseover 和 mouseenter 的区别？</h4><p>&nbsp;&nbsp;当鼠标移动到元素上时就会触发 <code>mouseenter</code> 事件，类似 <code>mouseover</code>，它们两者之间的差别是 <code>mouseenter</code> 不会冒泡。</p><p>&nbsp;&nbsp;由于 <code>mouseenter</code> 不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其 <code>mouseover</code> 和 <code>mouseout</code> 事件，但是却不会触发 <code>mouseenter</code> 和 <code>mouseleave</code> 事件。<br>事件委派必须使用<code>mouseover</code>和<code>mouseout</code>这一对。</p><p>详细资料可以参考：<a href="https://github.com/qianlongo/zepto-analysis/issues/1">《mouseenter 与 mouseover 为何这般纠缠不清？》</a></p><h4 id="125-js-拖拽功能的实现"><a href="#125-js-拖拽功能的实现" class="headerlink" title="125. js 拖拽功能的实现"></a>125. js 拖拽功能的实现</h4><p><strong>相关知识点：</strong></p><p>&nbsp;&nbsp;首先是三个事件，分别是 <code> mousedown，mousemove，mouseup</code> 当鼠标点击按下的时候，需要一个 <code>tag</code> 标识此时已经按下，可以执行 <code>mousemove</code> 里面的具体方法。<code>clientX，clientY</code> 标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用 <code>offsetX</code> 和 <code>offsetY</code> 来表示元素的初始坐标，移动的距离应该是：<br>鼠标移动时候的坐标-鼠标按下去时候的坐标。<br>也就是说定位信息为：<br>鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的 <code>offetLeft</code>.</p><p><strong>回答：</strong></p><p>&nbsp;&nbsp;一个元素的拖拽过程，我们可以分为三个步骤，第一步是鼠标按下目标元素，第二步是鼠标保持按下的状态移动鼠标，第三步是鼠标抬起，拖拽过程结束。</p><p>&nbsp;&nbsp;这三步分别对应了三个事件，<code>mousedown</code> 事件，<code>mousemove</code> 事件和 <code>mouseup</code> 事件。只有在鼠标按下的状态移动鼠标我们才会执行拖拽事件，因此我们需要在 <code>mousedown</code> 事件中设置一个状态来标识鼠标已经按下，然后在 <code>mouseup</code> 事件中再取消这个状态。在 <code>mousedown</code> 事件中我们首先应该判断，目标元素是否为拖拽元素，如果是拖拽元素，我们就设置状态并且保存这个时候鼠标的位置。然后在 <code>mousemove</code> 事件中，我们通过判断鼠标现在的位置和以前位置的相对移动，来确定拖拽元素在移动中的坐标。最后 <code>mouseup</code> 事件触发后，清除状态，结束拖拽事件。</p><p>详细资料可以参考：<a href="https://blog.csdn.net/LZGS_4/article/details/43523465">《原生 js 实现拖拽功能基本思路》</a></p><h4 id="126-为什么使用-setTimeout-实现-setInterval？怎么模拟？"><a href="#126-为什么使用-setTimeout-实现-setInterval？怎么模拟？" class="headerlink" title="126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？"></a>126. 为什么使用 setTimeout 实现 setInterval？怎么模拟？</h4><p><strong>相关知识点：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mySetInterval</span>(<span class="hljs-params">fn, timeout</span>) &#123;<br>  <span class="hljs-comment">// 控制器，控制定时器是否继续执行</span><br>  <span class="hljs-keyword">var</span> timer = &#123;<br>    <span class="hljs-attr">flag</span>: <span class="hljs-literal">true</span><br>  &#125;;<br><br>  <span class="hljs-comment">// 设置递归函数，模拟定时器执行。</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">interval</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (timer.<span class="hljs-property">flag</span>) &#123;<br>      <span class="hljs-title function_">fn</span>();<br>      <span class="hljs-built_in">setTimeout</span>(interval, timeout);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 启动定时器</span><br>  <span class="hljs-built_in">setTimeout</span>(interval, timeout);<br><br>  <span class="hljs-comment">// 返回控制器</span><br>  <span class="hljs-keyword">return</span> timer;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>回答：</strong></p><p>&nbsp;&nbsp;<code>setInterval</code> 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</p><p>&nbsp;&nbsp;针对 <code>setInterval</code> 的这个缺点，我们可以使用 <code>setTimeout</code> 递归调用来模拟 <code>setInterval</code>，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 <code>setInterval</code> 的问题。</p><p>详细资料可以参考：<br><a href="https://www.jianshu.com/p/32479bdfd851">《用 setTimeout 实现 setInterval》</a><br><a href="https://zhuanlan.zhihu.com/p/51995737">《setInterval 有什么缺点？》</a></p><h4 id="127-let-和-const-的注意点？"><a href="#127-let-和-const-的注意点？" class="headerlink" title="127. let 和 const 的注意点？"></a>127. let 和 const 的注意点？</h4><ul><li>1.声明的变量只在声明时的代码块内有效</li><li>2.不存在声明提升</li><li>3.存在暂时性死区，如果在变量声明前使用，会报错</li><li>4.不允许重复声明，重复声明会报错</li></ul><h4 id="128-什么是-rest-参数？"><a href="#128-什么是-rest-参数？" class="headerlink" title="128. 什么是 rest 参数？"></a>128. 什么是 rest 参数？</h4><p><code>rest</code> 参数（形式为…变量名），用于获取函数的多余参数。</p><h4 id="129-什么是尾调用，使用尾调用有什么好处？"><a href="#129-什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="129. 什么是尾调用，使用尾调用有什么好处？"></a>129. 什么是尾调用，使用尾调用有什么好处？</h4><p>&nbsp;&nbsp;尾调用指的是函数的最后一步调用另一个函数。我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p><h4 id="130-Symbol-类型的注意点？"><a href="#130-Symbol-类型的注意点？" class="headerlink" title="130. Symbol 类型的注意点？"></a>130. Symbol 类型的注意点？</h4><ul><li>1.<code>Symbol</code> 函数前不能使用 <code>new</code> 命令，否则会报错。</li><li>2.<code>Symbol</code> 函数可以接受一个字符串作为参数，表示对 <code>Symbol</code> 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</li><li>3.<code>Symbol</code> 作为属性名，该属性不会出现在 <code>for...in、for...of</code> 循环中，也不会被 <code>Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()</code> 返回。</li><li>4.<code>Object.getOwnPropertySymbols</code> 方法返回一个数组，成员是当前对象的所有用作属性名的 <code>Symbol</code> 值。</li><li>5.<code>Symbol.for</code> 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 <code>Symbol</code> 值。如果有，就返回这个 <code>Symbol</code> 值，否则就新建并返回一个以该字符串为名称的 <code>Symbol</code> 值。</li><li>6.<code>Symbol.keyFor</code> 方法返回一个已登记的 <code>Symbol</code> 类型值的 <code>key</code>。</li></ul><h4 id="131-Set-和-WeakSet-结构？"><a href="#131-Set-和-WeakSet-结构？" class="headerlink" title="131. Set 和 WeakSet 结构？"></a>131. Set 和 WeakSet 结构？</h4><ul><li>1.ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</li><li>2.WeakSet 结构与 Set 类似，也是不重复的值的集合。但是 WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用。</li></ul><h4 id="132-Map-和-WeakMap-结构？"><a href="#132-Map-和-WeakMap-结构？" class="headerlink" title="132. Map 和 WeakMap 结构？"></a>132. Map 和 WeakMap 结构？</h4><ul><li>1.Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li><li>2.WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li></ul><h4 id="133-什么是-Proxy-？"><a href="#133-什么是-Proxy-？" class="headerlink" title="133. 什么是 Proxy ？"></a>133. 什么是 Proxy ？</h4><p><code>Proxy</code> 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。</p><p>&nbsp;&nbsp;<code>Proxy</code> 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<code>Proxy</code> 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><h4 id="134-Reflect-对象创建目的？"><a href="#134-Reflect-对象创建目的？" class="headerlink" title="134. Reflect 对象创建目的？"></a>134. Reflect 对象创建目的？</h4><ul><li>1.将 <code>Object</code> 对象的一些明显属于语言内部的方法（比如 <code>Object.defineProperty</code>，放到 <code>Reflect</code> 对象上。</li><li>2.修改某些 <code>Object</code> 方法的返回结果，让其变得更合理。</li><li>3.让 <code>Object</code> 操作都变成函数行为。</li><li>4.<code>Reflect</code> 对象的方法与 <code>Proxy</code> 对象的方法一一对应，只要是 <code>Proxy</code> 对象的方法，就能在 <code>Reflect</code> 对象上找到对应的方法。这就让 <code>Proxy</code> 对象可以方便地调用对应的 <code>Reflect</code> 方法，完成默认行为，作为修改行为的基础。也就是说，不管 <code>Proxy</code> 怎么修改默认行为，你总可以在 <code>Reflect</code> 上获取默认行为。</li></ul><h4 id="135-require-模块引入的查找方式？"><a href="#135-require-模块引入的查找方式？" class="headerlink" title="135. require 模块引入的查找方式？"></a>135. require 模块引入的查找方式？</h4><p><strong>当 Node 遇到 require(X) 时，按下面的顺序处理:</strong></p><ol><li><p>如果 X 是内置模块（比如 require(‘http’)）<br>　　a. 返回该模块。<br>　　b. 不再继续执行。</p></li><li><p>如果 X 以 “.&#x2F;“ 或者 “&#x2F;“ 或者 “..&#x2F;“ 开头<br>　　a. 根据 X 所在的父模块，确定 X 的绝对路径。<br>　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。<br> X<br> X.js<br> X.json<br> X.node</p></li></ol><p>　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。<br>    X&#x2F;package.json（main字段）<br>    X&#x2F;index.js<br>    X&#x2F;index.json<br>    X&#x2F;index.node</p><ol start="3"><li><p>如果 X 不带路径<br>　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。<br>　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。</p></li><li><p>抛出 “not found”</p></li></ol><p>详细资料可以参考：<a href="http://www.ruanyifeng.com/blog/2015/05/require.html">《require() 源码解读》</a></p><h4 id="136-什么是-Promise-对象，什么是-Promises-A-规范？"><a href="#136-什么是-Promise-对象，什么是-Promises-A-规范？" class="headerlink" title="136. 什么是 Promise 对象，什么是 Promises&#x2F;A+ 规范？"></a>136. 什么是 Promise 对象，什么是 Promises&#x2F;A+ 规范？</h4><p>&nbsp;&nbsp;<code>Promise</code> 对象是异步编程的一种解决方案，最早由社区提出。<code>Promises/A+</code> 规范是 <code>JavaScript Promise</code> 的标准，规定了一个 <code>Promise</code> 所必须具有的特性。</p><p>&nbsp;&nbsp;<code>Promise</code> 是一个构造函数，接收一个函数作为参数，返回一个 <code>Promise</code> 实例。一个 <code>Promise</code> 实例有三种状态，分别是 <code>pending、resolved 和 rejected</code>，分别代表了进行中、已成功和已失败。实例的状态只能由 <code>pending </code>转变 <code>resolved</code> 或者 <code>rejected</code> 状态，并且状态一经改变，就凝固了，无法再被改变了。状态的改变是通过 <code>resolve()</code> 和 <code>reject()</code> 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 <code>Promise</code> 实例的状态，它的原型上定义了一个 <code>then</code> 方法，使用这个 <code>then</code> 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p><p>详细资料可以参考：<br>  <a href="http://www.ituring.com.cn/article/66566">《Promises&#x2F;A+ 规范》</a><br>  <a href="http://es6.ruanyifeng.com/#docs/promise#Promise-resolve">《Promise》</a></p><h4 id="137-手写一个-Promise"><a href="#137-手写一个-Promise" class="headerlink" title="137. 手写一个 Promise"></a>137. 手写一个 Promise</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RESOLVED</span> = <span class="hljs-string">&quot;resolved&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyPromise</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-comment">// 保存初始化状态</span><br>  <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br><br>  <span class="hljs-comment">// 初始化状态</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-variable constant_">PENDING</span>;<br><br>  <span class="hljs-comment">// 用于保存 resolve 或者 rejected 传入的值</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 用于保存 resolve 的回调函数</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">resolvedCallbacks</span> = [];<br><br>  <span class="hljs-comment">// 用于保存 reject 的回调函数</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">rejectedCallbacks</span> = [];<br><br>  <span class="hljs-comment">// 状态转变为 resolved 方法</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-comment">// 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span><br>    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyPromise</span>) &#123;<br>      <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">then</span>(resolve, reject);<br>    &#125;<br><br>    <span class="hljs-comment">// 保证代码的执行顺序为本轮事件循环的末尾</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 只有状态为 pending 时才能转变，</span><br>      <span class="hljs-keyword">if</span> (self.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-comment">// 修改状态</span><br>        self.<span class="hljs-property">state</span> = <span class="hljs-variable constant_">RESOLVED</span>;<br><br>        <span class="hljs-comment">// 设置传入的值</span><br>        self.<span class="hljs-property">value</span> = value;<br><br>        <span class="hljs-comment">// 执行回调函数</span><br>        self.<span class="hljs-property">resolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> &#123;<br>          <span class="hljs-title function_">callback</span>(value);<br>        &#125;);<br>      &#125;<br>    &#125;, <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 状态转变为 rejected 方法</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-comment">// 保证代码的执行顺序为本轮事件循环的末尾</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 只有状态为 pending 时才能转变</span><br>      <span class="hljs-keyword">if</span> (self.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-comment">// 修改状态</span><br>        self.<span class="hljs-property">state</span> = <span class="hljs-variable constant_">REJECTED</span>;<br><br>        <span class="hljs-comment">// 设置传入的值</span><br>        self.<span class="hljs-property">value</span> = value;<br><br>        <span class="hljs-comment">// 执行回调函数</span><br>        self.<span class="hljs-property">rejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> &#123;<br>          <span class="hljs-title function_">callback</span>(value);<br>        &#125;);<br>      &#125;<br>    &#125;, <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 将两个方法传入函数执行</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-title function_">fn</span>(resolve, reject);<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-comment">// 遇到错误时，捕获错误，执行 reject 函数</span><br>    <span class="hljs-title function_">reject</span>(e);<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">MyPromise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">onResolved, onRejected</span>) &#123;<br>  <span class="hljs-comment">// 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span><br>  onResolved =<br>    <span class="hljs-keyword">typeof</span> onResolved === <span class="hljs-string">&quot;function&quot;</span> ? onResolved : <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123; <span class="hljs-keyword">return</span> value; &#125;;<br><br>  onRejected =<br>    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span> ? onRejected : <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123; <span class="hljs-keyword">throw</span> error; &#125;;<br><br>  <span class="hljs-comment">// 如果是等待状态，则将函数加入对应列表中</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">resolvedCallbacks</span>.<span class="hljs-title function_">push</span>(onResolved);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">rejectedCallbacks</span>.<span class="hljs-title function_">push</span>(onRejected);<br>  &#125;<br><br>  <span class="hljs-comment">// 如果状态已经凝固，则直接执行对应状态的函数</span><br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">RESOLVED</span>) &#123;<br>    <span class="hljs-title function_">onResolved</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>    <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="138-如何检测浏览器所支持的最小字体大小？"><a href="#138-如何检测浏览器所支持的最小字体大小？" class="headerlink" title="138. 如何检测浏览器所支持的最小字体大小？"></a>138. 如何检测浏览器所支持的最小字体大小？</h4><p>用 JS 设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。</p><h4 id="139-怎么做-JS-代码-Error-统计？"><a href="#139-怎么做-JS-代码-Error-统计？" class="headerlink" title="139. 怎么做 JS 代码 Error 统计？"></a>139. 怎么做 JS 代码 Error 统计？</h4><p>error 统计使用浏览器的 window.error 事件。</p><h4 id="140-单例模式模式是什么？"><a href="#140-单例模式模式是什么？" class="headerlink" title="140. 单例模式模式是什么？"></a>140. 单例模式模式是什么？</h4><p>单例模式保证了全局只有一个实例来被访问。比如说常用的如弹框组件的实现和全局状态的实现。</p><h4 id="141-策略模式是什么？"><a href="#141-策略模式是什么？" class="headerlink" title="141. 策略模式是什么？"></a>141. 策略模式是什么？</h4><p>&nbsp;&nbsp;策略模式主要是用来将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。我主要在 MVP 模式解耦的时候用来将视图层的方法定义和方法调用分离。</p><h4 id="142-代理模式是什么？"><a href="#142-代理模式是什么？" class="headerlink" title="142. 代理模式是什么？"></a>142. 代理模式是什么？</h4><p>代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理。</p><h4 id="143-中介者模式是什么？"><a href="#143-中介者模式是什么？" class="headerlink" title="143. 中介者模式是什么？"></a>143. 中介者模式是什么？</h4><p>中介者模式指的是，多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。</p><h4 id="144-适配器模式是什么？"><a href="#144-适配器模式是什么？" class="headerlink" title="144. 适配器模式是什么？"></a>144. 适配器模式是什么？</h4><p>&nbsp;&nbsp;适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。假如我们需要一种新的接口返回方式，但是老的接口由于在太多地方已经使用了，不能随意更改，这个时候就可以使用适配器模式。比如我们需要一种自定义的时间返回格式，但是我们又不能对 js 时间格式化的接口进行修改，这个时候就可以使用适配器模式。</p><p>更多关于设计模式的资料可以参考：<br>  <a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc74186fb9a049ab0d0b6b">《前端面试之道》</a><br>  <a href="https://juejin.im/post/59df4f74f265da430f311909#heading-3">《JavaScript 设计模式》</a><br>  <a href="https://juejin.im/post/5afe6430518825428630bc4d">《JavaScript 中常见设计模式整理》</a></p><h4 id="145-观察者模式和发布订阅模式有什么不同？"><a href="#145-观察者模式和发布订阅模式有什么不同？" class="headerlink" title="145. 观察者模式和发布订阅模式有什么不同？"></a>145. 观察者模式和发布订阅模式有什么不同？</h4><p>发布订阅模式其实属于广义上的观察者模式</p><p>在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。</p><p>&nbsp;&nbsp;而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。</p><p>详细资料可以参考：<a href="https://www.zhihu.com/question/23486749">《观察者模式和发布订阅模式有什么不同？》</a></p><h4 id="146-Vue-的生命周期是什么？"><a href="#146-Vue-的生命周期是什么？" class="headerlink" title="146. Vue 的生命周期是什么？"></a>146. Vue 的生命周期是什么？</h4><p>&nbsp;&nbsp;<code>Vue</code> 的生命周期指的是组件从创建到销毁的一系列的过程，被称为 <code>Vue</code> 的生命周期。通过提供的 <code>Vue</code> 在生命周期各个阶段的钩子函数，我们可以很好的在 <code>Vue</code> 的各个生命阶段实现一些操作。</p><h4 id="147-Vue2-的各个生命阶段是什么？"><a href="#147-Vue2-的各个生命阶段是什么？" class="headerlink" title="147. Vue2 的各个生命阶段是什么？"></a>147. Vue2 的各个生命阶段是什么？</h4><p><code>Vue2</code> 一共有8个生命阶段，分别是<code>创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后</code>，每个阶段对应了一个生命周期的钩子函数。</p><ol><li><p><code>beforeCreate</code> 钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中我们是获取不到 <code>data</code> 数据的。</p></li><li><p><code>created</code> 钩子函数，在实例创建完成后触发，此时可以访问 <code>data、methods</code> 等属性。但这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。</p></li><li><p><code>beforeMount</code> 钩子函数，在组件被挂载到页面之前触发。在 <code>beforeMount</code> 之前，会找到对应的 <code>template</code>，并编译成 <code>render</code> 函数。</p></li><li><p><code>mounted</code> 钩子函数，在组件挂载到页面之后触发。此时可以通过 <code>DOM API</code> 获取到页面中的 <code>DOM</code> 元素。</p></li><li><p><code>beforeUpdate</code> 钩子函数，在响应式数据更新时触发，发生在虚拟 <code>DOM</code> 重新渲染和打补丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。</p></li><li><p><code>updated</code> 钩子函数，虚拟 <code>DOM</code> 重新渲染和打补丁之后调用。</p></li><li><p><code>beforeDestroy</code> 钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、解绑全局事件等。</p></li><li><p><code>destroyed</code> 钩子函数，在实例销毁之后调用，调用后，<code>Vue</code> 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p></li></ol><p>&nbsp;&nbsp;当我们使用 <code>keep-alive</code> 的时候，还有两个钩子函数，分别是 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>actived</code> 钩子函数。</p><p>详细资料可以参考：<br>  <a href="https://juejin.im/entry/5aee8fbb518825671952308c">《vue 生命周期深入》</a><br>  <a href="https://cn.vuejs.org/v2/guide/instance.html">《Vue 实例》</a></p><h4 id="148-Vue-组件间的参数传递方式？"><a href="#148-Vue-组件间的参数传递方式？" class="headerlink" title="148. Vue 组件间的参数传递方式？"></a>148. Vue 组件间的参数传递方式？</h4><p><strong>父子组件间通信:</strong></p><ol><li><p>子组件通过 <code>props</code> 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。</p></li><li><p>通过 <code>ref</code> 属性给子组件设置一个名字。父组件通过 <code>$refs</code> 组件名来获得子组件，子组件通过 <code>$parent</code> 获得父组件，这样也可以实现通信。</p></li><li><p>使用 <code>provider/inject</code>，在父组件中通过 <code>provider</code> 提供变量，在子组件中通过 <code>inject</code> 来将变量注入到组件中。不论子组件有多深，只要调用了 <code>inject</code> 那么就可以注入 <code>provider</code> 中的数据。</p></li></ol><p><strong>兄弟组件间通信:</strong></p><ol><li><p>使用 <code>eventBus</code> 的方法，它的本质是通过创建一个空的 <code>Vue</code> 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</p></li><li><p>通过 <code>$parent.$refs</code> 来获取到兄弟组件，也可以进行通信。</p></li></ol><p><strong>任意组件之间:</strong></p><p>使用 <code>eventBus</code> ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</p><p>&nbsp;&nbsp;如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 <code>vuex</code> ，<code>vuex</code> 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p><p>详细资料可以参考：<a href="https://juejin.im/entry/5ba215ac5188255c6d0d8345">《VUE 组件之间数据传递全集》</a></p><h4 id="149-computed-和-watch-的差异？"><a href="#149-computed-和-watch-的差异？" class="headerlink" title="149. computed 和 watch 的差异？"></a>149. computed 和 watch 的差异？</h4><ol><li><p><code>computed</code> 是计算一个新的属性，并将该属性挂载到 <code>Vue</code> 实例上，而 <code>watch</code> 是监听已经存在且已挂载到 <code>Vue</code> 实例上的数据，所以用 <code>watch</code> 同样可以监听 <code>computed</code> 计算属性的变化。</p></li><li><p><code>computed</code> 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 <code>computed</code> 属性，才会计算新的值。而 <code>watch</code> 则是当数据发生变化便会调用执行函数。</p></li><li><p>从使用场景上说，<code>computed</code> 适用一个数据被多个数据影响，而 <code>watch</code> 适用一个数据影响多个数据。</p></li></ol><p>详细资料可以参考：<br>  <a href="https://juejin.im/post/5b98c4da6fb9a05d353c5fd7">《做面试的不倒翁：浅谈 Vue 中 computed 实现原理》</a><br>  <a href="https://juejin.im/post/5af908ea5188254265399009">《深入理解 Vue 的 watch 实现原理及其实现方式》</a></p><h4 id="150-vue-router-中的导航钩子函数"><a href="#150-vue-router-中的导航钩子函数" class="headerlink" title="150. vue-router 中的导航钩子函数"></a>150. vue-router 中的导航钩子函数</h4><ol><li>全局的钩子函数 <code>beforeEach</code> 和 <code>afterEach</code></li></ol><p>&nbsp;&nbsp;<code>beforeEach</code> 有三个参数，<code>to</code> 代表要进入的路由对象，<code>from</code> 代表离开的路由对象。<code>next</code> 是一个必须要执行的函数，如果不传参数，那就执行下一个钩子函数，如果传入 <code>false</code>，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 <code>error</code> ，则导航终止，<code>error</code> 传入错误的监听函数。</p><ol start="2"><li><p>单个路由独享的钩子函数 <code>beforeEnter</code>，它是在路由配置上直接进行定义的。</p></li><li><p>组件内的导航钩子主要有这三种：<code>beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</code>。它们是直接在路由组件内部直接进行定义的。</p></li></ol><p>详细资料可以参考：<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">《导航守卫》</a></p><h4 id="151-route-和-router-的区别？"><a href="#151-route-和-router-的区别？" class="headerlink" title="151. $route 和 $router 的区别？"></a>151. $route 和 $router 的区别？</h4><p>&nbsp;&nbsp;<code>$route</code> 是“路由信息对象”，包括 <code>path，params，hash，query，fullPath，matched，name</code> 等路由信息参数。而 <code>$router</code> 是 <code>路由实例</code> 对象包括了路由的跳转方法，钩子函数等。</p><h4 id="152-vue-常用的修饰符？"><a href="#152-vue-常用的修饰符？" class="headerlink" title="152. vue 常用的修饰符？"></a>152. vue 常用的修饰符？</h4><ol><li><strong>.prevent:</strong> 提交事件不再重载页面；</li><li><strong>.stop:</strong> 阻止单击事件冒泡；</li><li><strong>.self:</strong> 当事件发生在该元素本身而不是子元素的时候会触发；</li></ol><h4 id="153-vue-中-key-值的作用？"><a href="#153-vue-中-key-值的作用？" class="headerlink" title="153. vue 中 key 值的作用？"></a>153. vue 中 key 值的作用？</h4><p><code>vue</code> 中 <code>key</code> 值的作用可以分为两种情况来考虑。</p><p>&nbsp;&nbsp;第一种情况是 <code>v-if</code> 中使用 <code>key</code>。由于 <code>Vue</code> 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当我们使用 <code>v-if</code> 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 <code>input</code> 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此我们可以通过使用 <code>key</code> 来唯一的标识一个元素，这个情况下，使用 <code>key</code> 的元素不会被复用。这个时候 <code>key</code> 的作用是用来标识一个独立的元素。</p><p>&nbsp;&nbsp;第二种情况是 <code>v-for</code> 中使用 <code>key</code>。用 <code>v-for</code> 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，<code>Vue</code> 不会移动 <code>DOM</code> 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 <code>key</code> 值，来以便 <code>Vue</code> 跟踪元素的身份，从而高效的实现复用。这个时候 <code>key</code> 的作用是为了高效的更新渲染虚拟 <code>DOM</code>。</p><p>详细资料可以参考：<br>  <a href="https://segmentfault.com/a/1190000016344599">《Vue 面试中，经常会被问到的面试题 Vue 知识点整理》</a><br>  <a href="https://www.zhihu.com/question/61064119">《Vue2.0 v-for 中 :key 到底有什么用？》</a><br>  <a href="https://www.cnblogs.com/RainyBear/p/8563101.html">《vue 中 key 的作用》</a></p><h4 id="154-computed-和-watch-区别？"><a href="#154-computed-和-watch-区别？" class="headerlink" title="154. computed 和 watch 区别？"></a>154. computed 和 watch 区别？</h4><p><code>computed</code> 是计算属性，依赖其他属性计算值，并且 <code>computed</code> 的值有缓存，只有当计算值变化才会返回内容。</p><p><code>watch</code> 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</p><h4 id="155-keep-alive-组件有什么作用？"><a href="#155-keep-alive-组件有什么作用？" class="headerlink" title="155. keep-alive 组件有什么作用？"></a>155. keep-alive 组件有什么作用？</h4><p>如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 <code>keep-alive</code> 组件包裹需要保存的组件。</p><h4 id="156-vue-中-mixin-和-mixins-区别？"><a href="#156-vue-中-mixin-和-mixins-区别？" class="headerlink" title="156. vue 中 mixin 和 mixins 区别？"></a>156. vue 中 mixin 和 mixins 区别？</h4><p><code>mixin</code> 用于全局混入，会影响到每个组件实例。</p><p>&nbsp;&nbsp;<code>mixins</code> 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 <code>mixins</code> 混入代码，比如上拉下拉加载数据这种逻辑等等。另外需要注意的是 <code>mixins</code> 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并</p><p>详细资料可以参考：<br>  <a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc731b51882516c56ced6f">《前端面试之道》</a><br>  <a href="https://cn.vuejs.org/v2/guide/mixins.html">《混入》</a></p><h4 id="157-开发中常用的几种-Content-Type-？"><a href="#157-开发中常用的几种-Content-Type-？" class="headerlink" title="157. 开发中常用的几种 Content-Type ？"></a>157. 开发中常用的几种 Content-Type ？</h4><p><strong>application&#x2F;x-www-form-urlencoded:</strong></p><p>&nbsp;&nbsp;浏览器的原生 <code>form</code> 表单，如果不设置 <code>enctype</code> 属性，那么最终就会以 <code>application/x-www-form-urlencoded</code> 方式提交数据。该种方式提交的数据放在 <code>body</code> 里面，数据按照 <code>key1=val1&amp;key2=val2</code> 的方式进行编码，<code>key</code> 和 <code>val</code> 都进行了 <code>URL</code> 转码。</p><p><strong>multipart&#x2F;form-data:</strong></p><p>该种方式也是一个常见的 <code>POST</code> 提交方式，通常表单上传文件时使用该种方式。</p><p><strong>application&#x2F;json:</strong></p><p>告诉服务器消息主体是序列化后的 <code>JSON</code> 字符串。</p><p><strong>text&#x2F;xml:</strong></p><p>该种方式主要用来提交 <code>XML</code> 格式的数据。</p><p>详细资料可以参考：<a href="https://honglu.me/2015/07/13/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8DContent-Type/">《常用的几种 Content-Type》</a></p><h4 id="158-如何封装一个-javascript-的类型判断函数？"><a href="#158-如何封装一个-javascript-的类型判断函数？" class="headerlink" title="158. 如何封装一个 javascript 的类型判断函数？"></a>158. 如何封装一个 javascript 的类型判断函数？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;---------------- 定义检测数据类型的方法 ------------------------&#x27;</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkoutType</span>(<span class="hljs-params">target</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(target).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://github.com/mqyqingfeng/Blog/issues/28">《JavaScript 专题之类型判断(上)》</a></p><h4 id="159-如何判断一个对象是否为空对象？"><a href="#159-如何判断一个对象是否为空对象？" class="headerlink" title="159. 如何判断一个对象是否为空对象？"></a>159. 如何判断一个对象是否为空对象？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkNullObj</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-property">length</span> === <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://blog.csdn.net/FungLeo/article/details/78113661">《js 判断一个 object 对象是否为空》</a></p><h4 id="160-使用闭包实现每隔一秒打印-1-2-3-4"><a href="#160-使用闭包实现每隔一秒打印-1-2-3-4" class="headerlink" title="160. 使用闭包实现每隔一秒打印 1,2,3,4"></a>160. 使用闭包实现每隔一秒打印 1,2,3,4</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用闭包实现</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;, i * <span class="hljs-number">1000</span>);<br>  &#125;)(i);<br>&#125;<br><br><span class="hljs-comment">// 使用 let 块级作用域</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;, i * <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="161-手写一个-jsonp"><a href="#161-手写一个-jsonp" class="headerlink" title="161. 手写一个 jsonp"></a>161. 手写一个 jsonp</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp</span>(<span class="hljs-params">url, params, callback</span>) &#123;<br>  <span class="hljs-comment">// 判断是否含有参数</span><br>  <span class="hljs-keyword">let</span> queryString = url.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;?&quot;</span>) === <span class="hljs-string">&quot;-1&quot;</span> ? <span class="hljs-string">&quot;?&quot;</span> : <span class="hljs-string">&quot;&amp;&quot;</span>;<br><br>  <span class="hljs-comment">// 添加参数</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> params) &#123;<br>    <span class="hljs-keyword">if</span> (params.<span class="hljs-title function_">hasOwnProperty</span>(k)) &#123;<br>      queryString += k + <span class="hljs-string">&quot;=&quot;</span> + params[k] + <span class="hljs-string">&quot;&amp;&quot;</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 处理回调函数名</span><br>  <span class="hljs-keyword">let</span> random = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()<br>      .<span class="hljs-title function_">toString</span>()<br>      .<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>),<br>    callbackName = <span class="hljs-string">&quot;myJsonp&quot;</span> + random;<br><br>  <span class="hljs-comment">// 添加回调函数</span><br>  queryString += <span class="hljs-string">&quot;callback=&quot;</span> + callbackName;<br><br>  <span class="hljs-comment">// 构建请求</span><br>  <span class="hljs-keyword">let</span> scriptNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;script&quot;</span>);<br>  scriptNode.<span class="hljs-property">src</span> = url + queryString;<br><br>  <span class="hljs-variable language_">window</span>[callbackName] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 调用回调函数</span><br>    <span class="hljs-title function_">callback</span>(...<span class="hljs-variable language_">arguments</span>);<br><br>    <span class="hljs-comment">// 删除这个引入的脚本</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;head&quot;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">removeChild</span>(scriptNode);<br>  &#125;;<br><br>  <span class="hljs-comment">// 发起请求</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;head&quot;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">appendChild</span>(scriptNode);<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br>  <a href="https://www.cnblogs.com/zzc5464/p/jsonp.html">《原生 jsonp 具体实现》</a><br>  <a href="https://segmentfault.com/a/1190000007665361#articleHeader1">《jsonp 的原理与实现》</a></p><h4 id="162-手写一个观察者模式？"><a href="#162-手写一个观察者模式？" class="headerlink" title="162. 手写一个观察者模式？"></a>162. 手写一个观察者模式？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> events = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> topics = &#123;&#125;;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-comment">// 注册监听函数</span><br>    <span class="hljs-attr">subscribe</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">topic, handler</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!topics.<span class="hljs-title function_">hasOwnProperty</span>(topic)) &#123;<br>        topics[topic] = [];<br>      &#125;<br>      topics[topic].<span class="hljs-title function_">push</span>(handler);<br>    &#125;,<br><br>    <span class="hljs-comment">// 发布事件，触发观察者回调事件</span><br>    <span class="hljs-attr">publish</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">topic, info</span>) &#123;<br>      <span class="hljs-keyword">if</span> (topics.<span class="hljs-title function_">hasOwnProperty</span>(topic)) &#123;<br>        topics[topic].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">handler</span>) &#123;<br>          <span class="hljs-title function_">handler</span>(info);<br>        &#125;);<br>      &#125;<br>    &#125;,<br><br>    <span class="hljs-comment">// 移除主题的一个观察者的回调事件</span><br>    <span class="hljs-attr">remove</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">topic, handler</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!topics.<span class="hljs-title function_">hasOwnProperty</span>(topic)) <span class="hljs-keyword">return</span>;<br><br>      <span class="hljs-keyword">var</span> handlerIndex = -<span class="hljs-number">1</span>;<br>      topics[topic].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>) &#123;<br>        <span class="hljs-keyword">if</span> (item === handler) &#123;<br>          handlerIndex = index;<br>        &#125;<br>      &#125;);<br><br>      <span class="hljs-keyword">if</span> (handlerIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>        topics[topic].<span class="hljs-title function_">splice</span>(handlerIndex, <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;,<br><br>    <span class="hljs-comment">// 移除主题的所有观察者的回调事件</span><br>    <span class="hljs-attr">removeAll</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">topic</span>) &#123;<br>      <span class="hljs-keyword">if</span> (topics.<span class="hljs-title function_">hasOwnProperty</span>(topic)) &#123;<br>        topics[topic] = [];<br>      &#125;<br>    &#125;<br>  &#125;;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://segmentfault.com/a/1190000006934031#articleHeader1">《JS 事件模型》</a></p><h4 id="163-EventEmitter-实现"><a href="#163-EventEmitter-实现" class="headerlink" title="163. EventEmitter 实现"></a>163. EventEmitter 实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventEmitter</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = &#123;&#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">on</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">let</span> callbacks = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] || [];<br>    callbacks.<span class="hljs-title function_">push</span>(callback);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = callbacks;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">off</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">let</span> callbacks = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event];<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = callbacks &amp;&amp; callbacks.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn !== callback);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">emit</span>(<span class="hljs-params">event, ...args</span>) &#123;<br>    <span class="hljs-keyword">let</span> callbacks = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event];<br>    callbacks.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">fn</span>(...args);<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">once</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">let</span> wrapFun = <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br>      <span class="hljs-title function_">callback</span>(...args);<br><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">off</span>(event, wrapFun);<br>    &#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(event, wrapFun);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="164-一道常被人轻视的前端-JS-面试题"><a href="#164-一道常被人轻视的前端-JS-面试题" class="headerlink" title="164. 一道常被人轻视的前端 JS 面试题"></a>164. 一道常被人轻视的前端 JS 面试题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;<br>  getName = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;<br><span class="hljs-title class_">Foo</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-number">2</span>);<br>&#125;;<br><span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-number">3</span>);<br>&#125;;<br><span class="hljs-keyword">var</span> getName = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-number">4</span>);<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-number">5</span>);<br>&#125;<br><br><span class="hljs-comment">//请写出以下输出结果：</span><br><span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 2</span><br><span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 4</span><br><span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 1</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 2</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>(); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br>  <a href="https://github.com/Wscats/Good-text-Share/issues/85">《前端程序员经常忽视的一个 JavaScript 面试题》</a><br>  <a href="https://segmentfault.com/q/1010000008430170">《一道考察运算符优先级的 JavaScript 面试题》</a><br>  <a href="https://www.cnblogs.com/xxcanghai/p/5189353.html">《一道常被人轻视的前端 JS 面试题》</a></p><h4 id="165-如何确定页面的可用性时间，什么是-Performance-API？"><a href="#165-如何确定页面的可用性时间，什么是-Performance-API？" class="headerlink" title="165. 如何确定页面的可用性时间，什么是 Performance API？"></a>165. 如何确定页面的可用性时间，什么是 Performance API？</h4><p><code>Performance API</code> 用于精确度量、控制、增强浏览器的性能表现。这个 <code>API</code> 为测量网站性能，提供以前没有办法做到的精度。</p><p>&nbsp;&nbsp;使用 <code>getTime</code> 来计算脚本耗时的缺点，首先，<code>getTime</code>方法（以及 <code>Date</code> 对象的其他方法）都只能精确到毫秒级别（一秒的千分之一），想要得到更小的时间差别就无能为力了。其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。</p><p>&nbsp;&nbsp;为了解决这两个不足之处，<code>ECMAScript 5</code>引入“高精度时间戳”这个 <code>API</code>，部署在 <code>performance</code> 对象上。它的精度可以达到1毫秒<br>的千分之一（1秒的百万分之一）。</p><p><strong>navigationStart：</strong> 当前浏览器窗口的前一个网页关闭，发生 <code>unload</code> 事件时的 <code>Unix</code> 毫秒时间戳。如果没有前一个网页，则等于 <code>fetchStart</code> 属性。</p><p><strong>loadEventEnd：</strong> 返回当前网页 <code>load</code> 事件的回调函数运行结束时的 <code>Unix</code> 毫秒时间戳。如果该事件还没有发生，返回 0。</p><p><strong>根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> t = performance.<span class="hljs-property">timing</span>;<br><span class="hljs-keyword">var</span> pageLoadTime = t.<span class="hljs-property">loadEventEnd</span> - t.<span class="hljs-property">navigationStart</span>;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="http://javascript.ruanyifeng.com/bom/performance.html">《Performance API》</a></p><h4 id="166-js-中的命名规则"><a href="#166-js-中的命名规则" class="headerlink" title="166. js 中的命名规则"></a>166. js 中的命名规则</h4><ol><li>第一个字符必须是字母、下划线（_）或美元符号（$）</li><li>余下的字符可以是下划线、美元符号或任何字母或数字字符</li></ol><p>一般我们推荐使用小驼峰法来对变量名进行命名，因为这样可以与 ECMAScript 内置的函数和对象命名格式保持一致。</p><p>详细资料可以参考：<a href="http://www.w3school.com.cn/js/pro_js_variables.asp">《ECMAScript 变量》</a></p><h4 id="167-js-语句末尾分号是否可以省略？"><a href="#167-js-语句末尾分号是否可以省略？" class="headerlink" title="167. js 语句末尾分号是否可以省略？"></a>167. js 语句末尾分号是否可以省略？</h4><p>&nbsp;&nbsp;在 ECMAScript 规范中，语句结尾的分号并不是必需的。但是我们一般最好不要省略分号，因为加上分号一方面有利于我们代码的可维护性，另一方面也可以避免我们在对代码进行压缩时出现错误。</p><h4 id="168-Object-assign"><a href="#168-Object-assign" class="headerlink" title="168. Object.assign()"></a>168. Object.assign()</h4><p><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><h4 id="169-Math-ceil-和-Math-floor"><a href="#169-Math-ceil-和-Math-floor" class="headerlink" title="169. Math.ceil 和 Math.floor"></a>169. Math.ceil 和 Math.floor</h4><p><code>Math.ceil()</code> &#x3D;&#x3D;&#x3D; 向上取整，函数返回一个大于或等于给定数字的最小整数。</p><p><code>Math.floor()</code> &#x3D;&#x3D;&#x3D; 向下取整，函数返回一个小于或等于给定数字的最大整数。</p><h4 id="170-js-for-循环注意点"><a href="#170-js-for-循环注意点" class="headerlink" title="170. js for 循环注意点"></a>170. js for 循环注意点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>, j &lt; <span class="hljs-number">9</span>; i++, j++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i, j);<br>&#125;<br><br><span class="hljs-comment">// 当判断语句含有多个语句时，以最后一个判断语句的值为准，因此上面的代码会执行 10 次。</span><br><span class="hljs-comment">// 当判断语句为空时，循环会一直进行。</span><br></code></pre></td></tr></table></figure><h4 id="171-一个列表，假设有-100000-个数据，这个该怎么办？"><a href="#171-一个列表，假设有-100000-个数据，这个该怎么办？" class="headerlink" title="171. 一个列表，假设有 100000 个数据，这个该怎么办？"></a>171. 一个列表，假设有 100000 个数据，这个该怎么办？</h4><p><strong>我们需要思考的问题：该处理是否必须同步完成？数据是否必须按顺序完成？</strong></p><p><strong>解决办法：</strong></p><ol><li><p>将数据分页，利用分页的原理，每次服务器端只返回一定数目的数据，浏览器每次只对一部分进行加载。</p></li><li><p>使用懒加载的方法，每次加载一部分数据，其余数据当需要使用时再去加载。</p></li><li><p>使用数组分块技术，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。</p></li></ol><h4 id="172-js-中倒计时的纠偏实现？"><a href="#172-js-中倒计时的纠偏实现？" class="headerlink" title="172. js 中倒计时的纠偏实现？"></a>172. js 中倒计时的纠偏实现？</h4><p>&nbsp;&nbsp;在前端实现中我们一般通过 <code>setTimeout</code> 和 <code>setInterval</code> 方法来实现一个倒计时效果。但是使用这些方法会存在时间偏差的问题，这是由于 <code>js</code> 的程序执行机制造成的，<code>setTimeout</code> 和 <code>setInterval</code> 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会等到当前执行栈为空的时候再取出事件执行，因此事件等待执行的时间就是造成误差的原因。</p><p><strong>一般解决倒计时中的误差的有这样两种办法：</strong></p><ol><li><p>第一种是通过前端定时向服务器发送请求获取最新的时间差，以此来校准倒计时时间。</p></li><li><p>第二种方法是前端根据偏差时间来自动调整间隔时间的方式来实现的。这一种方式首先是以 setTimeout 递归的方式来实现倒计时，然后通过一个变量来记录已经倒计时的秒数。每一次函数调用的时候，首先将变量加一，然后根据这个变量和每次的间隔时间，我们就可以计算出此时无偏差时应该显示的时间。然后将当前的真实时间与这个时间相减，这样我们就可以得到时间的偏差大小，因此我们在设置下一个定时器的间隔大小的时候，我们就从间隔时间中减去这个偏差大小，以此来实现由于程序执行所造成的时间误差的纠正。</p></li></ol><p>详细资料可以参考：<a href="https://juejin.im/post/5badf8305188255c8e728adc">《JavaScript 前端倒计时纠偏实现》</a></p><h4 id="173-进程间通信的方式？"><a href="#173-进程间通信的方式？" class="headerlink" title="173. 进程间通信的方式？"></a>173. 进程间通信的方式？</h4><ul><li>1.管道通信</li><li>2.消息队列通信</li><li>3.信号量通信</li><li>4.信号通信</li><li>5.共享内存通信</li><li>6.套接字通信</li></ul><p>详细资料可以参考：<br>  <a href="https://blog.csdn.net/violet_echo_0908/article/details/51201278">《进程间 8 种通信方式详解》</a><br>  <a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">《进程与线程的一个简单解释》</a></p><h4 id="174-如何查找一篇英文文章中出现频率最高的单词？"><a href="#174-如何查找一篇英文文章中出现频率最高的单词？" class="headerlink" title="174. 如何查找一篇英文文章中出现频率最高的单词？"></a>174. 如何查找一篇英文文章中出现频率最高的单词？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMostWord</span>(<span class="hljs-params">article</span>) &#123;<br>  <span class="hljs-comment">// 合法性判断</span><br>  <span class="hljs-keyword">if</span> (!article) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// 参数处理</span><br>  article = article.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">toLowerCase</span>();<br><br>  <span class="hljs-keyword">let</span> wordList = article.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/[a-z]+/g</span>),<br>    visited = [],<br>    maxNum = <span class="hljs-number">0</span>,<br>    maxWord = <span class="hljs-string">&quot;&quot;</span>;<br><br>  article = <span class="hljs-string">&quot; &quot;</span> + wordList.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;  &quot;</span>) + <span class="hljs-string">&quot; &quot;</span>;<br><br>  <span class="hljs-comment">// 遍历判断单词出现次数</span><br>  wordList.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;<br>    <span class="hljs-keyword">if</span> (visited.<span class="hljs-title function_">indexOf</span>(item) &lt; <span class="hljs-number">0</span>) &#123;<br><br>      <span class="hljs-comment">// 加入 visited </span><br>      visited.<span class="hljs-title function_">push</span>(item);<br><br>      <span class="hljs-keyword">let</span> word = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&quot; &quot;</span> + item + <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;g&quot;</span>),<br>        num = article.<span class="hljs-title function_">match</span>(word).<span class="hljs-property">length</span>;<br><br>      <span class="hljs-keyword">if</span> (num &gt; maxNum) &#123;<br>        maxNum = num;<br>        maxWord = item;<br>      &#125;<br>    &#125;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> maxWord + <span class="hljs-string">&quot;  &quot;</span> + maxNum;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
      <tag>动态语言特性</tag>
      
      <tag>现代Web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS总结</title>
    <link href="/2023/12/18/CSS%E6%80%BB%E7%BB%93/"/>
    <url>/2023/12/18/CSS%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4 id="1-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？"><a href="#1-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？" class="headerlink" title="1. 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？"></a>1. 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</h4><ol><li>有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）</li><li>盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分</li></ol><p>IE盒模型和W3C标准盒模型的区别：</p><ol><li>W3C标准盒模型：属性width，height只包含内容content，不包含border和padding</li><li>IE盒模型：属性width，height包含content、border和padding，指的是content<br>+padding+border。</li></ol><p>&nbsp;&nbsp;在ie8+浏览器中使用哪个盒模型可以由box-sizing（CSS新增的属性）控制，默认值为content-box，即标准盒模型；如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6，7，8中DOCTYPE缺失会将盒子模型解释为IE盒子模型。若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。</p><p>回答：</p><p>&nbsp;&nbsp;盒模型都是由四个部分组成的，分别是margin、border、padding和content。<br>&nbsp;&nbsp;标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content。<br>&nbsp;&nbsp;一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。</p><h4 id="2-CSS-选择器有哪些？"><a href="#2-CSS-选择器有哪些？" class="headerlink" title="2. CSS 选择器有哪些？"></a>2. CSS 选择器有哪些？</h4><ol><li>id选择器(#myid)</li><li>类选择器(.myclassname)</li><li>标签选择器(div,h1,p)</li><li>后代选择器(h1,p)</li><li>子选择器(ul&gt;li)</li><li>兄弟选择器(所有)(li~a)</li><li>相邻兄弟选择器(li+a)</li><li>属性选择器(a[rel&#x3D;”external”])</li><li>伪类选择器(a:hover,li:nth-child)</li><li>伪元素选择器(::before、::after)</li><li>通配符选择器(*)</li></ol><h4 id="3-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用"><a href="#3-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用" class="headerlink" title="3. ::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用"></a>3. ::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用</h4><p>相关知识点：</p><ul><li>单冒号 (:) 用于CSS3伪类，双冒号 (::) 用于CSS3伪元素。(伪元素由双冒号和伪元素名称组成)</li><li>双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。</li><li>想让插入的内容出现在其它内容前，使用::before，否者，使用::after；</li><li>在代码顺序上，::after生成的内容也比::before生成的内容靠后。如果按堆栈视角，::after生成的内容会在::before生成的内容之上。</li></ul><p>回答：<br>&nbsp;&nbsp;在css3中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号来表示伪元素。<br>&nbsp;&nbsp;伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等。</p><h4 id="4-伪类与伪元素的区别"><a href="#4-伪类与伪元素的区别" class="headerlink" title="4. 伪类与伪元素的区别"></a>4. 伪类与伪元素的区别</h4><p>&nbsp;&nbsp;css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。</p><p>&nbsp;&nbsp;伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。</p><p>&nbsp;&nbsp;伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</p><p>&nbsp;&nbsp;有时你会发现伪元素使用了两个冒号（::）而不是一个冒号（:）。这是CSS3的一部分，并尝试区分伪类和伪元素。大多数浏览器都支持这两个值。按照规则应该使用（::）而不是（:），从而区分伪类和伪元素。但是，由于在旧版本的W3C规范并未对此进行特别区分，因此目前绝大多数的浏览器都支持使用这两种方式表示伪元素。</p><h4 id="5-CSS-中哪些属性可以继承？"><a href="#5-CSS-中哪些属性可以继承？" class="headerlink" title="5. CSS 中哪些属性可以继承？"></a>5. CSS 中哪些属性可以继承？</h4><p>相关资料：</p><ul><li>每个CSS属性定义的概述都指出了这个属性是默认继承的，还是默认不继承的。这决定了当你没有为元素的属性指定值时该如何计算值。</li><li>当元素的一个继承属性没有指定值时，则取父元素的同属性的计算值。只有文档根元素取该属性的概述中给定的初始值（这里的意思应该是在该属性本身的定义中的默认值）。</li><li>当元素的一个非继承属性（在Mozilla code里有时称之为reset property）没有指定值时，则取属性的初始值initial value（该值在该属性的概述里被指定）。</li></ul><p>有继承性的属性：</p><ul><li>字体系列属性font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust</li><li>文本系列属性text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、<br>text-transform、direction、color</li><li>表格布局属性caption-side border-collapse empty-cells</li><li>列表属性list-style-type、list-style-image、list-style-position、list-style</li><li>光标属性cursor</li><li>元素可见性visibility</li><li>还有一些不常用的；speak，page，设置嵌套引用的引号类型quotes等属性</li></ul><p>注意：当一个属性不是继承属性时，可以使用inherit关键字指定一个属性应从父元素继承它的值，inherit关键字用于显式地指定继承性，可用于任何继承性&#x2F;非继承性属性。</p><p>回答：<br>&nbsp;&nbsp;每一个属性在定义中都给出了这个属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，会使用父元素的同属性的值来作为自己的值。</p><p>&nbsp;&nbsp;一般具有继承性的属性有，字体相关的属性，font-size和font-weight等。文本相关的属性，color和text-align等。表格的一些布局属性、列表属性如list-style等。还有光标属性cursor、元素可见性visibility。</p><p>&nbsp;&nbsp;当一个属性不是继承属性的时候，我们也可以通过将它的值设置为inherit来使它从父元素那获取同名的属性值来继承。</p><h4 id="6-CSS-优先级算法如何计算？"><a href="#6-CSS-优先级算法如何计算？" class="headerlink" title="6. CSS 优先级算法如何计算？"></a>6. CSS 优先级算法如何计算？</h4><p>相关知识点：</p><p>CSS的优先级是根据样式声明的特殊性值来判断的。<br>选择器的特殊性值分为四个等级，如下：</p><ol><li>内联样式选择器x,0,0,0</li><li>ID选择器0,x,0,0</li><li>class选择器&#x2F;属性选择器&#x2F;伪类选择器0,0,x,0</li><li>元素和伪元素选择器0,0,0,x</li></ol><p>计算方法：</p><ol><li>每个等级的初始值为0</li><li>每个等级的叠加为选择器出现的次数相加</li><li>不可进位，比如0,99,99,99</li><li>依次表示为：0,0,0,0</li><li>每个等级计数之间没关联</li><li>等级判断从左向右，如果某一位数值相同，则判断下一位数值</li><li>如果两个优先级相同，则最后出现的优先级高，!important也适用</li><li>通配符选择器的特殊性值为：0,0,0,0</li><li>继承样式优先级最低，通配符样式优先级高于继承样式</li><li>!important（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0。</li></ol><p>计算实例：</p><ol><li>#demo a{color: orange;}&#x2F;<em>特殊性值：0,1,0,1</em>&#x2F;</li><li>div#demo a{color: red;}&#x2F;<em>特殊性值：0,1,0,2</em>&#x2F;</li></ol><p>注意：</p><ol><li>样式应用时，css会先查看规则的权重（!important），加了权重的优先级最高，当权重相同的时候，会比较规则的特殊性。</li><li>特殊性值越大的声明优先级越高。</li><li>相同特殊性值的声明，根据样式引入的顺序，后声明的规则优先级高（距离元素出现最近的）</li><li>部分浏览器由于字节溢出问题出现的进位表现不做考虑</li></ol><p>回答：<br>&nbsp;&nbsp;判断优先级时，首先我们会判断一条属性声明是否有权重，也就是是否在声明后面加上了!important。一条声明如果加上了权重，那么它的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的特殊性。</p><p>&nbsp;&nbsp;一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。选择器的特殊性可以分为四个等级，第一个等级是行内样式，为1000，第二个等级是id选择器，为0100，第三个等级是类选择器、伪类选择器和属性选择器，为0010，第四个等级是元素选择器和伪元素选择器，为0001。规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊性值比所有以0开头的特殊性值要大。比如说特殊性值为1000的的规则优先级就要比特殊性值为0999的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引入的顺序，后出现的规则的优先级最高。</p><h4 id="7-关于伪类-LVHA-的解释"><a href="#7-关于伪类-LVHA-的解释" class="headerlink" title="7. 关于伪类 LVHA 的解释?"></a>7. 关于伪类 LVHA 的解释?</h4><p>&nbsp;&nbsp;a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active；</p><p>当链接未访问过时：</p><ol><li>当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪类后面声明；</li><li>当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），必须将:active声明放到:link和:hover之后。因此得出LVHA这个顺序。<br>&nbsp;&nbsp;当链接访问过时，情况基本同上，只不过需要将:link换成:visited。<br>&nbsp;&nbsp;这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖的问题。</li></ol><h4 id="8-CSS3-新增伪类有那些？"><a href="#8-CSS3-新增伪类有那些？" class="headerlink" title="8. CSS3 新增伪类有那些？"></a>8. CSS3 新增伪类有那些？</h4><ol><li>elem:nth-child(n)选中父元素下的第n个子元素，并且这个子元素的标签名为elem，n可以接受具体的数值，也可以接受函数。</li><li>elem:nth-last-child(n)作用同上，不过是从后开始查找。</li><li>elem:last-child选中最后一个子元素。</li><li>elem:only-child如果elem是父元素下唯一的子元素，则选中之。</li><li>elem:nth-of-type(n)选中父元素下第n个elem类型元素，n可以接受具体的数值，也可以接受函数。</li><li>elem:first-of-type选中父元素下第一个elem类型元素。\</li><li>elem:last-of-type选中父元素下最后一个elem类型元素。</li><li>elem:only-of-type如果父元素下的子元素只有一个elem类型元素，则选中该元素。</li><li>elem:empty选中不包含子元素和内容的elem类型元素。</li><li>elem:target选择当前活动的elem元素。</li><li>:not(elem)选择非elem元素的每个元素。</li><li>:enabled 控制表单控件的禁用状态。</li><li>:disabled控制表单控件的禁用状态。</li><li>:checked单选框或复选框被选中。</li></ol><h4 id="9-如何居中-div？"><a href="#9-如何居中-div？" class="headerlink" title="9. 如何居中 div？"></a>9. 如何居中 div？</h4><ul><li>水平居中：给 div 设置一个宽度，然后添加 margin:0 auto 属性<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>水平居中，利用 text-align:center 实现<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>让绝对定位的 div 居中<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">margin</span>: auto;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>水平垂直居中一<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*确定容器的宽高宽500高300的层设置层的外边距div&#123;*/</span><br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<span class="hljs-comment">/*绝对定位*/</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">margin</span>: -<span class="hljs-number">150px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> -<span class="hljs-number">250px</span>;<span class="hljs-comment">/*外边距为自身宽高的一半*/</span><br>  <span class="hljs-attribute">background-color</span>: pink;<span class="hljs-comment">/*方便看效果*/</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>水平垂直居中二<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*未知容器的宽高，利用`transform`属性*/</span><br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute; <span class="hljs-comment">/*相对定位或绝对定位均可*/</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>  <span class="hljs-attribute">background-color</span>: pink; <span class="hljs-comment">/*方便看效果*/</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>水平垂直居中三<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*利用flex布局实际使用时应考虑兼容性*/</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: center; <span class="hljs-comment">/*垂直居中*/</span><br>  <span class="hljs-attribute">justify-content</span>: center; <span class="hljs-comment">/*水平居中*/</span><br>&#125;<br><span class="hljs-selector-class">.containerdiv</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink; <span class="hljs-comment">/*方便看效果*/</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>水平垂直居中四<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*利用text-align:center和vertical-align:middle属性*/</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">position</span>: fixed;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>);<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br><br><span class="hljs-selector-class">.container</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">vertical-align</span>: middle;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">white-space</span>: normal;<br>  <span class="hljs-attribute">vertical-align</span>: middle;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>回答：</p><ul><li>对于宽高固定的元素<ol><li>我们可以利用margin:0 auto来实现元素的水平居中。</li><li>利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。</li><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素<br>的中心点到页面的中心。</li><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素<br>的中心点到页面的中心。</li><li>使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对<br>齐，然后它的子元素也可以实现垂直和水平的居中。<br>&nbsp;&nbsp;对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。</li></ol></li></ul><h4 id="10-display-有哪些值？说明他们的作用。"><a href="#10-display-有哪些值？说明他们的作用。" class="headerlink" title="10. display 有哪些值？说明他们的作用。"></a>10. display 有哪些值？说明他们的作用。</h4><ul><li>block块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</li><li>none元素不显示，并从文档流中移除。</li><li>inline行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</li><li>inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。</li><li>list-item像块类型元素一样显示，并添加样式列表标记。</li><li>table此元素会作为块级表格来显示。</li><li>inherit规定应该从父元素继承display属性的值。</li></ul><h4 id="11-position-的值-relative-和-absolute-定位原点是？"><a href="#11-position-的值-relative-和-absolute-定位原点是？" class="headerlink" title="11. position 的值 relative 和 absolute 定位原点是？"></a>11. position 的值 relative 和 absolute 定位原点是？</h4><p>相关知识点：</p><ul><li>absolute 生成绝对定位的元素，相对于值不为static的第一个父元素的padding box进行定位，也可以理解为离自己这一级元素最近的一级position设置为absolute或者relative的父元素的padding box的左上角为原点的。</li><li>fixed（老IE不支持）生成固定定位的元素，相对于浏览器窗口进行定位。</li><li>relative 生成相对定位的元素，相对于其元素本身所在文档流中的位置进行定位。</li><li>static 默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right,z-index声明）。</li><li>inherit 规定从父元素继承position属性的值。</li></ul><p>回答：</p><p>&nbsp;&nbsp;relative 定位的元素，是相对于元素本身所在文档流中的位置进行定位的。<br>&nbsp;&nbsp;absolute 定位的元素，是相对于它的第一个position值不为static的祖先元素的padding box来进行定位的。这句话我们可以这样来理解，我们首先需要找到绝对定位元素的一个position的值不为static的祖先元素，然后相对于这个祖先元素的padding box来定位，也就是说在计算定位距离的时候，padding的值也要算进去。</p><h4 id="12-CSS3-有哪些新特性？（根据项目回答）"><a href="#12-CSS3-有哪些新特性？（根据项目回答）" class="headerlink" title="12. CSS3 有哪些新特性？（根据项目回答）"></a>12. CSS3 有哪些新特性？（根据项目回答）</h4><ul><li>新增各种CSS选择器(:not(.input)：所有class不是“input”的节点)</li><li>圆角 (border-radius:8px)</li><li>多列布局 (multi-column layout)</li><li>阴影和反射 (Shadow\Reflect)</li><li>文字特效 (text-shadow)</li><li>文本修饰 (Text-decoration)</li><li>线性渐变   (linear-gradient)</li><li>旋转 (transform：rotate) 缩放，平移，倾斜，动画，多背景<br>例如：transform:\scale(0.85,0.90)\translate(0px,-30px)\skew(-9deg,0deg)\Animation:</li></ul><h4 id="13-请解释一下-CSS3-的-Flex-box（弹性盒布局模型），以及适用场景？"><a href="#13-请解释一下-CSS3-的-Flex-box（弹性盒布局模型），以及适用场景？" class="headerlink" title="13. 请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？"></a>13. 请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？</h4><p>相关知识点：<br>&nbsp;&nbsp;Flex是FlexibleBox的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>&nbsp;&nbsp;任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。<br>&nbsp;&nbsp;采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex元素（flex item），简称”元素”。<br>&nbsp;&nbsp;容器默认存在两根轴：水平的主轴（main axis）和垂直的辅轴（cross axis），元素默认沿主轴排列。</p><p>以下6个属性设置在容器上:</p><ol><li>flex-direction属性决定主轴的方向（即元素的排列方向）。</li><li>flex-wrap属性定义，如果一条轴线排不下，如何换行。</li><li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</li><li>justify-content属性定义了元素在主轴上的对齐方式。 可选值：flex-start, flex-end, center, space-around,space-between, stretch</li><li>align-items属性定义元素在辅轴上如何对齐。 可选值：flex-start, flex-end, center， stretch</li><li>align-content属性定义了多根轴线的对齐方式。如果元素只有一根轴线，该属性不起作用。</li></ol><p>以下6个属性设置在元素上:</p><ol><li>order属性定义元素的排列顺序。数值越小，排列越靠前，默认为0</li><li>flex-grow属性定义元素的增长系数，默认为0，即如果存在剩余空间，也不放大。</li><li>flex-shrink属性定义了项目的缩减系数，默认为1，即如果空间不足，该项目将缩小。</li><li>flex-basis属性定义了在分配多余空间之前，元素占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li><li>flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li><li>align-self属性允许单个元素有与其他元素不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父<br>元素的align-items属性，如果没有父元素，则等同于stretch。</li></ol><p>回答：</p><p>&nbsp;&nbsp;flex布局是CSS3新增的一种布局方式，我们可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的弹性元素。</p><p>&nbsp;&nbsp;一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的辅轴。我们可以使用flex-direction来指定主轴的方向。我们可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在辅轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。</p><p>&nbsp;&nbsp;对于容器中的弹性元素，我们可以使用order属性来指定元素的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，元素的增长系数。还可以使用flex-shrink来指定当排列空间不足时，元素的缩减系数。</p><h4 id="14-用纯-CSS-创建一个三角形的原理是什么？"><a href="#14-用纯-CSS-创建一个三角形的原理是什么？" class="headerlink" title="14. 用纯 CSS 创建一个三角形的原理是什么？"></a>14. 用纯 CSS 创建一个三角形的原理是什么？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  采用的是相邻边框连接处的均分原理。</span><br><span class="hljs-comment">  将元素的宽高设为0，只设置border，把任意三条边隐藏掉（颜色设为transparent），剩下的就是一个三角形。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-selector-id">#demo</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">border-width</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">border-style</span>: solid;<br>  <span class="hljs-attribute">border-color</span>: transparent transparent red transparent;<br>  <span class="hljs-attribute">border-top</span>: none;   <span class="hljs-comment">/*加上这一行可以让三角形顶格， 不加三角形会下移20px*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="15-一个满屏品字布局如何设计"><a href="#15-一个满屏品字布局如何设计" class="headerlink" title="15.一个满屏品字布局如何设计?"></a>15.一个满屏品字布局如何设计?</h4><p>简单的方式:<br>  上面div宽度为100%<br>  下面两个div宽度为50%<br>  然后用float或者inline使其不换行即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  *&#123;    <span class="hljs-comment">/* 去除所有元素默认的内外边距的值 */</span></span><br><span class="language-css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span>&#123;   <span class="hljs-comment">/* 默认HTML，body的高度为0，为其设置高度以使后面的div可以用百分比设置高度 */</span></span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  </span><br><span class="language-css">  <span class="hljs-selector-class">.header</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: orange;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.main</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.main</span> <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.main</span> <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="16-CSS-多列等高如何实现？"><a href="#16-CSS-多列等高如何实现？" class="headerlink" title="16.CSS 多列等高如何实现？"></a>16.CSS 多列等高如何实现？</h4><ol><li><p>利用padding-bottom|margin-bottom正负值相抵，不会影响页面布局的特点。设置父容器超出隐藏（overflow:hidden），这样父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。</p></li><li><p>利用table-cell所有单元格高度都相等的特性，来实现多列等高。</p></li><li><p>利用flex布局中弹性元素align-items属性默认为stretch，如果弹性元素未设置高度或设为auto，将占满整个容器的高度<br>的特性，来实现多列等高。</p></li></ol><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b0fb34151882515662238fd">《前端应该掌握的 CSS 实现多列等高布局》</a><br><a href="https://codepen.io/yangbo5207/post/equh">《CSS：多列等高布局》</a></p><h4 id="17-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用-hack-的技巧？"><a href="#17-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用-hack-的技巧？" class="headerlink" title="17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？"></a>17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？</h4><ol><li><p>png24位的图片在iE6浏览器上出现背景<br>解决方案：做成PNG8，也可以引用一段脚本处理。</p></li><li><p>浏览器默认的margin和padding不同<br>解决方案：加一个全局的*{margin:0;padding:0;}来统一。</p></li><li><p>IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。<br>#box{float:left;width:10px;margin:0 0 0 10px;} 这种情况之下IE会产生20px的距离<br>解决方案：在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</p></li><li><p>渐进识别的方式，从总体中逐渐排除局部。<br>解决方案: 首先，巧妙的使用”\9”这一标记，将IE浏览器从所有情况中分离出来。<br>     接着，再次使用”+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。<br>     .bb{<br>       background-color:#f1ee18;&#x2F;<em>所有识别</em>&#x2F;<br>       background-color:#00deff\9;&#x2F;<em>IE6、7、8识别</em>&#x2F;<br>       +background-color:#a200ff;&#x2F;<em>IE6、7识别</em>&#x2F;<br>       _background-color:#1e0bd1;&#x2F;<em>IE6识别</em>&#x2F;<br>     }</p></li><li><p>IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性<br>解决方法：统一通过getAttribute()获取自定义属性。</p></li><li><p>IE下，event对象有x、y属性，但是没有pageX、pageY属性;Firefox下，event对象有pageX、pageY属性，但是没有x、y属性。<br>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p></li><li><p>Chrome中文界面下默认会将小于12px的文本强制按照12px显示</p><ul><li>可通过加入CSS属性-webkit-text-size-adjust:none;解决。但是，在chrome更新到27版本之后就不可以用了。</li><li>还可以使用-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);收缩的是整个span的大小，这时候，必须要将span转换成块元素，可以使用display：block&#x2F;inline-block&#x2F;…；</li></ul></li><li><p>超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了<br>解决方法：改变CSS属性的排列顺序L-V-H-A</p></li><li><p>怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好 养成书写DTD声明的好习惯。</p></li></ol><h4 id="18-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#18-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="18.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>18.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h4><p>  浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个<code>&lt;li&gt;</code>放在一行，这导致<code>&lt;li&gt;</code>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。<br>  解决办法：</p><ol><li>为<code>&lt;li&gt;</code>设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</li><li>将所有<code>&lt;li&gt;</code>写在同一行。不足：代码不美观。</li><li>将<code>&lt;ul&gt;</code>内的字符尺寸直接设为0，即font-size:0。不足：<code>&lt;ul&gt;</code>中的其他字符尺寸也被设为0，需要额外重新设定其他<br>字符尺寸，且在Safari浏览器依然会出现空白间隔。</li><li>消除<code>&lt;ul&gt;</code>的字符间隔letter-spacing:-8px，不足：这也设置了<code>&lt;li&gt;</code>内的字符间隔，因此需要将<code>&lt;li&gt;</code>内的字符<br>间隔设为默认letter-spacing:normal。</li></ol><h4 id="19-为什么要初始化-CSS-样式？"><a href="#19-为什么要初始化-CSS-样式？" class="headerlink" title="19.为什么要初始化 CSS 样式？"></a>19.为什么要初始化 CSS 样式？</h4><ol><li>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</li><li>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。<br>最简单的初始化方法：*{padding:0;margin:0;}（强烈不建议）</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*淘宝初始化样式*/</span><br><span class="hljs-selector-tag">body</span>,<span class="hljs-selector-tag">h1</span>,<span class="hljs-selector-tag">h2</span>,<span class="hljs-selector-tag">h3</span>,<span class="hljs-selector-tag">h4</span>,<span class="hljs-selector-tag">h5</span>,<span class="hljs-selector-tag">h6</span>,hr,<span class="hljs-selector-tag">p</span>,<span class="hljs-selector-tag">blockquote</span>,<span class="hljs-selector-tag">dl</span>,<span class="hljs-selector-tag">dt</span>,<span class="hljs-selector-tag">dd</span>,<span class="hljs-selector-tag">ul</span>,<span class="hljs-selector-tag">ol</span>,<span class="hljs-selector-tag">li</span>,pre,<span class="hljs-selector-tag">form</span>,<span class="hljs-selector-tag">fieldset</span>,<span class="hljs-selector-tag">legend</span><br>,<span class="hljs-selector-tag">button</span>,<span class="hljs-selector-tag">input</span>,<span class="hljs-selector-tag">textarea</span>,<span class="hljs-selector-tag">th</span>,<span class="hljs-selector-tag">td</span>&#123;<span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;<span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;&#125;<br><span class="hljs-selector-tag">body</span>,<span class="hljs-selector-tag">button</span>,<span class="hljs-selector-tag">input</span>,select,<span class="hljs-selector-tag">textarea</span>&#123;<span class="hljs-attribute">font</span>:<span class="hljs-number">12px</span>/<span class="hljs-number">1.5</span>tahoma,arial,\<span class="hljs-number">5</span>b8b\<span class="hljs-number">4</span>f53;&#125;<br><span class="hljs-selector-tag">h1</span>,<span class="hljs-selector-tag">h2</span>,<span class="hljs-selector-tag">h3</span>,<span class="hljs-selector-tag">h4</span>,<span class="hljs-selector-tag">h5</span>,<span class="hljs-selector-tag">h6</span>&#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">100%</span>;&#125;<br><span class="hljs-selector-tag">address</span>,<span class="hljs-selector-tag">cite</span>,<span class="hljs-selector-tag">dfn</span>,<span class="hljs-selector-tag">em</span>,<span class="hljs-selector-tag">var</span>&#123;<span class="hljs-attribute">font-style</span>:normal;&#125;<br><span class="hljs-selector-tag">code</span>,<span class="hljs-selector-tag">kbd</span>,pre,<span class="hljs-selector-tag">samp</span>&#123;<span class="hljs-attribute">font-family</span>:couriernew,courier,monospace;&#125;<br>small&#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">12px</span>;&#125;<br><span class="hljs-selector-tag">ul</span>,<span class="hljs-selector-tag">ol</span>&#123;<span class="hljs-attribute">list-style</span>:none;&#125;<br><span class="hljs-selector-tag">a</span>&#123;<span class="hljs-attribute">text-decoration</span>:none;&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<span class="hljs-attribute">text-decoration</span>:underline;&#125;<br><span class="hljs-selector-tag">sup</span>&#123;<span class="hljs-attribute">vertical-align</span>:text-top;&#125;<br>sub&#123;<span class="hljs-attribute">vertical-align</span>:text-bottom;&#125;<br><span class="hljs-selector-tag">legend</span>&#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#000</span>;&#125;<br><span class="hljs-selector-tag">fieldset</span>,<span class="hljs-selector-tag">img</span>&#123;<span class="hljs-attribute">border</span>:<span class="hljs-number">0</span>;&#125;<br><span class="hljs-selector-tag">button</span>,<span class="hljs-selector-tag">input</span>,select,<span class="hljs-selector-tag">textarea</span>&#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">100%</span>;&#125;<br><span class="hljs-selector-tag">table</span>&#123;<span class="hljs-attribute">border-collapse</span>:collapse;<span class="hljs-attribute">border-spacing</span>:<span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><h4 id="20-什么是包含块，对于包含块的理解"><a href="#20-什么是包含块，对于包含块的理解" class="headerlink" title="20.什么是包含块，对于包含块的理解?"></a>20.什么是包含块，对于包含块的理解?</h4><p> 包含块（containing block）就是元素用来计算和定位的一个框。</p><ol><li>根元素（很多场景下可以看成是<html>）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。</li><li>对于其他元素，如果该元素的position是relative或者static，则“包含块”由其最近的块级祖先元素的content box边界形成。</li><li>如果元素position:fixed，则“包含块”是“初始包含块”。</li><li>如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素建立，具体方式如下：<br>如果该祖先元素是纯inline元素，则规则略复杂：<ul><li>假设给内联元素的前后各生成一个宽度为0的内联盒子（inline box），则这两个内联盒子的padding box外面的包围盒就是内联元素的“包含块”；</li><li>如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范并没有明确定义，浏览器自行发挥否则，“包含块”由该祖先的padding box边界形成。<br>如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">简单描述：默认情况下包含块就是离当前元素最近的块级祖先元素；<br>对于开启了绝对定位的元素来说，包含块是离它最近的开启了定位（且position不为static）的祖先元素，<br>如果所有的祖先元素都没有开启定位，则其包含块就是初始包含块。<br></code></pre></td></tr></table></figure></li></ul></li></ol><h4 id="21-CSS-里的-visibility-属性有个-collapse-属性值是干嘛用的？在不同浏览器下以后什么区别？"><a href="#21-CSS-里的-visibility-属性有个-collapse-属性值是干嘛用的？在不同浏览器下以后什么区别？" class="headerlink" title="21.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？"></a>21.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？</h4><ul><li>对于一般的元素，它的表现跟visibility：hidden;是一样的。元素是不可见的，但此时仍占用页面空间。</li><li>但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟display:none一样，也就是说，它们占用的空间也会释放。<br>在不同浏览器下的区别：<br>  在谷歌浏览器里，使用collapse值和使用hidden值没有什么区别。<br>  在火狐浏览器、Opera和IE11里，使用collapse值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。</li></ul><h4 id="22-width-auto-和-width-100-的区别"><a href="#22-width-auto-和-width-100-的区别" class="headerlink" title="22.width:auto 和 width:100%的区别"></a>22.width:auto 和 width:100%的区别</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">一般而言<br>  width:100%会使元素box的宽度等于父元素的content box的宽度。<br>  width:auto会使元素撑满整个父元素，margin、border、padding、content区域会自动分配水平空间。<br></code></pre></td></tr></table></figure><h4 id="23-绝对定位元素与非绝对定位元素的百分比计算的区别"><a href="#23-绝对定位元素与非绝对定位元素的百分比计算的区别" class="headerlink" title="23.绝对定位元素与非绝对定位元素的百分比计算的区别"></a>23.绝对定位元素与非绝对定位元素的百分比计算的区别</h4><p>绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的padding box来计算的。<br>非绝对定位元素的宽高百分比则是相对于父元素的content box来计算的。</p><h4 id="24-简单介绍使用图片-base64-编码的优点和缺点。"><a href="#24-简单介绍使用图片-base64-编码的优点和缺点。" class="headerlink" title="24.简单介绍使用图片 base64 编码的优点和缺点。"></a>24.简单介绍使用图片 base64 编码的优点和缺点。</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的<br>url属性。<br><br>使用base64的优点是：<br><br> 1. 减少一个图片的HTTP请求<br><br>使用base64的缺点是：<br><br>  1. 根据base64的编码原理，编码后的大小会比原文件大小大1/3，如果把大图片编码到html/css中，不仅会造成文件体<br>  积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。<br><br>  2. 使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如HTML或者CSS，这相比于直接缓存图片的效果要<br>  差很多。<br><br>  3. 兼容性的问题，ie8以前的浏览器不支持。<br><br> 一般一些网站的小图标可以使用base64图片来引入。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/coco1s/p/4375774.html">《玩转图片 base64 编码》</a><br><a href="https://www.zhihu.com/question/31155574">《前端开发中，使用 base64 图片的弊端是什么？》</a><br><a href="https://www.zhangxinxu.com/wordpress/2012/04/base64-url-image-%E5%9B%BE%E7%89%87-%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">《小 tip:base64:URL 背景图片与 web 页面性能优化》</a></p><h4 id="25-’display’、’position’和’float’的相互关系？"><a href="#25-’display’、’position’和’float’的相互关系？" class="headerlink" title="25.’display’、’position’和’float’的相互关系？"></a>25.’display’、’position’和’float’的相互关系？</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs maxima">（<span class="hljs-number">1</span>）首先我们判断<span class="hljs-built_in">display</span>属性是否为none，如果为none，则<span class="hljs-built_in">position</span>和<span class="hljs-built_in">float</span>属性的值不影响元素最后的表现。<br><br>（<span class="hljs-number">2</span>）然后判断<span class="hljs-built_in">position</span>的值是否为absolute或者fixed，如果是，则<span class="hljs-built_in">float</span>属性失效，并且<span class="hljs-built_in">display</span>的值应该被<br>设置为table或者<span class="hljs-built_in">block</span>，具体转换需要看初始转换值。<br><br>（<span class="hljs-number">3</span>）如果<span class="hljs-built_in">position</span>的值不为absolute或者fixed，则判断<span class="hljs-built_in">float</span>属性的值是否为none，如果不是，则<span class="hljs-built_in">display</span><br>的值则按上面的规则转换。注意，如果<span class="hljs-built_in">position</span>的值为relative并且<span class="hljs-built_in">float</span>属性的值存在，则relative相对<br>于浮动后的最终位置定位。<br><br>（<span class="hljs-number">4</span>）如果<span class="hljs-built_in">float</span>的值为none，则判断元素是否为根元素，如果是根元素则<span class="hljs-built_in">display</span>属性按照上面的规则转换，如果不是，<br>则保持指定的<span class="hljs-built_in">display</span>属性值不变。<br><br>总的来说，可以把它看作是一个类似优先级的机制，<span class="hljs-string">&quot;position:absolute&quot;</span>和<span class="hljs-string">&quot;position:fixed&quot;</span>优先级最高，有它存在<br>的时候，浮动不起作用，&#x27;<span class="hljs-built_in">display</span>&#x27;的值也需要调整；其次，元素的&#x27;<span class="hljs-built_in">float</span>&#x27;特性的值不是<span class="hljs-string">&quot;none&quot;</span>的时候或者它是根元素<br>的时候，调整&#x27;<span class="hljs-built_in">display</span>&#x27;的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，&#x27;<span class="hljs-built_in">display</span>&#x27;特性值同设置值。<br><br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://www.cnblogs.com/jackyWHJ/p/3756087.html">《position 跟 display、margincollapse、overflow、float 这些特性相互叠加后会怎么样？》</a></p><h4 id="26-margin-重叠问题的理解。"><a href="#26-margin-重叠问题的理解。" class="headerlink" title="26.margin 重叠问题的理解。"></a>26.margin 重叠问题的理解。</h4><p>相关知识点：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs css">块级元素的上外边距（<span class="hljs-attribute">margin-top</span>）与下外边距（<span class="hljs-attribute">margin-bottom</span>）有时会合并为单个外边距，这样的现象称为“<span class="hljs-attribute">margin</span>合<br>并”。<br><br>产生折叠的必备条件：<span class="hljs-attribute">margin</span>必须是邻接的!<br><br>而根据w3c规范，两个<span class="hljs-attribute">margin</span>是邻接的必须满足以下条件：<br><br>•必须是处于常规文档流（非<span class="hljs-attribute">float</span>和绝对定位）的块级盒子，并且处于同一个BFC当中。<br>•没有线盒，没有空隙，没有<span class="hljs-attribute">padding</span>和<span class="hljs-attribute">border</span>将他们分隔开<br>•都属于垂直方向上相邻的外边距，可以是下面任意一种情况<br>•元素的<span class="hljs-attribute">margin-top</span>与其第一个常规文档流的子元素的<span class="hljs-attribute">margin-top</span><br>•元素的<span class="hljs-attribute">margin-bottom</span>与其下一个常规文档流的兄弟元素的<span class="hljs-attribute">margin-top</span><br>•<span class="hljs-attribute">height</span>为auto的元素的<span class="hljs-attribute">margin-bottom</span>与其最后一个常规文档流的子元素的<span class="hljs-attribute">margin-bottom</span><br>•高度为<span class="hljs-number">0</span>并且最小高度也为<span class="hljs-number">0</span>，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的<span class="hljs-attribute">margin-top</span>和<span class="hljs-attribute">margin-bottom</span><br><br><span class="hljs-attribute">margin</span>合并的<span class="hljs-number">3</span>种场景：<br><br>（<span class="hljs-number">1</span>）相邻兄弟元素<span class="hljs-attribute">margin</span>合并。<br><br>解决办法：<br>•设置块状格式化上下文元素（BFC），即开启BFC<br><br>（<span class="hljs-number">2</span>）父级和第一个/最后一个子元素的<span class="hljs-attribute">margin</span>合并。<br><br>解决办法：<br><br>对于<span class="hljs-attribute">margin-top</span>合并，可以进行如下操作（满足一个条件即可）：<br>•父元素设置为块状格式化上下文元素；即开启BFC<br>•父元素设置<span class="hljs-attribute">border-top</span>值；<br>•父元素设置<span class="hljs-attribute">padding-top</span>值；<br>•父元素和第一个子元素之间添加内联元素进行分隔。<br><br>对于<span class="hljs-attribute">margin-bottom</span>合并，可以进行如下操作（满足一个条件即可）：<br>•父元素设置为块状格式化上下文元素；<br>•父元素设置<span class="hljs-attribute">border-bottom</span>值；<br>•父元素设置<span class="hljs-attribute">padding-bottom</span>值；<br>•父元素和最后一个子元素之间添加内联元素进行分隔；<br>•父元素设置<span class="hljs-attribute">height</span>、<span class="hljs-attribute">min-height</span>或<span class="hljs-attribute">max-height</span>。<br><br>（<span class="hljs-number">3</span>）空块级元素的<span class="hljs-attribute">margin</span>合并。<br><br>解决办法：<br>•设置垂直方向的<span class="hljs-attribute">border</span>；<br>•设置垂直方向的<span class="hljs-attribute">padding</span>；<br>•里面添加内联元素（直接Space键空格是没用的）；<br>•设置<span class="hljs-attribute">height</span>或者<span class="hljs-attribute">min-height</span>。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">margin</span>重叠指的是在垂直方向上，两个相邻元素的<span class="hljs-attribute">margin</span>发生重叠的情况。<br><br>一般来说可以分为四种情形：<br><br>第一种是相邻兄弟元素的marin-<span class="hljs-attribute">bottom</span>和<span class="hljs-attribute">margin-top</span>的值发生重叠。这种情况下我们可以通过设置其中一个元素为BFC<br>来解决。<br><br>第二种是父元素的<span class="hljs-attribute">margin-top</span>和子元素的<span class="hljs-attribute">margin-top</span>发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这<br>一点来解决这个问题。我们可以为父元素设置<span class="hljs-attribute">border-top</span>、<span class="hljs-attribute">padding-top</span>值来分隔它们，当然我们也可以将父元素设置为BFC<br>来解决。<br><br>第三种是高度为auto的父元素的<span class="hljs-attribute">margin-bottom</span>和子元素的<span class="hljs-attribute">margin-bottom</span>发生重叠。它们发生重叠一个是因为它们相<br>邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置<span class="hljs-attribute">border-bottom</span>、<span class="hljs-attribute">padding-bottom</span>来分隔它们，也可以为<br>父元素设置一个高度，<span class="hljs-attribute">max-height</span>和<span class="hljs-attribute">min-height</span>也能解决这个问题。当然将父元素设置为BFC是最简单的方法。<br><br>第四种情况，是没有内容的元素，自身的<span class="hljs-attribute">margin-top</span>和<span class="hljs-attribute">margin-bottom</span>发生的重叠。我们可以通过为其设置<span class="hljs-attribute">border</span>、pa<br>dding或者高度来解决这个问题。<br></code></pre></td></tr></table></figure><h4 id="27-对-BFC-规范（块级格式化上下文：block-formatting-context）的理解？"><a href="#27-对-BFC-规范（块级格式化上下文：block-formatting-context）的理解？" class="headerlink" title="27.对 BFC 规范（块级格式化上下文：block formatting context）的理解？"></a>27.对 BFC 规范（块级格式化上下文：block formatting context）的理解？</h4><p>相关知识点：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino">块级格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒<br>子的区域，也是浮动元素与其他元素的交互限定区域。<br><br>通俗来讲<br><br>•BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。<br>•如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。<br><br>创建BFC<br><br>（<span class="hljs-number">1</span>）根元素或包含根元素的元素<br>（<span class="hljs-number">2</span>）浮动元素<span class="hljs-type">float</span>＝left|right或inherit（≠none）<br>（<span class="hljs-number">3</span>）绝对定位元素position＝absolute或fixed<br>（<span class="hljs-number">4</span>）display＝<span class="hljs-keyword">inline</span>-block|flex|<span class="hljs-keyword">inline</span>-flex|table-cell或table-caption<br>（<span class="hljs-number">5</span>）overflow＝hidden|<span class="hljs-keyword">auto</span>或<span class="hljs-built_in">scroll</span>(≠visible)<br><br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">BFC指的是块级格式化上下文，一个元素开启了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也<br>不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。<br><br>一般来说根元素是一个BFC区域，浮动和绝对定位的元素也会形成BFC，<span class="hljs-attribute">display</span>属性的值为inline-block、<span class="hljs-attribute">flex</span>这些<br>属性时也会创建BFC。还有就是元素的<span class="hljs-attribute">overflow</span>的值不为visible时都会创建BFC。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html">《深入理解 BFC 和 MarginCollapse》</a><br><a href="https://segmentfault.com/a/1190000013647777">《前端面试题-BFC（块格式化上下文）》</a></p><h4 id="28-IFC-是什么？"><a href="#28-IFC-是什么？" class="headerlink" title="28.IFC 是什么？"></a>28.IFC 是什么？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">IFC指的是行级格式化上下文，它有这样的一些布局规则：<br><br>（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。<br>（2）当一行不够的时候会自动切换到下一行。<br>（3）行级上下文的高度由内部最高的内联盒子的高度决定。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000004466536#articleHeader5">《[译]:BFC 与 IFC》</a><br><a href="https://blog.csdn.net/paintandraw/article/details/80401741">《BFC 和 IFC 的理解（布局）》</a></p><h4 id="29-请解释一下为什么需要清除浮动？清除浮动的方式"><a href="#29-请解释一下为什么需要清除浮动？清除浮动的方式" class="headerlink" title="29.请解释一下为什么需要清除浮动？清除浮动的方式"></a>29.请解释一下为什么需要清除浮动？清除浮动的方式</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，<br>不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框<br>的高度小于浮动框的时候，此时就会出现“高度塌陷”。<br><br>清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。<br><br>清除浮动的方式<br><br>（<span class="hljs-number">1</span>）使用clear属性清除浮动。参考<span class="hljs-number">30</span>。<br><br>（<span class="hljs-number">2</span>）使用<span class="hljs-keyword">BFC块级格式化上下文来清除浮动。参考26。</span><br><span class="hljs-keyword"></span><br>因为<span class="hljs-keyword">BFC元素不会影响外部元素的特点，所以BFC元素也可以用来清除浮动的影响，因为如果不清除，子元素浮动则父元</span><br><span class="hljs-keyword"></span>素高度塌陷，必然会影响后面元素布局和定位，这显然有违<span class="hljs-keyword">BFC元素的子元素不会影响外部元素的设定。</span><br></code></pre></td></tr></table></figure><h4 id="30-使用-clear-属性清除浮动的原理？"><a href="#30-使用-clear-属性清除浮动的原理？" class="headerlink" title="30.使用 clear 属性清除浮动的原理？"></a>30.使用 clear 属性清除浮动的原理？</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs coq">使用<span class="hljs-built_in">clear</span>属性清除浮动，其语法如下：<span class="hljs-built_in">clear</span>:none|<span class="hljs-type">left</span>|<span class="hljs-type">right</span>|<span class="hljs-type">both</span><br><br>如果单看字面意思，<span class="hljs-built_in">clear</span>:<span class="hljs-built_in">left</span>应该是“清除左浮动”，<span class="hljs-built_in">clear</span>:<span class="hljs-built_in">right</span>应该是“清除右浮动”的意思，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。<br><br>官方对<span class="hljs-built_in">clear</span>属性的解释是：“元素盒子的边不能和前面的浮动元素相邻。”，我们对元素设置<span class="hljs-built_in">clear</span>属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。<br><br>还需要注意的一点是<span class="hljs-built_in">clear</span>属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”<span class="hljs-number">3</span>个字，也就是<span class="hljs-built_in">clear</span>属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是<span class="hljs-built_in">left</span>，要么是<span class="hljs-built_in">right</span>，不可能同时存在，同时由于<span class="hljs-built_in">clear</span>属性对“后面的”浮动元素不闻不问，因此，当<span class="hljs-built_in">clear</span>:<span class="hljs-built_in">left</span>有效的时候，<span class="hljs-built_in">clear</span>:<span class="hljs-built_in">right</span>必定无效，也就是此时<span class="hljs-built_in">clear</span>:<span class="hljs-built_in">left</span>等同于设置<span class="hljs-built_in">clear</span>:both；同样地，<span class="hljs-built_in">clear</span>:<span class="hljs-built_in">right</span>如果有效也是等同于设置<span class="hljs-built_in">clear</span>:both。由此可见，<span class="hljs-built_in">clear</span>:<span class="hljs-built_in">left</span>和<span class="hljs-built_in">clear</span>:<span class="hljs-built_in">right</span>这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用<span class="hljs-built_in">clear</span>:both吧。<br><br>一般使用伪元素的方式清除浮动<br>.<span class="hljs-built_in">clear</span>::<span class="hljs-built_in">before</span>,  // 解决外边距重叠的问题<br>.<span class="hljs-built_in">clear</span>::<span class="hljs-built_in">after</span>&#123;   // 解决高度塌陷的问题<br>  content:&#x27;&#x27;;<br>  display:table;//也可以是&#x27;block&#x27;，或者是&#x27;list-item&#x27;<br>  <span class="hljs-built_in">clear</span>:both;<br>&#125;<br><br><span class="hljs-built_in">clear</span>属性只有块级元素才有效的，而::<span class="hljs-built_in">after</span>等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。<br></code></pre></td></tr></table></figure><h4 id="31-zoom-1-的清除浮动原理"><a href="#31-zoom-1-的清除浮动原理" class="headerlink" title="31.zoom:1 的清除浮动原理?"></a>31.zoom:1 的清除浮动原理?</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gauss">清除浮动，触发hasLayout；<br>zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。譬如外边距（<span class="hljs-built_in">margin</span>）<br>的重叠，浮动清除，触发ie的haslayout属性等。<br><br>来龙去脉大概如下：<br>当设置了zoom的值之后，所设置的元素就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发<br>生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。<br><br>zoom属性是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标<br>准化，出现在CSS3<span class="hljs-number">.0</span>规范草案中。<br><br>目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？可以通过css3里面的动画属性<span class="hljs-built_in">scale</span>进行缩放。<br></code></pre></td></tr></table></figure><h4 id="32-移动端的布局用过媒体查询吗？"><a href="#32-移动端的布局用过媒体查询吗？" class="headerlink" title="32.移动端的布局用过媒体查询吗？"></a>32.移动端的布局用过媒体查询吗？</h4><p>&nbsp;&nbsp;假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法</p><p>&nbsp;&nbsp;当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规则被应用。当媒体查询返回假，标签上带有媒体查询的样式表仍将被下载（只不过不会被应用）。</p><p>&nbsp;&nbsp;包含了一个媒体类型和至少一个使用宽度、高度和颜色等媒体属性来限制样式表范围的表达式。CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。</p><p>详细资料可以参考：<br><a href="http://www.runoob.com/cssref/css3-pr-mediaquery.html">《CSS3@media 查询》</a><br><a href="http://caibaojian.com/356.html">《响应式布局和自适应布局详解》</a></p><h4 id="33-使用-CSS-预处理器吗？喜欢哪个？"><a href="#33-使用-CSS-预处理器吗？喜欢哪个？" class="headerlink" title="33.使用 CSS 预处理器吗？喜欢哪个？"></a>33.使用 CSS 预处理器吗？喜欢哪个？</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">SASS（SASS、<span class="hljs-keyword">LESS</span>没有本质区别，只因为团队前端都是用的SASS）<br></code></pre></td></tr></table></figure><h4 id="34-CSS-优化、提高性能的方法有哪些？"><a href="#34-CSS-优化、提高性能的方法有哪些？" class="headerlink" title="34.CSS 优化、提高性能的方法有哪些？"></a>34.CSS 优化、提高性能的方法有哪些？</h4><p><strong>加载性能：</strong></p><ol><li>css压缩：将写好的css进行打包压缩，可以减少很多的体积。</li><li>css单一样式：当需要下边距和左边距的时候，很多时候选择<code>margin:top 0 bottom 0</code>但<code>margin-bottom:bottom;margin-left:left;</code>执行的效率更高。</li><li>减少使用<code>@import</code>,而建议使用<code>link</code>，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</li></ol><p><strong>选择器性能：</strong></p><ol><li>关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择器是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</li><li>如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</li><li>避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。</li><li>尽量少的去对标签进行选择，而是用class。</li><li>尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li><li>了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</li></ol><p><strong>渲染性能：</strong></p><ol><li>慎重使用高性能属性：浮动、定位。</li><li>尽量减少页面重排、重绘。</li><li>去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</li><li>属性值为0时，不加单位。</li><li>属性值为浮动小数0.**，可以省略小数点之前的0。</li><li>标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li><li>不使用@import前缀，它会影响css的加载速度。</li><li>选择器优化嵌套，尽量避免层级过深。</li><li>css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li><li>正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</li><li>不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏<br>览器在下载web fonts时会阻塞页面渲染损伤性能。</li></ol><p><strong>可维护性、健壮性：</strong></p><ol><li>将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</li><li>样式与内容分离：将css代码定义到外部css中。</li></ol><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19886806">《CSS 优化、提高性能的方法有哪些？》</a><br><a href="https://www.jianshu.com/p/4e673bf24a3b">《CSS 优化，提高性能的方法》</a></p><h4 id="35-浏览器是怎样解析-CSS-选择器的？"><a href="#35-浏览器是怎样解析-CSS-选择器的？" class="headerlink" title="35.浏览器是怎样解析 CSS 选择器的？"></a>35.浏览器是怎样解析 CSS 选择器的？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直<br>到和规则匹配，或者是因为不匹配而放弃该规则。<br><br>试想一下，如果采用从左至右的方式读取CSS规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，<br>最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://juejin.im/entry/5a123c55f265da432240cc90">《探究 CSS 解析原理》</a></p><h4 id="36-在网页中应该使用奇数还是偶数的字体？为什么呢？"><a href="#36-在网页中应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="36.在网页中应该使用奇数还是偶数的字体？为什么呢？"></a>36.在网页中应该使用奇数还是偶数的字体？为什么呢？</h4><ol><li>偶数字号相对更容易和web设计的其他部分构成比例关系。比如：当我用了14px的正文字号，我可能会在一些地方用14×0.5&#x3D;7px的margin，在另一些地方用14×1.5&#x3D;21px的标题字号。</li><li>浏览器缘故，低版本的浏览器ie6会把奇数字体强制转化为偶数，即13px渲染为14px。</li><li>系统差别，早期的Windows里，中易宋体点阵只有12和14、15、16px，唯独缺少13px。</li></ol><p>详细资料可以参考：<br><a href="https://blog.csdn.net/jian_xi/article/details/79346477">《谈谈网页中使用奇数字体和偶数字体》</a><br><a href="https://www.zhihu.com/question/20440679">《现在网页设计中的为什么少有人用 11px、13px、15px 等奇数的字体？》</a></p><h4 id="37-margin-和-padding-分别适合什么场景使用？"><a href="#37-margin-和-padding-分别适合什么场景使用？" class="headerlink" title="37.margin 和 padding 分别适合什么场景使用？"></a>37.margin 和 padding 分别适合什么场景使用？</h4><p>margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。<br>margin用于布局分开元素使元素与元素互不相干。<br>padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。</p><p>何时应当使用margin：</p><ul><li>需要在border外侧添加空白时。</li><li>空白处不需要背景（色）时。</li><li>上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。</li></ul><p>何时应当时用padding：</p><ul><li>需要在border内测添加空白时。</li><li>空白处需要背景（色）时。</li><li>上下相连的两个盒子之间的空白，不需要相互抵消时。如15px+20px的margin，将得到35px的空白。</li></ul><h4 id="38-抽离样式模块怎么写，说出思路，有无实践经验？-阿里航旅的面试题"><a href="#38-抽离样式模块怎么写，说出思路，有无实践经验？-阿里航旅的面试题" class="headerlink" title="38.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]"></a>38.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</h4><p>&nbsp;&nbsp;<strong>我的理解是把常用的css样式单独做成css文件……通用的和业务相关的分离出来，通用的做成样式模块儿共享，业务相关的，放进业务相关的库里面做成对应功能的模块儿。</strong></p><p>详细资料可以参考：<a href="http://nec.netease.com/standard/css-sort.html">《CSS 规范-分类方法》</a></p><h4 id="39-简单说一下-css3-的-all-属性。"><a href="#39-简单说一下-css3-的-all-属性。" class="headerlink" title="39.简单说一下 css3 的 all 属性。"></a>39.简单说一下 css3 的 all 属性。</h4><p>&nbsp;&nbsp;all属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction这两个CSS属性。支持三个CSS通用属性值，initial,inherit,unset。</p><p><strong>initial:</strong> initial是初始值的意思，也就是该元素除了<code>unicode-bidi</code>和<code>direction</code>以外的CSS属性都使用属性的默认初始值。</p><p><strong>inherit:</strong> inherit是继承的意思，也就是该元素除了<code>unicode-bidi</code>和<code>direction</code>以外的CSS属性都继承父元素的属性值。</p><p><strong>unset:</strong> unset是取消设置的意思，也就是当前元素浏览器或用户设置的CSS忽略，然后如果是具有继承特性的CSS，如<code>color</code>，则使用继承值；如果是没有继承特性的CSS属性，如<code>background-color</code>，则使用初始值。</p><p>详细资料可以参考：<a href="https://www.zhangxinxu.com/wordpress/2016/03/know-about-css3-all/">《简单了解 CSS3 的 all 属性》</a></p><h4 id="40-为什么不建议使用统配符初始化-css-样式。"><a href="#40-为什么不建议使用统配符初始化-css-样式。" class="headerlink" title="40.为什么不建议使用统配符初始化 css 样式。"></a>40.为什么不建议使用统配符初始化 css 样式。</h4><p>&nbsp;&nbsp;采用<code>*&#123;padding:0;margin:0;&#125;</code>这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时，样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一套初始化样式。</p><p>&nbsp;&nbsp;出于性能的考虑，并不是所有标签都会有<code>padding</code>和<code>margin</code>，因此对常见的具有默认<code>padding</code>和<code>margin</code>的元素初始化即可，并不需使用通配符*来初始化。</p><h4 id="41-absolute-的-containingblock（包含块）计算方式跟正常流有什么不同？"><a href="#41-absolute-的-containingblock（包含块）计算方式跟正常流有什么不同？" class="headerlink" title="41.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？"></a>41.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？</h4><ul><li>内联元素也可以作为“包含块”所在的元素；</li><li>“包含块”所在的元素不是父块级元素，而是最近的position不为static的祖先元素或根元素；</li><li>边界是padding box而不是content box。</li></ul><h4 id="42-对于-hasLayout-的理解？"><a href="#42-对于-hasLayout-的理解？" class="headerlink" title="42.对于 hasLayout 的理解？"></a>42.对于 hasLayout 的理解？</h4><p>&nbsp;&nbsp;hasLayout是IE特有的一个属性。很多的IE下的css bug都与其息息相关。在IE中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完成这些工作。</p><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000010883974">《CSS 基础篇–CSS 中 IE 浏览器的 hasLayout，IE 低版本的 bug 根源》</a><br><a href="https://segmentfault.com/a/1190000004632071">《CSS 魔法堂：hasLayout 原来是这样的！》</a></p><h4 id="43-元素竖向的百分比设定是相对于容器的高度吗？"><a href="#43-元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="43.元素竖向的百分比设定是相对于容器的高度吗？"></a>43.元素竖向的百分比设定是相对于容器的高度吗？</h4><p><strong>如果是height的话，是相对于包含块的高度。</strong><br><strong>如果是padding或者margin竖直方向的属性则是相对于包含块的宽度。</strong></p><h4 id="44-全屏滚动的原理是什么？用到了-CSS-的哪些属性？（待深入实践）"><a href="#44-全屏滚动的原理是什么？用到了-CSS-的哪些属性？（待深入实践）" class="headerlink" title="44.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）"></a>44.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）</h4><p>&nbsp;&nbsp;<strong>原理：</strong> 有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，容器及容器内的页面取当前可视区高度，同时容器的父级元素overflow属性值设为hidden，通过更改容器可视区的位置来实现全屏滚动效果。主要是响应鼠标事件，页面通过CSS的动画效果，进行移动。<br><code>overflow：hidden；transition：all 1000ms ease；</code></p><p>详细资料可以参考：<br><a href="https://blog.csdn.net/liona_koukou/article/details/52680409">《js 实现网页全屏切换（平滑过渡），鼠标滚动切换》</a><br><a href="https://juejin.im/post/5aeef41cf265da0ba0630de0">《用 ES6 写全屏滚动插件》</a></p><h4 id="45-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？（待深入了解）"><a href="#45-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？（待深入了解）" class="headerlink" title="45.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）"></a>45.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）</h4><p>&nbsp;&nbsp;响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。页面头部必须有meta声明的viewport。</p><p>详细资料可以参考：<br><a href="https://blog.csdn.net/dreamerframework/article/details/8994741">《响应式布局原理》</a><br><a href="http://www.mahaixiang.cn/wzsj/278.html">《响应式布局的实现方法和原理》</a></p><h4 id="46-视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）"><a href="#46-视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）" class="headerlink" title="46.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）"></a>46.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）</h4><p>&nbsp;&nbsp;视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。</p><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/20990029">《如何实现视差滚动效果的网页？》</a></p><h4 id="47-如何修改-chrome-记住密码后自动填充表单的黄色背景？"><a href="#47-如何修改-chrome-记住密码后自动填充表单的黄色背景？" class="headerlink" title="47.如何修改 chrome 记住密码后自动填充表单的黄色背景？"></a>47.如何修改 chrome 记住密码后自动填充表单的黄色背景？</h4><p>&nbsp;&nbsp;chrome表单自动填充后，input文本框的背景会变成黄色的，通过审查元素可以看到这是由于chrome会默认给自动填充的input表单加上input:-webkit-autofill私有属性，然后对其赋予以下样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>  <span class="hljs-attribute">background-color</span>:<span class="hljs-built_in">rgb</span>(<span class="hljs-number">250</span>,<span class="hljs-number">255</span>,<span class="hljs-number">189</span>)<span class="hljs-meta">!important</span>;<br>  <span class="hljs-attribute">background-image</span>:none<span class="hljs-meta">!important</span>;<br>  <span class="hljs-attribute">color</span>:<span class="hljs-built_in">rgb</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<span class="hljs-meta">!important</span>;<br>&#125;<br><span class="hljs-comment">/*对chrome默认定义的background-color，background-image，color使用important是不能提高其优先级的，但是其他属性可使用。*/</span><br></code></pre></td></tr></table></figure><p>&nbsp;&nbsp;使用足够大的纯色内阴影来覆盖input输入框的黄色背景，处理如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span>:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill &#123;<br>  -webkit-<span class="hljs-attribute">box-shadow</span>:<span class="hljs-number">000px</span> <span class="hljs-number">1000px</span> white inset;<br>  <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#CCC</span> <span class="hljs-meta">!important</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/zsl_955200/article/details/78276209">《去掉 chrome 记住密码后的默认填充样式》</a><br><a href="https://blog.csdn.net/M_agician/article/details/73381706">《修改谷歌浏览器 chrome 记住密码后自动填充表单的黄色背景》</a></p><h4 id="48-怎么让-Chrome-支持小于-12px-的文字？"><a href="#48-怎么让-Chrome-支持小于-12px-的文字？" class="headerlink" title="48.怎么让 Chrome 支持小于 12px 的文字？"></a>48.怎么让 Chrome 支持小于 12px 的文字？</h4><p>&nbsp;&nbsp;在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</p><p>解决办法：</p><ol><li>可以使用Webkit的内核的<code>-webkit-text-size-adjust</code>的私有CSS属性来解决，只要加了<code>-webkit-text-size-adjust:none;</code>字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持<code>-webkit-text-size-adjust</code>样式，所以要使用时候慎用。</li><li>还可以使用css3的<code>transform</code>缩放属性<code>-webkit-transform:scale(0.5);</code>注意<code>-webkit-transform:scale(0.75);</code>收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用<code>display：block/inline-block/...；</code></li><li>使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</li></ol><p>详细资料可以参考：<a href="https://570109268.iteye.com/blog/2406562">《谷歌浏览器不支持 CSS 设置小于 12px 的文字怎么办？》</a></p><h4 id="49-让页面里的字体变清晰，变细用-CSS-怎么做？"><a href="#49-让页面里的字体变清晰，变细用-CSS-怎么做？" class="headerlink" title="49.让页面里的字体变清晰，变细用 CSS 怎么做？"></a>49.让页面里的字体变清晰，变细用 CSS 怎么做？</h4><p>&nbsp;&nbsp;webkit内核的私有属性<code>：-webkit-font-smoothing</code>，用于字体抗锯齿，使用后字体看起来会更清晰舒服。<br>&nbsp;&nbsp;在MacOS测试环境下面设置<code>-webkit-font-smoothing:antialiased;</code>但是这个属性仅仅是面向MacOS，其他操作系统设置后无效。</p><p>详细资料可以参考：<a href="https://blog.csdn.net/huo_bao/article/details/50251585">《让字体变的更清晰 CSS 中-webkit-font-smoothing》</a></p><h4 id="50-font-style-属性中-italic-和-oblique-的区别？"><a href="#50-font-style-属性中-italic-和-oblique-的区别？" class="headerlink" title="50.font-style 属性中 italic 和 oblique 的区别？"></a>50.font-style 属性中 italic 和 oblique 的区别？</h4><p>&nbsp;&nbsp;<code>italic</code>和<code>oblique</code>这两个关键字都表示“斜体”的意思。<br>&nbsp;&nbsp;它们的区别在于，<code>italic</code>是使用当前字体的斜体字体，而<code>oblique</code>只是单纯地让文字倾斜。如果当前字体没有对应的斜体字体，<br>则退而求其次，解析为<code>oblique</code>，也就是单纯形状倾斜。</p><h4 id="51-设备像素、css-像素、设备独立像素、dpr、ppi-之间的区别？"><a href="#51-设备像素、css-像素、设备独立像素、dpr、ppi-之间的区别？" class="headerlink" title="51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？"></a>51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？</h4><p>&nbsp;&nbsp;设备像素指的是物理像素，一般手机的分辨率指的就是设备像素，一个设备的设备像素是不可变的。</p><p>&nbsp;&nbsp;css像素和设备独立像素是等价的，不管在何种分辨率的设备上，css像素的大小应该是一致的，css像素是一个相对单位，它是相对于设备像素的，一个css像素的大小取决于页面缩放程度和dpr的大小。</p><p>&nbsp;&nbsp;dpr指的是设备像素和设备独立像素的比值，一般的pc屏幕，dpr&#x3D;1。在iphone4时，苹果推出了retina屏幕，它的dpr为2。屏幕的缩放会改变dpr的值。</p><p>&nbsp;&nbsp;ppi指的是每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/libin-1/p/7148377.html">《什么是物理像素、虚拟像素、逻辑像素、设备像素，什么又是 PPI,DPI,DPR 和 DIP》</a><br><a href="https://www.jianshu.com/p/af6dad66e49a">《前端工程师需要明白的「像素」》</a><br><a href="https://github.com/jawil/blog/issues/21">《CSS 像素、物理像素、逻辑像素、设备像素比、PPI、Viewport》</a><br><a href="https://github.com/wujunchuan/wujunchuan.github.io/issues/15">《前端开发中像素的概念》</a></p><h4 id="52-layout-viewport、visual-viewport-和-ideal-viewport-的区别？"><a href="#52-layout-viewport、visual-viewport-和-ideal-viewport-的区别？" class="headerlink" title="52.layout viewport、visual viewport 和 ideal viewport 的区别？"></a>52.layout viewport、visual viewport 和 ideal viewport 的区别？</h4><p><strong>相关知识点：</strong></p><ul><li>如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定默认情况下把<code>viewport</code>设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。ppk把这个浏览器默认的<code>viewport</code>叫做<code>layout viewport</code>。</li><li><code>layout viewport</code>的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个<code>viewport</code>来代表浏览器可视区域的大小，ppk把这个<code>viewport</code>叫做<code>visual viewport</code>。</li><li><code>ideal viewport</code>是最适合移动设备的<code>viewport，ideal viewport</code>的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为<code>ideal viewport</code>的宽度（单位用px），那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。<code>ideal viewport</code>的意义在于，无论在何种分辨率的屏幕下，那些针对<code>ideal viewport</code>而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。</li></ul><p><strong>回答：</strong></p><ul><li>移动端一共需要理解三个viewport的概念的理解。</li><li>第一个视口是布局视口，在移动端显示网页时，由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，那么整个页面的布局都会显示错乱。所以移动端浏览器提供了一个<code>layout viewport</code>布局视口的概念，使用这个视口来对页面进行布局展示，一般<code>layout viewport</code>的大小为980px，因此页面布局不会有太大的变化，我们可以通过拖动和缩放来查看到这个页面。</li><li>第二个视口指的是视觉视口，<code>visual viewport</code>指的是移动设备上我们可见的区域的视口大小，一般为屏幕的分辨率的大小。<code>visual viewport</code>和<code>layout viewport</code>的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口中的网页内容。</li><li>第三个视口是理想视口，由于<code>layout viewport</code>一般比<code>visual viewport</code>要大，所以想要看到整个页面必须通过拖动和缩放才能实现。所以又提出了<code>ideal viewport</code>的概念，<code>ideal viewport</code>下用户不用缩放和滚动条就能够查看到整个页面，并且页面在不同分辨率下显示的内容大小相同。<code>ideal viewport</code>其实就是通过修改<code>layout viewport</code>的大小，让它等于设备的宽度，这个宽度可以理解为是设备独立像素，因此根据<code>ideal viewport</code>设计的页面，在不同分辨率的屏幕下，显示应该相同。</li></ul><p>详细资料可以参考：<br>  <a href="https://www.cnblogs.com/2050/p/3877280.html">《移动前端开发之 viewport 的深入理解》</a><br>  <a href="https://www.html.cn/archives/5975">《说说移动前端中 viewport（视口）》</a><br>  <a href="https://juejin.im/post/5b6d21daf265da0f9d1a2ed7#heading-14">《移动端适配知识你到底知多少》</a></p><h4 id="53-position-fixed-在-android-下无效怎么处理？"><a href="#53-position-fixed-在-android-下无效怎么处理？" class="headerlink" title="53.position:fixed;在 android 下无效怎么处理？"></a>53.position:fixed;在 android 下无效怎么处理？</h4><p>&nbsp;&nbsp;因为移动端浏览器默认的viewport叫做layout viewport。在移动端显示时，因为layout viewport的宽度大于移动端屏幕的宽度，所以页面会出现滚动条左右移动，fixed的元素是相对layout viewport来固定位置的，而不是移动端屏幕来固定位置的，所以会出现感觉fixed无效的情况。</p><p>&nbsp;&nbsp;如果想实现fixed相对于屏幕的固定效果，我们需要改变的是viewport的大小为ideal viewport，可以如下设置：<br>&nbsp;&nbsp;<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no"/></p><h4 id="54-如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）"><a href="#54-如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）" class="headerlink" title="54.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）"></a>54.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</h4><p>&nbsp;&nbsp;多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1&#x2F;60*1000ms＝16.7ms</p><h4 id="55-如何去除-inline-block-元素间间距？"><a href="#55-如何去除-inline-block-元素间间距？" class="headerlink" title="55.如何去除 inline-block 元素间间距？"></a>55.如何去除 inline-block 元素间间距？</h4><p>&nbsp;&nbsp;移除空格、使用<code>margin负值</code>、<code>使用font-size:0</code>、<code>letter-spacing</code>、<code>word-spacing</code></p><p>详细资料可以参考：<a href="https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/">《去除 inline-block 元素间间距的 N 种方法》</a></p><h4 id="56-overflow-scroll-时不能平滑滚动的问题怎么处理？"><a href="#56-overflow-scroll-时不能平滑滚动的问题怎么处理？" class="headerlink" title="56.overflow:scroll 时不能平滑滚动的问题怎么处理？"></a>56.overflow:scroll 时不能平滑滚动的问题怎么处理？</h4><p>&nbsp;&nbsp;以下代码可解决这种卡顿的问题<code>-webkit-overflow-scrolling:touch;</code>是因为这行代码启用了硬件加速特性，所以滑动很流畅。</p><p>详细资料可以参考：<a href="https://www.jianshu.com/p/1f4693d0ad2d">《解决页面使用 overflow:scroll 在 iOS 上滑动卡顿的问题》</a></p><h4 id="57-有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度。"><a href="#57-有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度。" class="headerlink" title="57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。"></a>57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。</h4><ol><li>外层<code>div</code>使用<code>position：relative；</code>高度要求自适应的div使用<code>position:absolute;top:100px;bottom:0;left:0;right:0;</code></li><li>使用<code>flex</code>布局，设置主轴为竖轴，第二个div的<code>flex-grow</code>为1。</li></ol><p>详细资料可以参考：<a href="https://blog.csdn.net/xutongbao/article/details/79408522">《有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度(三种方案)》</a></p><h4 id="58-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？"><a href="#58-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？" class="headerlink" title="58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？"></a>58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？</h4><p><strong>相关知识点：</strong></p><ol><li><code>BMP</code>，是无损的、既支持索引色也支持直接色的、点阵图。这种图片格式几乎没有对数据进行压缩，所以<code>BMP</code>格式的图片通常具有较大的文件大小。</li><li><code>GIF</code>是无损的、采用索引色的、点阵图。采用LZW压缩算法进行编码。文件小，是<code>GIF</code>格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但<code>GIF</code>格式仅支持8bit的索引色，所以<code>GIF</code>格式适用于对色彩要求不高同时需要文件体积较小的场景。</li><li><code>JPEG</code>是有损的、采用直接色的、点阵图。<code>JPEG</code>的图片的优点，是采用了直接色，得益于更丰富的色彩，<code>JPEG</code>非常适合用来<br>存储照片，与<code>GIF</code>相比，<code>JPEG</code>不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，<br>又会导致图片文件较<code>GIF</code>更大。</li><li><code>PNG-8</code>是无损的、使用索引色的、点阵图。<code>PNG是</code>一种比较新的图片格式，<code>PNG-8</code>是非常好的<code>GIF</code>格式替代者，在可能的情况下，应该尽可能的使用<code>PNG-8</code>而不是<code>GIF</code>，因为在相同的图片效果下，<code>PNG-8</code>具有更小的文件体积。除此之外，<code>PNG-8</code>还支持透明度的调节，而<code>GIF</code>并不支持。现在，除非需要动画的支持，否则我们没有理由使用<code>GIF</code>而不是<code>PNG-8</code>。</li><li><code>PNG-24</code>是无损的、使用直接色的、点阵图。<code>PNG-24</code>的优点在于，它压缩了图片的数据，使得同样效果的图片，<code>PNG-24</code>格<br>式的文件大小要比<code>BMP</code>小得多。当然，<code>PNG24</code>的图片还是要比<code>JPEG、GIF、PNG-8</code>大得多。</li><li><code>SVG</code>是无损的、矢量图。<code>SVG</code>是矢量图。这意味着<code>SVG</code>图片由直线和曲线以及绘制它们的方法组成。当你放大一个<code>SVG</code>图片的时候，你看到的还是线和曲线，而不会出现像素点。这意味着<code>SVG</code>图片在放大时，不会失真，所以它非常适合用来绘制企业<code>Logo、Icon</code>等。</li><li><code>WebP</code>是谷歌开发的一种新图片格式，<code>WebP</code>是同时支持有损和无损压缩的、使用直接色的、点阵图。从名字就可以看出来它是为<code>Web</code>而生的，什么叫为<code>Web</code>而生呢？就是说相同质量的图片，<code>WebP</code>具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。</li></ol><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul><p>&nbsp;&nbsp;但是目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p><p><strong>回答：</strong></p><ol><li>jpeg(jpg)：支持的颜色比较丰富，不支持透明效果，不支持动图。一般用来显示照片。</li><li>gif：支持的颜色比较少，支持简单透明，支持动图。适用颜色单一的图片、动图。</li><li>png：支持的颜色丰富，支持复杂透明，不支持动图。专为网页而生。</li><li>webp：这种格式是谷歌推出的专门用来表示网页中的图片的一种格式。<br> 使用webp格式的最大的优点是，在相同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，<br> 因为图片体积的减少，意味着请求时间的减小，这样会提高用户的体验。<br> 缺点是目前在兼容性上不太好。<br> 选取图片规则：效果一样用小的，效果不一样用效果好的。</li></ol><p>详细资料可以参考：<a href="https://www.cnblogs.com/xinzhao/p/5130410.html">《图片格式那么多，哪种更适合你？》</a></p><h4 id="59-浏览器如何判断是否支持-webp-格式图片"><a href="#59-浏览器如何判断是否支持-webp-格式图片" class="headerlink" title="59.浏览器如何判断是否支持 webp 格式图片"></a>59.浏览器如何判断是否支持 webp 格式图片</h4><ol><li><p>宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格式的图片。</p></li><li><p>canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断返回值中是否含有image&#x2F;webp字段，如果包含则说明支持WebP，反之则不支持。</p></li></ol><p>详细资料可以参考：<br><a href="https://blog.csdn.net/jesslu/article/details/82495061">《判断浏览器是否支持 WebP 图片》</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toDataURL">《toDataURL()》</a></p><h4 id="60-什么是-Cookie-隔离？（或者说：请求资源的时候不要让它带-cookie-怎么做）"><a href="#60-什么是-Cookie-隔离？（或者说：请求资源的时候不要让它带-cookie-怎么做）" class="headerlink" title="60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）"></a>60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）</h4><p>&nbsp;&nbsp;网站向服务器请求的时候，会自动带上<code>cookie</code>，这样增加表头信息量，使请求变慢。</p><p>&nbsp;&nbsp;如果静态文件都放在主域名下，那静态文件请求的时候都带有的<code>cookie</code>的数据提交给<code>server</code>的，非常浪费流量，所以不如隔离开，静态资源放CDN。</p><p>&nbsp;&nbsp;因为<code>cookie</code>有域的限制，因此不能跨域提交请求，故使用非主域名的时候，请求头中就不会带有<code>cookie</code>数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。</p><p>&nbsp;&nbsp;同时这种方式不会将<code>cookie</code>传入<code>WebServer</code>，也减少了<code>WebServer</code>对<code>cookie</code>的处理分析环节，提高了<code>webserver</code>的http请求的解析速度。</p><p>详细资料可以参考：<a href="https://www.zhihu.com/question/36514327?rf=37353035">《CDN 是什么？使用 CDN 有什么优势？》</a></p><h4 id="61-style-标签写在-body-后与-body-前有什么区别？"><a href="#61-style-标签写在-body-后与-body-前有什么区别？" class="headerlink" title="61.style 标签写在 body 后与 body 前有什么区别？"></a>61.style 标签写在 body 后与 body 前有什么区别？</h4><p>&nbsp;&nbsp;页面加载自上而下当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象(即样式失效导致的页面闪烁问题(结构解析完但样式还没有解析完))</p><h4 id="62-什么是-CSS-预处理器-后处理器？"><a href="#62-什么是-CSS-预处理器-后处理器？" class="headerlink" title="62.什么是 CSS 预处理器&#x2F;后处理器？"></a>62.什么是 CSS 预处理器&#x2F;后处理器？</h4><p>&nbsp;&nbsp;<code>CSS</code>预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为<code>CSS</code>增加了一些编程的特性，将<code>CSS</code>作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，<code>CSS</code>预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的<code>CSS</code>文件。</p><p>&nbsp;&nbsp;预处理器例如：<code>LESS、Sass、Stylus</code>，用来预编译<code>Sass</code>或<code>less</code> ，增强了<code>css</code>代码的复用性，还有<code>层级、mixin、变量、循环、函数</code>等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</p><p>&nbsp;&nbsp;<code>CSS</code>后处理器是对<code>CSS</code>进行处理，并最终生成<code>CSS</code>的预处理器，它属于广义上的<code>CSS</code>预处理器。我们很久以前就在用<code>CSS</code>后处理器了，最典型的例子是<code>CSS</code>压缩工具（如<code>clean-css</code>），只不过以前没单独拿出来说过。还有最近比较火的<code>Autoprefixer</code>，以<code>CanIUse</code>上的浏览器支持数据为基础，自动处理兼容性问题。</p><p>&nbsp;&nbsp;后处理器例如：<code>PostCSS</code>，通常被视为在完成的样式表中根据<code>CSS</code>规范处理<code>CSS</code>，让其更有效；目前最常做的是给<code>CSS</code>属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p><p>详细资料可以参考：<a href="https://blog.csdn.net/yushuangyushuang/article/details/79209752">《CSS 预处理器和后处理器》</a></p><h4 id="63-阐述一下-CSS-Sprites"><a href="#63-阐述一下-CSS-Sprites" class="headerlink" title="63.阐述一下 CSS Sprites"></a>63.阐述一下 CSS Sprites</h4><p>&nbsp;&nbsp;将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的<code>background-image，background-repeat，background-position</code>的组合进行背景定位。利用<code>CSS Sprites</code>能很好地减少网页的http请求，从而很好的提高页面的性能；<code>CSS Sprites</code>能减少图片的字节。</p><p>  优点：<br>  减少HTTP请求数，极大地提高页面加载速度<br>  增加图片信息重复度，提高压缩比，减少图片大小<br>  更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</p><p>  缺点：<br>  图片合并麻烦<br>  维护麻烦，修改一个图片可能需要重新布局整个图片，样式</p><h4 id="64-使用-rem-布局的优缺点？"><a href="#64-使用-rem-布局的优缺点？" class="headerlink" title="64.使用 rem 布局的优缺点？"></a>64.使用 rem 布局的优缺点？</h4><p><strong>优点：</strong><br>&nbsp;&nbsp;在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持rem了，兼容性也非常的好。</p><p><strong>缺点：</strong></p><ol><li>在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。</li><li>使用iframe引用也会出现问题。</li><li>rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问<br>题。</li></ol><p>详细资料可以参考：<br>  <a href="https://www.zhihu.com/question/21504656">《css3 的字体大小单位 rem 到底好在哪？》</a><br>  <a href="https://www.jianshu.com/p/e8ae1c3861dc">《VW:是时候放弃 REM 布局了》</a><br>  <a href="https://blog.csdn.net/Honeymao/article/details/76795089">《为什么设计稿是 750px》</a><br>  <a href="https://github.com/amfe/article/issues/17">《使用 Flexible 实现手淘 H5 页面的终端适配》</a></p><h4 id="65-几种常见的-CSS-布局"><a href="#65-几种常见的-CSS-布局" class="headerlink" title="65.几种常见的 CSS 布局"></a>65.几种常见的 CSS 布局</h4><h5 id="圣杯布局："><a href="#圣杯布局：" class="headerlink" title="圣杯布局："></a><strong>圣杯布局</strong>：</h5><ol><li><p>比较特殊的三栏布局，同样也是<strong>两边固定宽度，中间自适应</strong>，唯一区别是dom结构必须是<strong>先写中间列部分</strong>，这样实现中间列可以优先加载。</p></li><li><p>三个部分都设定为左浮动，否则左右两边内容上不去，就不可能与中间列同一行。然后设置center的宽度为100%(**实现中间列内容自适应)**，此时，left和right部分会跳到下一行。</p></li></ol><p>  <img src="https://user-gold-cdn.xitu.io/2018/10/18/16682cae82722a6a?imageslim" alt="img"></p><ol start="3"><li>通过设置margin-left为负值让left和right部分回到与center部分同一行。</li></ol><p>  <img src="https://user-gold-cdn.xitu.io/2018/10/18/16682c1d72a1ea68?imageslim" alt="img"></p><ol start="4"><li>通过设置父容器的padding-left和padding-right，让左右两边留出间隙。</li></ol><p>  <img src="https://user-gold-cdn.xitu.io/2018/10/18/16682c473f605745?imageslim" alt="img"></p><ol start="5"><li>通过设置相对定位，让left和right部分移动到两边。</li></ol><p>  <img src="https://user-gold-cdn.xitu.io/2018/10/17/16682bf3615502c2?imageslim" alt="img"></p><h5 id="圣杯布局的缺点："><a href="#圣杯布局的缺点：" class="headerlink" title="圣杯布局的缺点："></a>圣杯布局的缺点：</h5><ul><li>center部分的最小宽度不能小于left部分的宽度，否则会left部分掉到下一行</li><li>如果其中一列内容高度拉长，其他两列的背景并不会自动填充。(借助等高布局正padding+负margin可解决，下文会介绍)</li></ul><h5 id="双飞翼布局："><a href="#双飞翼布局：" class="headerlink" title="双飞翼布局："></a>双飞翼布局：</h5><ol><li>同样也是三栏布局，在圣杯布局基础上进一步优化，解决了圣杯布局错乱问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题。</li><li>实现步骤(前两步与圣杯布局一样)<br>1. 三个部分都设定为左浮动，然后设置center的宽度为100%，此时，left和right部分会跳到下一行；<br>2. 通过设置margin-left为负值让left和right部分回到与center部分同一行；<br>3. center部分增加一个内层div，并设margin: 0 200px；</li></ol><h5 id="双飞翼布局的缺点："><a href="#双飞翼布局的缺点：" class="headerlink" title="双飞翼布局的缺点："></a><strong>双飞翼布局的缺点：</strong></h5><pre><code class="hljs"> 多加一层 dom 树节点，增加渲染树生成的计算量。</code></pre><h5 id="两种布局实现方式对比"><a href="#两种布局实现方式对比" class="headerlink" title="两种布局实现方式对比:"></a>两种布局实现方式对比:</h5><ul><li>两种布局方式都是把主列放在文档流最前面，使主列优先加载。</li><li>两种布局方式在实现上也有相同之处，都是让三列浮动，然后通过负外边距形成三列布局。</li><li>两种布局方式的不同之处在于如何处理中间主列的位置： <strong>圣杯布局是利用父容器的左、右内边距+两个从列相对定位</strong>； <strong>双飞翼布局是把主列嵌套在一个新的父级块中利用主列的左、右外边距进行布局调整</strong>。</li></ul><p>详细的资料可以参考：<a href="https://juejin.im/post/5bbcd7ff5188255c80668028#heading-12">《几种常见的 CSS 布局》</a></p><h4 id="66-画一条-0-5px-的线"><a href="#66-画一条-0-5px-的线" class="headerlink" title="66.画一条 0.5px 的线"></a>66.画一条 0.5px 的线</h4><p>&nbsp;&nbsp;采用<code>meta viewport</code>的方式<br>&nbsp;&nbsp;采用<code>border-image</code>的方式<br>&nbsp;&nbsp;&nbsp;回答时答这个就行： 采用<code>transform:scaleY()</code>的方式 &#x2F;&#x2F;注意chrome下实线变虚的问题，可以通过设置<code>transform-origin: 50% 100%</code>解决</p><p>详细资料可以参考：<a href="https://juejin.im/post/5ab65f40f265da2384408a95">《怎么画一条 0.5px 的边（更新）》</a></p><h4 id="67-transition-和-animation-的区别"><a href="#67-transition-和-animation-的区别" class="headerlink" title="67.transition 和 animation 的区别"></a>67.transition 和 animation 的区别</h4><p>&nbsp;&nbsp;<code>transition</code>关注的是<code>CSS property</code>的变化，<code>property</code>值和时间的关系是一个三次贝塞尔曲线。一般结合<code>transforms</code>使用</p><p>&nbsp;&nbsp;<code>animation</code>作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。</p><p>详细资料可以参考：<br>  <a href="https://www.zhihu.com/question/19749045">《CSSanimation 与 CSStransition 有何区别？》</a><br>  <a href="https://blog.csdn.net/cddcj/article/details/53582334">《CSS3Transition 和 Animation 区别及比较》</a><br>  <a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html">《CSS 动画简介》</a><br>  <a href="https://juejin.im/post/5b137e6e51882513ac201dfb">《CSS 动画：animation、transition、transform、translate》</a></p><h4 id="68-什么是首选最小宽度？"><a href="#68-什么是首选最小宽度？" class="headerlink" title="68.什么是首选最小宽度？"></a>68.什么是首选最小宽度？</h4><p>&nbsp;&nbsp;“首选最小宽度”，指的是元素最适合的最小宽度。</p><p>&nbsp;&nbsp;东亚文字（如中文）最小宽度为每个汉字的宽度。</p><p>&nbsp;&nbsp;西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短横线、问号以及其他非英文字符等。</p><p>&nbsp;&nbsp;如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS中的word-break:break-all。</p><h4 id="69-为什么-height-100-会无效？"><a href="#69-为什么-height-100-会无效？" class="headerlink" title="69.为什么 height:100%会无效？"></a>69.为什么 height:100%会无效？</h4><p>&nbsp;&nbsp;对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。</p><p>&nbsp;&nbsp;原因是如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto，因为解释成了auto，所以无法参与计算。</p><p>&nbsp;&nbsp;使用绝对定位的元素会有计算值，即使祖先元素的height计算为auto也是如此。</p><h4 id="70-min-width-max-width-和-min-height-max-height-属性间的覆盖规则？"><a href="#70-min-width-max-width-和-min-height-max-height-属性间的覆盖规则？" class="headerlink" title="70.min-width&#x2F;max-width 和 min-height&#x2F;max-height 属性间的覆盖规则？"></a>70.min-width&#x2F;max-width 和 min-height&#x2F;max-height 属性间的覆盖规则？</h4><ol><li><code>max-width</code>会覆盖<code>width</code>，即使<code>width</code>是行类样式或者设置了<code>!important</code>。</li><li><code>min-width</code>会覆盖<code>max-width</code>，此规则发生在<code>min-width</code>和<code>max-width</code>冲突的时候。</li></ol><h4 id="71-内联盒模型基本概念"><a href="#71-内联盒模型基本概念" class="headerlink" title="71.内联盒模型基本概念"></a>71.内联盒模型基本概念</h4><ol><li>内容区域<code>content area</code>。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子<code>character box</code>；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些元素，内容区域可以看成元素自身。</li><li>内联盒子<code>inline box</code>。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类。</li><li>行框盒子<code>line box</code>，每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。</li><li>包含块<code>containing box</code>，由一行一行的“行框盒子”组成。</li></ol><h4 id="72-什么是幽灵空白节点？"><a href="#72-什么是幽灵空白节点？" class="headerlink" title="72.什么是幽灵空白节点？"></a>72.什么是幽灵空白节点？</h4><p>&nbsp;&nbsp;“幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。</p><h4 id="73-什么是替换元素？"><a href="#73-什么是替换元素？" class="headerlink" title="73.什么是替换元素？"></a>73.什么是替换元素？</h4><p>&nbsp;&nbsp;通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。因此，<code>&lt;img&gt;、&lt;object&gt;、&lt;video&gt;、&lt;iframe&gt;</code>或者表<br>单元素<code>&lt;textarea&gt;</code>和<code>&lt;input&gt;</code>和<code>&lt;select&gt;</code>都是典型的替换元素。</p><p>替换元素除了内容可替换这一特性以外，还有以下一些特性。</p><ol><li><p>内容的外观不受页面上的CSS的影响。用专业的话讲就是样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似<code>appearance</code>属性，或者浏览器自身暴露的一些样式接口，</p></li><li><p>有自己的尺寸。在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如<code>&lt;video&gt;、&lt;iframe&gt;</code>或者<code>&lt;canvas&gt;</code>等，也有少部分替换元素为<code>0</code>像素，如<code>&lt;img&gt;</code>图片，而表单元素的替换元素的尺寸则和浏览器有关，没有明显的规律。</p></li><li><p>在很多CSS属性上有自己的一套表现规则。比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，<code>vertical-align</code>属性值的解释是不一样的。比方说<code>vertical-align</code>的默认值的<code>baseline</code>，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</p></li><li><p>所有的替换元素都是内联水平元素，也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的<code>display</code>值却是不一样的，有的是<code>inline</code>，有的是<code>inline-block</code>。</p></li></ol><h4 id="74-替换元素的计算规则？"><a href="#74-替换元素的计算规则？" class="headerlink" title="74.替换元素的计算规则？"></a>74.替换元素的计算规则？</h4><p>替换元素的尺寸从内而外分为3类：固有尺寸、HTML尺寸和CSS尺寸。</p><ol><li>固有尺寸指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</li><li>HTML尺寸只能通过HTML原生属性改变，这些HTML原生属性包括<code>&lt;img&gt;</code>的<code>width</code>和<code>height</code>属性、<code>&lt;input&gt;</code>的<code>size</code>属性、<code>&lt;textarea&gt;</code>的<code>cols</code>和<code>rows</code>属性等。</li><li>CSS尺寸特指可以通过CSS的<code>width</code>和<code>height</code>或者<code>max-width/min-width</code>和<code>max-height/min-height</code>设置的尺寸，对应盒尺寸中的<code>content box</code>。</li></ol><p>这3层结构的计算规则具体如下: (简单理解为：固有尺寸、HTML尺寸和CSS尺寸优先级依次递增。)</p><ol><li>如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。</li><li>如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。</li><li>如果有CSS尺寸，则最终尺寸由CSS属性决定。</li><li>如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。</li><li>如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。</li><li>内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</li></ol><h4 id="75-content-与替换元素的关系？"><a href="#75-content-与替换元素的关系？" class="headerlink" title="75.content 与替换元素的关系？"></a>75.content 与替换元素的关系？</h4><p><code>content</code>属性生成的对象称为“匿名替换元素”。</p><ol><li>我们使用<code>content</code>生成的文本是无法选中、无法复制的，好像设置了<code>user select:none</code>声明一般，但是普通元素的文本却可以被轻松选中。同时，<code>content</code>生成的文本无法被屏幕阅读设备读取，也无法被搜索引擎抓取，因此，千万不要自以为是地把重要的文本信息使用<code>content</code>属性生成，因为这对可访问性和SEO都很不友好。</li><li><code>content</code>生成的内容不能左右<code>:empty</code>伪类。</li><li><code>content</code>动态生成值无法获取。</li></ol><h4 id="76-margin-auto-的填充规则？"><a href="#76-margin-auto-的填充规则？" class="headerlink" title="76.margin:auto 的填充规则？"></a>76.margin:auto 的填充规则？</h4><p>&nbsp;&nbsp;<code>margin</code>的<code>auto</code>可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发<code>margin:auto</code>计算有一个前提条件，就是<code>width</code>或<code>height</code>为<code>auto</code>时，元素是具有对应方向的自动填充特性的。</p><ol><li>如果一侧定值，一侧<code>auto</code>，则<code>auto</code>为剩余空间大小。</li><li>如果两侧均是<code>auto</code>，则平分剩余空间。</li></ol><h4 id="77-margin-无效的情形"><a href="#77-margin-无效的情形" class="headerlink" title="77.margin 无效的情形"></a>77.margin 无效的情形</h4><ol><li><p><code>display</code>计算值<code>inline</code>的非替换元素的垂直<code>margin</code>是无效的。对于内联替换元素，垂直<code>margin</code>有效，并且没有<code>margin</code>合并的问题。</p></li><li><p>表格中的<code>&lt;tr&gt;</code>和<code>&lt;td&gt;</code>元素或者设置<code>display</code>计算值是<code>table-cell</code>或<code>table-row</code>的元素的<code>margin</code>都是无效的。</p></li><li><p>绝对定位元素非定位方位的<code>margin</code>值“无效”。</p></li><li><p>定高容器的子元素的<code>margin-bottom</code>或者宽度定死的子元素的<code>margin-right</code>的定位“失效”。</p></li></ol><h4 id="78-border-的特殊性？"><a href="#78-border-的特殊性？" class="headerlink" title="78.border 的特殊性？"></a>78.border 的特殊性？</h4><ol><li><code>border-width</code>却不支持百分比。</li><li><code>border-style</code>的默认值是<code>none</code>，有一部分人可能会误以为是<code>solid</code>。这也是单纯设置<code>border-width</code>或<code>border-color</code>没有边框显示的原因。</li><li><code>border-style:double</code>的表现规则：双线宽度永远相等，中间间隔±1。</li><li><code>border-color</code>默认颜色就是<code>color</code>色值。</li><li>默认<code>background</code>背景图片是相对于<code>padding box</code>定位的。</li></ol><h4 id="79-什么是基线和-x-height？"><a href="#79-什么是基线和-x-height？" class="headerlink" title="79.什么是基线和 x-height？"></a>79.什么是基线和 x-height？</h4><p>&nbsp;&nbsp;字母x的下边缘（线）就是我们的基线。</p><p>&nbsp;&nbsp;x-height指的就是小写字母x的高度，术语描述就是基线和等分线（meanline）（也称作中线，midline）之间的距离。在CSS世界中，middle指的是基线往上1&#x2F;2x-height高度。我们可以近似理解为字母x交叉点那个位置。</p><p>&nbsp;&nbsp;ex是CSS中的一个相对单位，指的是小写字母x的高度，没错，就是指x-height。ex的价值就在其副业上不受字体和字号影响的内联元素的垂直居中对齐效果。内联元素默认是基线对齐的，而基线就是x的底部，而1ex就是一个x的高度。</p><h4 id="80-line-height-的特殊性？"><a href="#80-line-height-的特殊性？" class="headerlink" title="80.line-height 的特殊性？"></a>80.line-height 的特殊性？</h4><ol><li>对于非替换元素的纯内联元素，其可视高度完全由line-height决定。对于文本这样的纯内联元素，line-height就是高度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。</li><li>内联元素的高度由固定高度和不固定高度组成，这个不固定的部分就是这里的“行距”。换句话说，line-height之所以起作用，就是通过改变“行距”来实现的。在CSS中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”。</li><li>行距 &#x3D; line-height - font-size。</li><li>border以及line-height等传统CSS属性并没有小数像素的概念。如果标注的是文字上边距，则向下取整；如果是文字下边距，则向上取整。</li><li>对于纯文本元素，line-height直接决定了最终的高度。但是，如果同时有替换元素，则line-height只能决定最小高度。</li><li>对于块级元素，line-height对其本身是没有任何作用的，我们平时改变line-height，块级元素的高度跟着变化实际上是通过改变块级元素里面内联级别元素占据的高度实现的。</li><li>line-height的默认值是normal，还支持数值、百分比值以及长度值。为数值类型时，其最终的计算值是和当前font-size相乘后的值。为百分比值时，其最终的计算值是和当前font-size相乘后的值。为长度值时原意不变。</li><li>如果使用数值作为line-height的属性值，那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值。</li><li>无论内联元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定的。</li><li>只要有“内联盒子”在，就一定会有“行框盒子”，就是每一行内联元素外面包裹的一层看不见的盒子。然后，重点来了，在每个“行框盒子”前面有一个宽度为0的具有该元素的字体和行高属性的看不见的“幽灵空白节点”。</li></ol><h4 id="81-vertical-align-的特殊性？"><a href="#81-vertical-align-的特殊性？" class="headerlink" title="81.vertical-align 的特殊性？"></a>81.vertical-align 的特殊性？</h4><ol><li><code>vertical-align</code>的默认值是<code>baseline</code>，即基线对齐，而基线的定义是字母x的下边缘。因此，内联元素默认都是沿着字母x的下边缘对齐的。对于图片等替换元素，往往使用元素本身的下边缘作为基线。：一个<code>inline-block</code>元素，如果里面没有内联元素，或者<code>overflow</code>不是<code>visible</code>，则该元素的基线就是其<code>margin</code>底边缘；否则其基线就是元素里面最后一行内联元素的基线。</li><li><code>vertical-align:top</code>就是垂直上边缘对齐，如果是内联元素，则和这一行位置最高的内联元素的顶部对齐；如果<code>display</code>计算值是<code>table-cell</code>的元素，我们不妨脑补成<code>&lt;td&gt;</code>元素，则和<code>&lt;tr&gt;</code>元素上边缘对齐。</li><li><code>vertical-align:middle</code>是中间对齐，对于内联元素，元素的垂直中心点和行框盒子基线往上<code>1/2x-height</code>处对齐。对于<code>table-cell</code>元素，单元格填充盒子相对于外面的表格行居中对齐。</li><li><code>vertical-align</code>支持数值属性，根据数值的不同，相对于基线往上或往下偏移，如果是负值，往下偏移，如果是正值，往上偏移。</li><li><code>vertical-align</code>属性的百分比值则是相对于<code>line-height</code>的计算值计算的。</li><li><code>vertical-align</code>起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及<code>display</code>值为<code>table-cell</code>的元素。</li><li><code>table-cell</code>元素设置<code>vertical-align</code>垂直对齐的是子元素，但是其作用的并不是子元素，而是<code>table-cell</code>元素自身。</li></ol><h4 id="82-overflow-的特殊性？"><a href="#82-overflow-的特殊性？" class="headerlink" title="82.overflow 的特殊性？"></a>82.overflow 的特殊性？</h4><ol><li>一个设置了<code>overflow:hidden</code>声明的元素，假设同时存在<code>border</code>属性和<code>padding</code>属性，则当子元素内容超出容器宽度高度限制的时候，剪裁的边界是<code>border box</code>的内边缘，而非<code>padding box</code>的内边缘。</li><li><code>HTML</code>中有两个标签是默认可以产生滚动条的，一个是根元素<code>&lt;html&gt;</code>，另一个是文本域<code>&lt;textarea&gt;</code>。</li><li>滚动条会占用容器的可用宽度或高度。</li><li>元素设置了<code>overflow:hidden</code>声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！</li></ol><h4 id="83-无依赖绝对定位是什么？"><a href="#83-无依赖绝对定位是什么？" class="headerlink" title="83.无依赖绝对定位是什么？"></a>83.无依赖绝对定位是什么？</h4><p>没有设置<code>left/top/right/bottom</code>属性值的绝对定位称为“无依赖绝对定位”。</p><p>无依赖绝对定位其定位的位置和没有设置<code>position:absolute</code>时候的位置相关。</p><h4 id="84-absolute-与-overflow-的关系？"><a href="#84-absolute-与-overflow-的关系？" class="headerlink" title="84.absolute 与 overflow 的关系？"></a>84.absolute 与 overflow 的关系？</h4><ol><li>如果<code>overflow</code>不是定位元素，同时绝对定位元素和<code>overflow</code>容器之间也没有定位元素，则<code>overflow</code>无法对<code>absolute</code>元素进行剪裁。</li><li>如果<code>overflow</code>的属性值不是<code>hidden</code>而是<code>auto</code>或者<code>scroll</code>，即使绝对定位元素高宽比<code>overflow</code>元素高宽还要大，也都不会出现滚动条。</li><li><code>overflow</code>元素自身<code>transform</code>的时候，<code>Chrome和Opera</code>浏览器下的<code>overflow</code>剪裁是无效的。</li></ol><h4 id="85-clip-裁剪是什么？"><a href="#85-clip-裁剪是什么？" class="headerlink" title="85.clip 裁剪是什么？"></a>85.clip 裁剪是什么？</h4><p>&nbsp;&nbsp;所谓“可访问性隐藏”，指的是虽然内容肉眼看不见，但是其他辅助设备却能够进行识别和访问的隐藏。<br>&nbsp;&nbsp;clip剪裁被我称为“最佳可访问性隐藏”的另外一个原因就是，它具有更强的普遍适应性，任何元素、任何场景都可以无障碍使用。</p><h4 id="86-relative-的特殊性？"><a href="#86-relative-的特殊性？" class="headerlink" title="86.relative 的特殊性？"></a>86.relative 的特殊性？</h4><ol><li>相对定位元素的<code>left/top/right/bottom</code>的百分比值是相对于包含块计算的，而不是自身。注意，虽然定位位移是相对自身，但是百分比值的计算值不是。</li><li><code>top</code>和<code>bottom</code>这两个垂直方向的百分比值计算跟<code>height</code>的百分比值是一样的，都是相对高度计算的。同时，如果包含块的高度是auto，那么计算值是0，偏移无效，也就是说，如果父元素没有设定高度或者不是“格式化高度”，那么<code>relative</code>类似<code>top:20%</code>的代码等同于<code>top:0</code>。</li><li>当相对定位元素同时应用对立方向定位值的时候，也就是<code>top/bottom</code>和<code>left/right</code>同时使用的时候，只有一个方向的定位属性会起作用。而谁起作用则是与文档流的顺序有关的，默认的文档流是自上而下、从左往右，因此<code>top/bottom</code>同时使用的时候，<code>bottom</code>失效；<code>left/right</code>同时使用的时候，<code>right</code>失效。</li></ol><h4 id="87-什么是层叠上下文？"><a href="#87-什么是层叠上下文？" class="headerlink" title="87.什么是层叠上下文？"></a>87.什么是层叠上下文？</h4><p>&nbsp;&nbsp;层叠上下文，英文称作stacking context，是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元素在z轴上就“高人一等”。</p><p><strong>层叠上下文元素有如下特性：</strong></p><ol><li>层叠上下文的层叠水平要比普通元素高（原因后面会说明）。</li><li>层叠上下文可以阻断元素的混合模式。</li><li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。</li><li>每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。</li><li>每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</li></ol><p><strong>层叠上下文的创建：</strong></p><ol><li>页面根元素天生具有层叠上下文，称为根层叠上下文。根层叠上下文指的是页面根元素，可以看成是<code>&lt;html&gt;</code>元素。因此，页面中所有的元素一定处于至少一个“层叠结界”中。</li><li>对于<code>position</code>值为<code>relative/absolute</code>以及Firefox&#x2F;IE浏览器（不包括Chrome浏览器）下含有<code>position:fixed</code>声明的定位元素，当其<code>z-index</code>值不是<code>auto</code>的时候，会创建层叠上下文。<code>Chrome</code>等<code>WebKit</code>内核浏览器下，<code>position:fixed</code>元素天然层叠上下文元素，无须<code>z-index</code>为数值。根据我的测试，目前<code>IE和Firefox</code>仍是老套路。</li><li>其他一些<code>CSS3</code>属性，比如元素的<code>opacity</code>值不是1。</li></ol><h4 id="88-什么是层叠水平？"><a href="#88-什么是层叠水平？" class="headerlink" title="88.什么是层叠水平？"></a>88.什么是层叠水平？</h4><p>&nbsp;&nbsp;层叠水平，英文称作<code>stacking level</code>，决定了同一个层叠上下文中元素在z轴上的显示顺序。</p><p>&nbsp;&nbsp;显而易见，所有的元素都有层叠水平，包括层叠上下文元素，也包括普通元素。然而，对普通元素的层叠水平探讨只局限在当前层叠上下文元素中。</p><h4 id="89-元素的层叠顺序？"><a href="#89-元素的层叠顺序？" class="headerlink" title="89.元素的层叠顺序？"></a>89.元素的层叠顺序？</h4><p>&nbsp;&nbsp;层叠顺序，英文称作 <code>stacking order</code>，表示元素发生层叠时有着特定的垂直显示顺序。<br>&nbsp;&nbsp;<img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-15.png" alt="层叠顺序"></p><h4 id="90-层叠准则？"><a href="#90-层叠准则？" class="headerlink" title="90.层叠准则？"></a>90.层叠准则？</h4><ol><li><strong>谁大谁上：</strong> 当具有明显的层叠水平标识的时候，如生效的z-index属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。</li><li><strong>后来居上：</strong> 当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</li></ol><h4 id="91-font-weight-的特殊性？"><a href="#91-font-weight-的特殊性？" class="headerlink" title="91.font-weight 的特殊性？"></a>91.font-weight 的特殊性？</h4><p>&nbsp;&nbsp;如果使用数值作为<code>font-weight</code>属性值，必须是<code>100～900</code>的整百数。因为这里的数值仅仅是外表长得像数值，实际上是一个具有特定含义的关键字，并且这里的数值关键字和字母关键字之间是有对应关系的。一般使用<code>font-weight: bold</code>来加粗。\</p><h4 id="92-text-indent-的特殊性？"><a href="#92-text-indent-的特殊性？" class="headerlink" title="92.text-indent 的特殊性？"></a>92.text-indent 的特殊性？</h4><ol><li><code>text-indent</code>仅对第一行内联盒子内容有效。</li><li>非替换元素以外的<code>display</code>计算值为<code>inlin</code>e的内联元素设置<code>text-indent</code>值无效，如果计算值<code>inline-block/inline-table</code>则会生效。</li><li><code>&lt;input&gt;</code>标签按钮<code>text-indent</code>值无效。</li><li><code>&lt;button&gt;</code>标签按钮<code>text-indent</code>值有效。</li><li><code>text-indent</code>的百分比值是相对于当前元素的“包含块”计算的，而不是当前元素。</li></ol><h4 id="93-letter-spacing-与字符间距？"><a href="#93-letter-spacing-与字符间距？" class="headerlink" title="93.letter-spacing 与字符间距？"></a>93.letter-spacing 与字符间距？</h4><p><code>letter-spacing</code>可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。</p><p><code>letter-spacing</code>具有以下一些特性:</p><ol><li>继承性。</li><li>默认值是normal而不是0。虽然说正常情况下，normal的计算值就是0，但两者还是有差别的，在有些场景下，letter-spacing会调整normal的计算值以实现更好的版面布局。</li><li>支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。</li><li>和text-indent属性一样，无论值多大或多小，第一行一定会保留至少一个字符。</li><li>支持小数值，即使0.1px也是支持的。</li><li>暂不支持百分比值。</li></ol><h4 id="94-word-spacing-与单词间距？"><a href="#94-word-spacing-与单词间距？" class="headerlink" title="94.word-spacing 与单词间距？"></a>94.word-spacing 与单词间距？</h4><p>&nbsp;&nbsp;<code>letter-spacing</code>作用于所有字符，但<code>word-spacing</code>仅作用于空格字符。换句话说，<code>word-spacing</code>的作用就是增加空格的间隙宽度。</p><h4 id="95-white-space-与换行和空格的控制？"><a href="#95-white-space-与换行和空格的控制？" class="headerlink" title="95.white-space 与换行和空格的控制？"></a>95.white-space 与换行和空格的控制？</h4><p>&nbsp;&nbsp;<code>white-space</code>属性声明了如何处理元素内的空白字符，这类空白字符包括<code>Space(空格键)、Enter(回车键)、Tab(制表符键)</code>产生的空白。因此，<code>white-space</code>可以决定图文内容是否在一行显示(回车空格是否生效)，是否显示大段连续空白(空格是否生效)等。</p><p>其属性值包括下面这些:</p><ul><li><strong>normal：</strong> 合并空白字符和换行符。</li><li><strong>pre：</strong> 空白字符不合并，并且内容只在有换行符的地方换行。</li><li><strong>nowrap：</strong> 该值和normal一样会合并空白字符，但不允许文本环绕。</li><li><strong>pre-wrap：</strong> 空白字符不合并，并且内容只在有换行符的地方换行，同时允许文本环绕。</li><li><strong>pre-line：</strong> 合并空白字符，但只在有换行符的地方换行，允许文本环绕。</li></ul><h4 id="96-隐藏元素的-background-image-到底加不加载？"><a href="#96-隐藏元素的-background-image-到底加不加载？" class="headerlink" title="96.隐藏元素的 background-image 到底加不加载？"></a>96.隐藏元素的 background-image 到底加不加载？</h4><p><strong>相关知识点：</strong></p><ul><li>根据测试，一个元素如果display计算值为none，在IE浏览器下（IE8～IE11，更高版本不确定）依然会发送图片请求，Firefox浏览器不会，至于Chrome和Safari浏览器则似乎更加智能一点：如果隐藏元素同时又设置了background-image，则图片依然会去加载；如果是父元素的display计算值为none，则背景图不会请求，此时浏览器或许放心地认为这个背景图暂时是不会使用的。</li><li>如果不是background-image，而是<img>元素，则设置display:none在所有浏览器下依旧都会请求图片资源。</li><li>还需要注意的是如果设置的样式没有对应的元素，则background-image也不会加载。hover情况下的background-image，在触发时加载。</li></ul><p><strong>回答：</strong></p><ol><li>元素的背景图片<br>- 元素本身设置 display:none，会请求图片 -父级元素设置 display:none，不会请求图片 -样式没有元素使用，不会请求<br>- :hover 样式下，触发时请求</li><li>img 标签图片任何情况下都会请求图片</li></ol><p>详细资料可以参考：<a href="https://www.jb51.net/css/469033.html">《CSS 控制前端图片 HTTP 请求的各种情况示例》</a></p><h4 id="97-如何实现单行／多行文本溢出的省略（…）？"><a href="#97-如何实现单行／多行文本溢出的省略（…）？" class="headerlink" title="97.如何实现单行／多行文本溢出的省略（…）？"></a>97.如何实现单行／多行文本溢出的省略（…）？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*单行文本溢出*/</span><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">text-overflow</span>: ellipsis;<br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>&#125;<br><br><span class="hljs-comment">/*多行文本溢出*/</span><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5em</span>;<br>  <span class="hljs-comment">/*高度为需要显示的行数*行高，比如这里我们显示两行，则为3*/</span><br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">3em</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;...&#x27;</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br>  <a href="https://zhuanlan.zhihu.com/p/30707916">《【CSS&#x2F;JS】如何实现单行／多行文本溢出的省略》</a><br>  <a href="https://juejin.im/entry/587f453e1b69e60058555a5f">《CSS 多行文本溢出省略显示》</a></p><h4 id="98-常见的元素隐藏方式？"><a href="#98-常见的元素隐藏方式？" class="headerlink" title="98.常见的元素隐藏方式？"></a>98.常见的元素隐藏方式？</h4><ol><li>使用 <code>display:none;</code>隐藏元素，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li><li>使用 <code>visibility:hidden;</code>隐藏元素。元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li><li>使用 <code>opacity:0;</code>将元素的不透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li><li>通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li><li>通过 <code>z-index</code> 负值，来使其他元素遮盖住该元素，以此来实现隐藏。</li><li>通过 <code>clip/clip-path</code> 元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li><li>通过 <code>transform:scale(0,0)</code>来将元素缩放为 0，以此来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li></ol><p>详细资料可以参考：<a href="https://juejin.im/post/584b645a128fe10058a0d625#heading-2">《CSS 隐藏元素的八种方法》</a></p><h4 id="99-css-实现上下固定中间自适应布局？"><a href="#99-css-实现上下固定中间自适应布局？" class="headerlink" title="99.css 实现上下固定中间自适应布局？"></a>99.css 实现上下固定中间自适应布局？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 利用绝对定位实现 */</span><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.header</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: red;<br>&#125;<br><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">background</span>: green;<br>&#125;<br><br><span class="hljs-selector-class">.footer</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">background</span>: red;<br>&#125;<br><br><span class="hljs-comment">/* 利用flex布局实现 */</span><br><span class="hljs-selector-tag">html</span>,<br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">flex-direction</span>: column;<br>&#125;<br><br><span class="hljs-selector-class">.header</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: red;<br>&#125;<br><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: green;<br>&#125;<br><br><span class="hljs-selector-class">.footer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://www.jianshu.com/p/30bc9751e3e8">《css 实现上下固定中间自适应布局》</a></p><h4 id="100-css-两栏布局的实现？"><a href="#100-css-两栏布局的实现？" class="headerlink" title="100.css 两栏布局的实现？"></a>100.css 两栏布局的实现？</h4><p><strong>相关资料：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。*/</span><br><span class="hljs-comment">/*以左边宽度固定为200px为例*/</span><br><br><span class="hljs-comment">/*（1）利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: auto;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-comment">/*（2）第二种是利用flex布局，将左边元素宽度设置为200px。将右边的元素的放大比例设置为1。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br><br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<br><br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-comment">/*（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为absolute定位，并且宽度设置为</span><br><span class="hljs-comment">200px。将右边元素的margin-left的值设置为200px。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br><br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-comment">/*（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br><br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br><br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="http://cavszhouyou.top/Demo-Display/TwoColumnLayout/index.html">《两栏布局 demo 展示》</a></p><p><strong>回答：</strong></p><p>两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。</p><p>以左边宽度固定为 200px 为例:</p><ol><li>利用浮动，将左边元素宽度设置为 200px，并且设置向左浮动。将右边元素的 margin-left 设置为 200px，宽度设置为 auto（默认为 auto，撑满整个父元素）。</li><li>第二种是利用flex布局，将左边元素宽度设置为200px。将右边的元素的放大比例设置为1。</li><li>第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为 absolute 定位，并且宽度设置为 200px。将右边元素的 margin-left 的值设置为 200px。</li><li>第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为 200px，右边元素设置为绝对定位，左边定位为 200px，其余方向定位为 0。</li></ol><h4 id="101-css-三栏布局的实现？"><a href="#101-css-三栏布局的实现？" class="headerlink" title="101.css 三栏布局的实现？"></a>101.css 三栏布局的实现？</h4><p>相关资料：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">这里以左边宽度固定为100px，右边宽度固定为200px为例。*/</span><br><br><span class="hljs-comment">/*（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-comment">/*（2）利用flex布局的方式，左右两栏的宽度分别设置为100px和200px，中间一栏增长系数设置为1*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-comment">/*（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-comment">/*（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。*/</span><br><span class="hljs-selector-class">.outer</span>&#123;<br>  <span class="hljs-comment">/*  为左右栏腾出空间  */</span><br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">100px</span>;  <br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">200px</span>; <br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.center</span>&#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: orange;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-comment">/*（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元</span><br><span class="hljs-comment">素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。*/</span><br><br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="http://cavszhouyou.top/Demo-Display/ThreeColumnLayout/index.html">《三栏布局 demo 展示》</a></p><p><strong>回答：</strong></p><p>三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。</p><p>这里以左边宽度固定为100px，右边宽度固定为200px为例:</p><ol><li>利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</li><li>利用flex布局的方式，左右两栏的宽度分别设置为100px和200px，中间一栏增长系数设置为1</li><li>利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。</li><li>圣杯布局，利用浮动和负边距来实现。父级元素设置左右的padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置margin负值将其移动到上一行，再利用相对定位，定位到两边。圣杯布局中间列的宽度不能小于左边列的宽度，否则左边列上不去，而双飞翼布局则不存在这个问题。</li><li>双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的margin值来实现的，而不是通过父元素的padding来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</li></ol><h4 id="102-实现一个宽高自适应的正方形"><a href="#102-实现一个宽高自适应的正方形" class="headerlink" title="102.实现一个宽高自适应的正方形"></a>102.实现一个宽高自适应的正方形</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*1.第一种方式是利用vw来实现*/</span><br><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">10vw</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">10vw</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-comment">/*2.第二种方式是利用元素的margin/padding百分比是相对父元素width的性质来实现*/</span><br><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">20%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">20%</span>;<br>  <span class="hljs-attribute">background</span>: orange;<br>&#125;<br><br><span class="hljs-comment">/*3.第三种方式是利用子元素的margin-top的值来实现的*/</span><br><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">30%</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br><br><span class="hljs-selector-class">.square</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="http://cavszhouyou.top/Demo-Display/AdaptiveSquare/index.html">《自适应正方形 demo 展示》</a></p><h4 id="103-实现一个三角形"><a href="#103-实现一个三角形" class="headerlink" title="103.实现一个三角形"></a>103.实现一个三角形</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*三角形的实现原理是利用了元素边框连接处的等分原理。*/</span><br><span class="hljs-selector-class">.triangle</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">border-width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">border-style</span>: solid;<br>  <span class="hljs-attribute">border-color</span>: transparent transparent tomato;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="http://cavszhouyou.top/Demo-Display/Triangle/index.html">《三角形 demo 展示》</a></p><h4 id="104-一个自适应矩形，水平垂直居中，且宽高比为-2-1"><a href="#104-一个自适应矩形，水平垂直居中，且宽高比为-2-1" class="headerlink" title="104.一个自适应矩形，水平垂直居中，且宽高比为 2:1"></a>104.一个自适应矩形，水平垂直居中，且宽高比为 2:1</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*实现原理参考自适应正方形和水平居中方式*/</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: auto;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">20%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">10vw</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="105-你知道-CSS-中不同属性设置为百分比-时对应的计算基准？"><a href="#105-你知道-CSS-中不同属性设置为百分比-时对应的计算基准？" class="headerlink" title="105.你知道 CSS 中不同属性设置为百分比%时对应的计算基准？"></a>105.你知道 CSS 中不同属性设置为百分比%时对应的计算基准？</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino">公式：当前元素某CSS属性值 = 基准 * 对应的百分比<br>元素的 position 为 relative 和 absolute 时，top和bottom、left和right基准分别为包含块的 height、width<br>元素的 position 为 fixed 时，top和bottom、left和right基准分别为初始包含块（也就是视口）的 height、width，移动设备较为复杂，基准为 Layout viewport 的 height、width<br>元素的 height 和 width 设置为百分比时，基准分别为包含块的 height 和 width<br>元素的 margin 和 padding 设置为百分比时，基准为包含块的 width（易错）<br>元素的 border-width，不支持百分比<br>元素的 text-indent，基准为包含块的 width<br><br>元素的 border-radius，基准为分别为自身的height、width<br>元素的 background-size，基准为分别为自身的height、width<br>元素的 translateX、translateY，基准为分别为自身的height、width<br>元素的 line-height，基准为自身的 font-size<br><br>元素的 font-size，基准为父元素字体<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML总结</title>
    <link href="/2023/11/16/HTML%E6%80%BB%E7%BB%93/"/>
    <url>/2023/11/16/HTML%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="HTML-面试知识点总结"><a href="#HTML-面试知识点总结" class="headerlink" title="HTML 面试知识点总结"></a>HTML 面试知识点总结</h3><h4 id="1-DOCTYPE的作用是什么"><a href="#1-DOCTYPE的作用是什么" class="headerlink" title="1. DOCTYPE的作用是什么"></a>1. DOCTYPE的作用是什么</h4><p>相关知识点: </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的。<br><br>&lt;!DOCTYPE&gt;声明位于 HTML文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。<br><br>DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。<br></code></pre></td></tr></table></figure><p>回答(参考1-5)：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;!DOCTYPE&gt;  声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。<br><br>在 html5 之后不再需要指定 DTD 文档，因为 html5 以前的 html 文档都是基于 SGML 的，所以需要通过指定 DTD 来定义文档中允许的属性以及一些规则。而 html5 不再基于 SGML 了，所以不再需要使用 DTD。<br></code></pre></td></tr></table></figure><h4 id="2-标准模式与兼容模式有什么区别"><a href="#2-标准模式与兼容模式有什么区别" class="headerlink" title="2. 标准模式与兼容模式有什么区别?"></a>2. 标准模式与兼容模式有什么区别?</h4><p>&nbsp;&nbsp;标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</p><h4 id="3-HEML为什么只需写-，而无需引入DTD"><a href="#3-HEML为什么只需写-，而无需引入DTD" class="headerlink" title="3. HEML为什么只需写 ，而无需引入DTD"></a>3. HEML为什么只需写 <!DOCTYPE HTML>，而无需引入DTD</h4><p>&nbsp;&nbsp;HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行(让浏览器按照它们应该的方式来运行)。而 HTML4.01 基于 SGML ，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。</p><h4 id="4-SGML-、-HTML-、XML-和-XHTML-的区别？"><a href="#4-SGML-、-HTML-、XML-和-XHTML-的区别？" class="headerlink" title="4. SGML 、 HTML 、XML 和 XHTML 的区别？"></a>4. SGML 、 HTML 、XML 和 XHTML 的区别？</h4><p>&nbsp;&nbsp;SGML 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。<br>&nbsp;&nbsp;HTML 是超文本标记语言，主要是用于规定怎么显示网页。<br>&nbsp;&nbsp;XML 是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，而 HTML 的标签都是固定的而且数量有限。<br>&nbsp;&nbsp;XHTML 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML 更严格，比如标签必须都用小写，标签都必须有闭合标签等。</p><h4 id="5-DTD-介绍"><a href="#5-DTD-介绍" class="headerlink" title="5. DTD 介绍"></a>5. DTD 介绍</h4><p>&nbsp;&nbsp;DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML 或 HTML 的特定版本中所有允许元素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。<br>&nbsp;&nbsp;DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式(工作模式)。</p><h4 id="6-行内元素定义"><a href="#6-行内元素定义" class="headerlink" title="6. 行内元素定义"></a>6. 行内元素定义</h4><p>&nbsp;&nbsp;HTML4 中，元素被分成两大类: inline （内联元素）与 block（块级元素）。一个行内元素只占据它对应标签的边框所包含的空间。<br>&nbsp;&nbsp;常见的行内元素有 <strong>a b span img strong sub sup button input label select textarea</strong></p><h4 id="7-块级元素定义"><a href="#7-块级元素定义" class="headerlink" title="7. 块级元素定义"></a>7. 块级元素定义</h4><p>&nbsp;&nbsp;块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。<br>&nbsp;&nbsp;常见的块级元素有<strong>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</strong></p><h4 id="8-行内元素与块级元素的区别？"><a href="#8-行内元素与块级元素的区别？" class="headerlink" title="8. 行内元素与块级元素的区别？"></a>8. 行内元素与块级元素的区别？</h4><p>HTML4中，元素被分成两大类：inline （内联元素）与 block （块级元素）。</p><ol><li>格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。</li><li>内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。</li><li>行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素不支持设置宽高；行内元素支持水平方向的padding、border、margin；</li><li>行内元素可以设置垂直方向的padding、border、margin，但是不会影响布局。</li></ol><h4 id="9-HTML5-元素的分类"><a href="#9-HTML5-元素的分类" class="headerlink" title="9. HTML5 元素的分类"></a>9. HTML5 元素的分类</h4><p>&nbsp;&nbsp;HTML4中，元素被分成两大类: inline（内联元素）与 block（块级元素）。但在实际的开发过程中，因为页面表现的需要，前端工程师经常把 inline 元素的 display 值设定为 block （比如 a 标签），也经常把 block 元素的display 值设定为inline 之后更是出现了 inline-block 这一对外呈现 inline 对内呈现 block 的属性。因此，简单地把 HTML 元素划分为inline 与 block 已经不再符合实际需求。</p><p>HTML5中，元素主要分为7类：Metadata Flow Sectioning Heading Phrasing Embedded Interactive。</p><ul><li>Metadata（元数据型）：位于head中，决定其他内容的样式或行为。包括：<code>&lt;meta&gt; &lt;link&gt; &lt;title&gt;</code>等</li><li>Flow（文档流型）：大部分文档body内的元素</li><li>Sectioning（区块型）：定义区块内容范围的元素</li><li>Heading（标题型）：定义节的标题。包括<code>&lt;hgroup&gt; &lt;h1&gt;-&lt;h6&gt;</code></li><li>Phrasing（语句型）: 包含许多HTML4中的inline层次的元素。包括<code>&lt;span&gt; &lt;img&gt; &lt;sub&gt; &lt;sup&gt;</code>等</li><li>Embedded（内嵌型）：将其他资源导入（嵌入）到文档中。 包括<code>&lt;audio&gt; &lt;video&gt; &lt;canvas&gt;</code>等</li><li>Interactive（交互型）：专门用来与用户交互。包括<code>&lt;input&gt; &lt;a&gt; &lt;select&gt;</code>等</li></ul><h4 id="10-空元素定义"><a href="#10-空元素定义" class="headerlink" title="10. 空元素定义"></a>10. 空元素定义</h4><p>标签内没有内容的 HTML 标签被称为空元素。空元素是在开始标签中关闭的。<br>常见的空元素有：<code>br hr img input link meta</code></p><h4 id="11-link-标签定义"><a href="#11-link-标签定义" class="headerlink" title="11. link 标签定义"></a>11. link 标签定义</h4><p>link 标签定义文档与外部资源的关系。<br>link 元素是空元素，它仅包含属性。 此元素只能存在于 head 部分，不过它可出现任何次数。<br>link 标签中的 rel 属性定义了当前文档与被链接文档之间的关系。常见的 stylesheet 指的是定义一个外部加载的样式表。</p><h4 id="12-页面导入样式时，使用-link-和-import-有什么区别？"><a href="#12-页面导入样式时，使用-link-和-import-有什么区别？" class="headerlink" title="12. 页面导入样式时，使用 link 和 @import 有什么区别？"></a>12. 页面导入样式时，使用 link 和 @import 有什么区别？</h4><ol><li>从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用；link 是 HTML 提供的标签，不仅可以加<br>载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。</li><li>加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。</li><li>兼容性区别。@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容<br>性问题。</li><li>DOM 可控性区别。可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用<br>@import 的方式插入样式。</li></ol><h4 id="13-你对浏览器的理解？"><a href="#13-你对浏览器的理解？" class="headerlink" title="13. 你对浏览器的理解？"></a>13. 你对浏览器的理解？</h4><ol><li>浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。</li><li>HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。</li><li>但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。</li><li>简单来说浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。内核才是浏览器的核心。内核是基于标记语言显示内容的程序或模块。也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。</li></ol><h4 id="14-介绍一下你对浏览器内核的理解？"><a href="#14-介绍一下你对浏览器内核的理解？" class="headerlink" title="14. 介绍一下你对浏览器内核的理解？"></a>14. 介绍一下你对浏览器内核的理解？</h4><p>&nbsp;&nbsp;主要分成两部分：渲染引擎和 JS引擎。</p><p><strong>渲染引擎</strong>: 渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。<br><strong>JS 引擎</strong>：解析和执行 javascript 来实现网页的动态效果。<br>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p><h4 id="15-常见的浏览器内核比较"><a href="#15-常见的浏览器内核比较" class="headerlink" title="15. 常见的浏览器内核比较"></a>15. 常见的浏览器内核比较</h4><ol><li><p>Trident：这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。</p></li><li><p>Gecko：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</p></li><li><p>Presto：Opera曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</p></li><li><p>Webkit：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。</p></li><li><p>Blink：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</p></li></ol><h4 id="16-常见浏览器所用内核"><a href="#16-常见浏览器所用内核" class="headerlink" title="16. 常见浏览器所用内核"></a>16. 常见浏览器所用内核</h4><ol><li><p>IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；</p></li><li><p>Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；</p></li><li><p>Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；</p></li><li><p>Safari 浏览器内核：Webkit 内核；</p></li><li><p>Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；</p></li><li><p>360浏览器、猎豹浏览器内核：IE + Chrome 双内核；</p></li><li><p>搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；</p></li><li><p>百度浏览器、世界之窗内核：IE 内核；</p></li><li><p>2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；</p></li><li><p>UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说<br>是基于火狐内核。</p></li></ol><h4 id="17-浏览器的渲染原理？"><a href="#17-浏览器的渲染原理？" class="headerlink" title="17. 浏览器的渲染原理？"></a>17. 浏览器的渲染原理？</h4><ol><li><p>首先解析收到的文档，根据文档定义构建一颗DOM树，DOM树是由DOM元素及属性节点组成的。</p></li><li><p>然后对CSS进行解析，生成CSSOM规则树。</p></li><li><p>根据 DOM树 和 CSSOM规则树 构建渲染树。渲染树的节点被称为渲染节点，渲染对象是一个包含颜色和大小等属性的矩形，渲染对象和 DOM元素 相对应，但这种对应关系不是一对一的，不可见的DOM元素不会被插入渲染树，还有一些DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</p></li><li><p>但渲染对象被创建并添加到DOM树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局(也可叫做回流)。这一阶段浏览器要做的事就是弄清楚各个节点在页面中的确切位置和大小。通常这一行为叫做”自动重排”。</p></li><li><p>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p></li><li><p>详细资料可以参考:</p><p> <a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc7207f265da613c09425d">浏览器渲染原理</a><br> <a href="https://coolshell.cn/articles/9666.html">浏览器渲染原理简介</a><br> <a href="https://kb.cnblogs.com/page/129756">前端必读:浏览器内部工作原理</a><br> <a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering">深入浅出浏览器渲染原理</a></p></li></ol><h4 id="18-渲染过程中遇到-JS-文件怎么处理？（浏览器解析过程）"><a href="#18-渲染过程中遇到-JS-文件怎么处理？（浏览器解析过程）" class="headerlink" title="18. 渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）"></a>18. 渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）</h4><p>&ensp;&ensp;JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给script 标签添加 defer 或者 async 属性。</p><h4 id="19-async-和-defer-的作用是什么？有什么区别？（浏览器解析过程）"><a href="#19-async-和-defer-的作用是什么？有什么区别？（浏览器解析过程）" class="headerlink" title="19. async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）"></a>19. async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）</h4><ol><li><p>js脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</p></li><li><p>defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。</p></li><li><p>async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。</p></li></ol><p>&ensp;&ensp;资料: <a href="https://segmentfault.com/q/1010000000640869">《defer和async的区别》</a></p><h4 id="20-什么是文档的预解析？（浏览器解析过程）"><a href="#20-什么是文档的预解析？（浏览器解析过程）" class="headerlink" title="20. 什么是文档的预解析？（浏览器解析过程）"></a>20. 什么是文档的预解析？（浏览器解析过程）</h4><p>&ensp;&ensp;Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p><h4 id="21-CSS-如何阻塞文档解析？（浏览器解析过程）"><a href="#21-CSS-如何阻塞文档解析？（浏览器解析过程）" class="headerlink" title="21. CSS 如何阻塞文档解析？（浏览器解析过程）"></a>21. CSS 如何阻塞文档解析？（浏览器解析过程）</h4><p>&ensp;&ensp;理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。<br>&ensp;&ensp;所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。</p><h4 id="22-渲染页面时常见哪些不良现象？（浏览器渲染过程）"><a href="#22-渲染页面时常见哪些不良现象？（浏览器渲染过程）" class="headerlink" title="22. 渲染页面时常见哪些不良现象？（浏览器渲染过程）"></a>22. 渲染页面时常见哪些不良现象？（浏览器渲染过程）</h4><ul><li><p>FOUC：主要指的是样式闪烁的问题，由于浏览器渲染机制（比如firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 css 加载时间过长，或者 css 被放在了文档底部。</p></li><li><p>白屏：有些浏览器渲染机制（比如chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML 尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 js 文件放在头部，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。</p></li></ul><p>&ensp;&ensp;资料:<br>&ensp;&ensp;<a href="https://juejin.im/entry/58f867045c497d0058e2ff3a">《前端魔法堂：解秘 FOUC》</a><br>&ensp;&ensp;<a href="https://www.jianshu.com/p/6617efa874b0">《白屏问题和 FOUC》</a></p><h4 id="23-如何优化关键渲染路径？（浏览器渲染过程）"><a href="#23-如何优化关键渲染路径？（浏览器渲染过程）" class="headerlink" title="23. 如何优化关键渲染路径？（浏览器渲染过程）"></a>23. 如何优化关键渲染路径？（浏览器渲染过程）</h4><p>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：<br>&ensp;&ensp;1. 关键资源的数量。<br>&ensp;&ensp;2. 关键路径长度。<br>&ensp;&ensp;3. 关键字节的数量。</p><p>&ensp;&ensp;关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。<br>&ensp;&ensp;最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p><p>优化关键渲染路径的常规步骤如下：<br>&ensp;&ensp;1. 对关键路径进行分析和特性描述：资源数、字节数、长度。<br>&ensp;&ensp;2. 最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。<br>&ensp;&ensp;3. 优化关键字节数以缩短下载时间（往返次数）。<br>&ensp;&ensp;4. 优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。</p><p>&ensp;&ensp;资料:<br>&ensp;&ensp;<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path?hl=zh-cn">《优化关键渲染路径》</a></p><h4 id="24-什么是重绘和重排（回流）？（浏览器绘制过程）"><a href="#24-什么是重绘和重排（回流）？（浏览器绘制过程）" class="headerlink" title="24. 什么是重绘和重排（回流）？（浏览器绘制过程）"></a>24. 什么是重绘和重排（回流）？（浏览器绘制过程）</h4><p>&ensp;&ensp;重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background-color，我们将这样的操作称为重绘。</p><p>&ensp;&ensp;重排（回流）：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。</p><p>&ensp;&ensp;常见引起回流属性和方法：<br>&ensp;&ensp;任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。<br>&ensp;&ensp;&ensp;1. 添加或者删除可见的 DOM 元素；<br>&ensp;&ensp;&ensp;2. 元素尺寸改变——边距、填充、边框、宽度和高度<br>&ensp;&ensp;&ensp;3. 内容变化，比如用户在 input 框中输入文字<br>&ensp;&ensp;&ensp;4. 浏览器窗口尺寸改变——resize事件发生时<br>&ensp;&ensp;&ensp;5. 计算 offsetWidth 和 offsetHeight 属性<br>&ensp;&ensp;&ensp;6. 置 style 属性的值<br>&ensp;&ensp;&ensp;7. 当你修改网页的默认字体时。</p><p>&ensp;&ensp;回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p><h4 id="25-如何减少回流？（浏览器绘制过程）"><a href="#25-如何减少回流？（浏览器绘制过程）" class="headerlink" title="25. 如何减少回流？（浏览器绘制过程）"></a>25. 如何减少回流？（浏览器绘制过程）</h4><ol><li><p>使用 transform 替代 top</p></li><li><p>不要把节点的属性值放在一个循环里当成循环里的变量</p></li><li><p>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</p></li><li><p>把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM</p></li><li><p>不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。</p></li></ol><h4 id="26-为什么操作-DOM-慢？（浏览器绘制过程）"><a href="#26-为什么操作-DOM-慢？（浏览器绘制过程）" class="headerlink" title="26. 为什么操作 DOM 慢？（浏览器绘制过程）"></a>26. 为什么操作 DOM 慢？（浏览器绘制过程）</h4><p>&ensp;&ensp;一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。</p><h4 id="27-DOMContentLoaded-事件和-Load-事件的区别？"><a href="#27-DOMContentLoaded-事件和-Load-事件的区别？" class="headerlink" title="27. DOMContentLoaded 事件和 Load 事件的区别？"></a>27. DOMContentLoaded 事件和 Load 事件的区别？</h4><p>&ensp;&ensp;当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的加载完成。<br>&ensp;&ensp;Load 事件是当所有资源加载完成后触发的。</p><h4 id="28-HTML5-有哪些新特性、移除了那些元素？"><a href="#28-HTML5-有哪些新特性、移除了那些元素？" class="headerlink" title="28. HTML5 有哪些新特性、移除了那些元素？"></a>28. HTML5 有哪些新特性、移除了那些元素？</h4><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。<br>新增的有：</p><ul><li>画布： canvas;</li><li>音视频： video 和 audio 元素;\</li><li>web存储：本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;</li><li>sessionStorage 的数据在浏览器关闭后自动删除;</li><li>语义化更好的内容元素，比如 article、footer、header、main、nav、section;</li><li>表单控件，calendar、date、time、email、url、search;</li><li>新的技术 webworker, websocket;</li><li>新的文档属性 document.visibilityState</li></ul><p>移除的元素有：</p><ul><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li><li>对可用性产生负面影响的元素：frame，frameset，noframes；</li></ul><h4 id="29-简述一下你对-HTML-语义化的理解？"><a href="#29-简述一下你对-HTML-语义化的理解？" class="headerlink" title="29. 简述一下你对 HTML 语义化的理解？"></a>29. 简述一下你对 HTML 语义化的理解？</h4><ol><li><p>用正确的标签做正确的事情。</p></li><li><p>html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</p></li><li><p>即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;</p></li><li><p>搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO（搜索引擎优化）;</p></li><li><p>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p></li></ol><p>回答：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">我认为 <span class="hljs-selector-tag">html</span> 语义化主要指的是我们应该使用合适的标签来划分网页内容的结构。<span class="hljs-selector-tag">html</span> 的本质作用其实就是定义网页文档的结构，一个语义化的文档，能够使页面的结构更加清晰，易于理解。这样不仅有利于开发者的维护和理解，同时也能够使机器对文档内容进行正确的解读。比如说我们常用的 <span class="hljs-selector-tag">b</span> 标签和 <span class="hljs-selector-tag">strong</span> 标签，它们在样式上都是文字的加粗，但是 <span class="hljs-selector-tag">strong</span> 标签拥有强调的语义。<br>对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。如果用户使用的是屏幕阅读器来访问网页的话，使用 <span class="hljs-selector-tag">strong</span> 标签就会有明显的语调上的变化，而 <span class="hljs-selector-tag">b</span> 标签则没有。如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会依赖于 <span class="hljs-selector-tag">html</span> 标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的，从而有利于我们网站的 SEO 。从 html5 我们可以看出，标准是倾向于以语义化的方式来构建网页的，比如新增了 <span class="hljs-selector-tag">header</span> 、<span class="hljs-selector-tag">footer</span> 这些语义标签，删除了 big 、<span class="hljs-attribute">font</span> 这些没有语义的标签。<br></code></pre></td></tr></table></figure><h4 id="30-b-与-strong-的区别和-i-与-em-的区别？"><a href="#30-b-与-strong-的区别和-i-与-em-的区别？" class="headerlink" title="30. b 与 strong 的区别和 i 与 em 的区别？"></a>30. b 与 strong 的区别和 i 与 em 的区别？</h4><p>&ensp;&ensp;从页面显示效果来看，被 <code>&lt;b&gt;</code> 和 <code>&lt;strong&gt;</code> 包围的文字将会被加粗，而被 <code>&lt;i&gt;</code> 和 <code>&lt;em&gt;</code> 包围的文字将以斜体的形式呈现。但是 <code>&lt;b&gt; &lt;i&gt;</code> 是自然样式标签，分别表示无意义的加粗，无意义的斜体，表现样式为 { font-weight: bolder}，仅仅表示「这里应该用粗体显示」或者「这里应该用斜体显示」，此两个标签在 HTML4.01 中并不被推荐使用。而 <code>&lt;em&gt;</code> 和 <code>&lt;strong&gt;</code> 是语义样式标签。 <code>&lt;em&gt;</code> 表示一般的强调文本，而 <code>&lt;strong&gt;</code> 表示比 <code>&lt;em&gt;</code> 语义更强的强调文本。使用阅读设备阅读网页时：<code>&lt;strong&gt;</code> 会重读，而 <code>&lt;b&gt;</code> 是展示强调内容。</p><h4 id="31-前端需要注意哪些-SEO-？"><a href="#31-前端需要注意哪些-SEO-？" class="headerlink" title="31. 前端需要注意哪些 SEO ？"></a>31. 前端需要注意哪些 SEO ？</h4><ol><li><p>合理的 title、description、keywords：搜索对这三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可。</p></li><li><p>语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。</p></li><li><p>重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被抓取。</p></li><li><p>重要内容不要用 js 输出：爬虫不会执行 js 获取内容</p></li><li><p>少用 iframe：搜索引擎不会抓取 iframe 中的内容</p></li><li><p>非装饰性图片必须加 alt</p></li><li><p>提高网站速度：网站速度是搜索引擎排序的一个重要指标</p></li></ol><h4 id="32-HTML5-的离线储存怎么使用，工作原理能不能解释一下？"><a href="#32-HTML5-的离线储存怎么使用，工作原理能不能解释一下？" class="headerlink" title="32. HTML5 的离线储存怎么使用，工作原理能不能解释一下？"></a>32. HTML5 的离线储存怎么使用，工作原理能不能解释一下？</h4><p>&ensp;&ensp;在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。<br>&ensp;&ensp;原理：HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制（不是存储技术），通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p><p>如何使用：</p><ul><li><p>创建一个和 html 同名的 manifest 文件，然后在页面头部像下面一样加入一个 manifest 的属性。<html lang="en" manifest="index.manifest"></p></li><li><p>在如下 cache.manifest 文件的编写离线存储的资源。</p></li></ul><ol><li>CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li><li>NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 C<br> ACHE 的优先级更高。</li><li>FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</li></ol><ul><li>在离线状态时，操作 window.applicationCache 进行离线缓存的操作。<br> 如何更新缓存：</li></ul><ol><li>更新 manifest 文件</li><li>通过 javascript 操作</li><li>清除浏览器缓存</li></ol><p> 注意事项：</p><ol><li>浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</li><li>如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。</li><li>引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。</li><li>FALLBACK 中的资源必须和 manifest 文件同源。</li><li>当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</li><li>站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</li><li>当 manifest 文件发生改变时，资源请求本身也会触发更新。</li></ol><h4 id="33-浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的呢？"><a href="#33-浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的呢？" class="headerlink" title="33. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？"></a>33. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？</h4><p>&ensp;&ensp;在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。<br>&ensp;&ensp;离线的情况下，浏览器就直接使用离线存储的资源。</p><h4 id="34-常见的浏览器端的存储技术有哪些？"><a href="#34-常见的浏览器端的存储技术有哪些？" class="headerlink" title="34. 常见的浏览器端的存储技术有哪些？"></a>34. 常见的浏览器端的存储技术有哪些？</h4><ul><li>浏览器常见的存储技术有 cookie、localStorage 和 sessionStorage。</li><li>还有两种存储技术用于大规模数据存储，webSQL（已被废除）和 indexDB。</li><li>IE 支持 userData 存储数据，但是基本很少使用到，除非有很强的浏览器兼容需求。</li></ul><h4 id="35-请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#35-请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="35. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>35. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h4><p>&ensp;&ensp;SessionStorage， LocalStorage， Cookie 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。区别在于前两者属于 HTML5 WebStorage，创建它们的目的便于客户端存储数据。而 cookie 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）。cookie 数据始终在同源（协议、主机、端口相同）的 http 请求中携带（即使不需要），会在浏览器和服务器间来回传递。</p><p>存储大小：</p><ul><li>cookie 数据大小不能超过4 k 。</li><li>sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</li></ul><p>有期时间：</p><ul><li>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。</li><li>sessionStorage 数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会<br>保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。</li><li>cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</li></ul><p>作用域：</p><ul><li>sessionStorage 只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。</li><li>localStorage 在所有同源窗口中都是共享的。</li><li>cookie 在所有同源窗口中都是共享的。</li></ul><p>回答：</p><ul><li>浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。</li><li>cookie 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</li><li>sessionStorage 是 html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。</li><li>localStorage 也是 html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</li></ul><p>上面几种方式都是存储少量数据的时候的存储方式，当我们需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。</p><p>详细的资料可以参考：<br><a href="https://segmentfault.com/a/1190000017423117">请描述一下 cookies，sessionStorage 和 localStorage 的区别？</a><br><a href="http://www.ruanyifeng.com/blog/2018/07/indexeddb.html">浏览器数据库 IndexedDB 入门教程</a></p><h4 id="36-iframe-有那些缺点？"><a href="#36-iframe-有那些缺点？" class="headerlink" title="36. iframe 有那些缺点？"></a>36. iframe 有那些缺点？</h4><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。<br>主要缺点有：</p><ol><li>iframe 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 src 可以避免这种阻塞情况。</li><li>搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。</li><li>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li><li>浏览器的后退按钮失效。</li><li>小型的移动设备无法完全显示框架。</li></ol><p>详细的资料可以参考：<br><a href="https://blog.csdn.net/yintianqin/article/details/72625785">使用 iframe 的优缺点</a><br><a href="https://segmentfault.com/a/1190000009891683">iframe 简单探索以及 iframe 跨域处理</a></p><h4 id="37-Label-的作用是什么？是怎么用的？"><a href="#37-Label-的作用是什么？是怎么用的？" class="headerlink" title="37. Label 的作用是什么？是怎么用的？"></a>37. Label 的作用是什么？是怎么用的？</h4><p>label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。<br><code>&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;</code><br><code>&lt;input type=“text“ name=&quot;Name&quot; id=&quot;Name&quot;/&gt;</code></p><h4 id="38-HTML5-的-form-的自动完成功能是什么？"><a href="#38-HTML5-的-form-的自动完成功能是什么？" class="headerlink" title="38. HTML5 的 form 的自动完成功能是什么？"></a>38. HTML5 的 form 的自动完成功能是什么？</h4><p>&ensp;&ensp;autocomplete 属性规定输入字段是否应该启用自动完成功能。默认为启用，设置为 autocomplete&#x3D;off 可以关闭该功能。<br>&ensp;&ensp;自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。<br>&ensp;&ensp;autocomplete 属性适用于 <code>&lt;form&gt;</code>，以及下面的 <code>&lt;input&gt;</code> 类型：text, search, url, telephone, email, password, datepickers, range 以及 color。</p><h4 id="39-如何实现浏览器内多个标签页之间的通信"><a href="#39-如何实现浏览器内多个标签页之间的通信" class="headerlink" title="39. 如何实现浏览器内多个标签页之间的通信?"></a>39. 如何实现浏览器内多个标签页之间的通信?</h4><p>相关资料：</p><ol><li>使用 WebSocket，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。</li><li>使用 SharedWorker （只在 chrome 浏览器实现了），两个页面共享同一个线程，通过向线程发送数据和接收数据来实现标签页之间的双向通行。</li><li>可以调用 localStorage、cookies 等本地存储方式，localStorge 另一个浏览上下文里被添加、修改或删除时，它都会触发一个 storage 事件，我们通过监听 storage 事件，控制它的值来进行页面信息通信；</li><li>如果我们能够获得对应标签页的引用，通过 postMessage 方法也是可以实现多个标签页通信的。</li></ol><p>回答：<br>&ensp;&ensp;实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。<br>&ensp;&ensp;第一种实现的方式是使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。<br>&ensp;&ensp;第二种是使用 SharedWorker 的方式，sharedWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。<br>&ensp;&ensp;第三种方式是使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。<br>&ensp;&ensp;还有一种方式是使用 postMessage 方法，如果我们能够获得对应标签页的引用，我们就可以使用 postMessage 方法，进行通信。</p><p>详细的资料可以参考：</p><p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 教程</a><br><a href="https://www.cnblogs.com/chyingp/p/websocket-deep-in.html">WebSocket 协议：5分钟从入门到精通</a><br><a href="https://segmentfault.com/a/1190000011538416">WebSocket 学习（一）——基于 socket.io 实现简单多人聊天室</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API">使用 Web Storage API</a><br><a href="https://www.zhuwenlong.com/blog/article/590ea64fe55f0f385f9a12e5">JavaScript 的多线程，Worker 和 SharedWorker</a><br><a href="https://juejin.im/post/5acdba01f265da23826e5633#heading-1">实现多个标签页之间通信的几种方法</a></p><h4 id="40-webSocket-如何兼容低版本浏览器？"><a href="#40-webSocket-如何兼容低版本浏览器？" class="headerlink" title="40. webSocket 如何兼容低版本浏览器？"></a>40. webSocket 如何兼容低版本浏览器？</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">Adobe Flash Socket 、<br>ActiveX HTMLFile <span class="hljs-comment">(IE)</span> 、<br>基于 multipart 编码发送 XHR 、<br>基于长轮询的 XHR<br></code></pre></td></tr></table></figure><h4 id="41-页面可见性（Page-Visibility-API）-可以有哪些用途？"><a href="#41-页面可见性（Page-Visibility-API）-可以有哪些用途？" class="headerlink" title="41. 页面可见性（Page Visibility API） 可以有哪些用途？"></a>41. 页面可见性（Page Visibility API） 可以有哪些用途？</h4><p>&ensp;&ensp;这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户不看网页，下面这些网页行为都是可以暂停的。</p><ol><li>对服务器的轮询</li><li>网页动画</li><li>正在播放的音频或视频</li></ol><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2018/10/page_visibility_api.html">Page Visibility API 教程</a></p><h4 id="42-如何在页面上实现一个圆形的可点击区域？"><a href="#42-如何在页面上实现一个圆形的可点击区域？" class="headerlink" title="42. 如何在页面上实现一个圆形的可点击区域？"></a>42. 如何在页面上实现一个圆形的可点击区域？</h4><ol><li><p>纯 html 实现，使用 <code>&lt;area&gt;</code> 来给 <code>&lt;img&gt;</code> 图像标记热点区域的方式，<code>&lt;map&gt;</code> 标签用来定义一个客户端图像映射，<code>&lt;area&gt;</code> 标签用来定义图像映射中的区域，area 元素永远嵌套在 map 元素内部，我们可以将 area 区域设置为圆形，从而实现可点击的圆形区域。</p></li><li><p>纯 css 实现，使用 border-radius ，当 border-radius 的长度等于宽高相等的元素值的一半时，即可实现一个圆形的点击区域。</p></li><li><p>纯 js 实现，判断一个点在不在圆上的简单算法，通过监听文档的点击事件，获取每次点击时鼠标的位置，判断该位置是否在我们规定的圆形区域内。</p></li></ol><p>详细资料可以参考：<br><a href="https://maizi93.github.io/2017/08/29/%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9C%86%E5%BD%A2%E7%9A%84%E5%8F%AF%E7%82%B9%E5%87%BB%E5%8C%BA%E5%9F%9F%EF%BC%9F/">如何在页面上实现一个圆形的可点击区域？</a><br><a href="https://www.zhangxinxu.com/wordpress/2017/05/html-area-map/">HTML <area><map> 标签及在实际开发中的应用</a></p><h4 id="43-实现不使用-border-画出-1-px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"><a href="#43-实现不使用-border-画出-1-px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。" class="headerlink" title="43. 实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"></a>43. 实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;height:1px;overflow:hidden;background:red&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="44-title-与-h1-的区别？"><a href="#44-title-与-h1-的区别？" class="headerlink" title="44. title 与 h1 的区别？"></a>44. title 与 h1 的区别？</h4><p>&ensp;&ensp;title 属性没有明确意义只表示是个标题，h1 则表示层次明确的标题，对页面信息的抓取也有很大的影响。</p><h4 id="45-的-title-和-alt-有什么区别？"><a href="#45-的-title-和-alt-有什么区别？" class="headerlink" title="45. &lt;img&gt; 的 title 和 alt 有什么区别？"></a>45. <code>&lt;img&gt;</code> 的 title 和 alt 有什么区别？</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">title 通常当鼠标滑动到元素上的时候显示<br>alt 是 <span class="hljs-tag">&lt;<span class="hljs-name">img</span>&gt;</span> 的特有属性，是图片内容的等价描述，用于图片无法加载时显示（图片无法加载时显示文字）、读屏器阅读图片。可提高图片可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。<br></code></pre></td></tr></table></figure><h4 id="46-Canvas-和-SVG-有什么区别？"><a href="#46-Canvas-和-SVG-有什么区别？" class="headerlink" title="46. Canvas 和 SVG 有什么区别？"></a>46. Canvas 和 SVG 有什么区别？</h4><p>&ensp;&ensp;Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，因此当我们对 Canvas 进行缩放时，会出现锯齿或者失真的情况。<br>&ensp;&ensp;SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。</p><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19690014">SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途？</a></p><h4 id="47-网页验证码是干嘛的，是为了解决什么安全问题？"><a href="#47-网页验证码是干嘛的，是为了解决什么安全问题？" class="headerlink" title="47. 网页验证码是干嘛的，是为了解决什么安全问题？"></a>47. 网页验证码是干嘛的，是为了解决什么安全问题？</h4><ol><li><p>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</p></li><li><p>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</p></li></ol><h4 id="48-渐进增强和优雅降级的定义"><a href="#48-渐进增强和优雅降级的定义" class="headerlink" title="48. 渐进增强和优雅降级的定义"></a>48. 渐进增强和优雅降级的定义</h4><ul><li>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li><li>优雅降级：一开始就根据高版本浏览器构建完整的功能，然后再针对低版本浏览器进行兼容。</li></ul><h4 id="49-attribute-和-property-的区别是什么？"><a href="#49-attribute-和-property-的区别是什么？" class="headerlink" title="49. attribute 和 property 的区别是什么？"></a>49. attribute 和 property 的区别是什么？</h4><ul><li>attribute 是 dom 元素在文档中作为 html 标签拥有的属性；</li><li>property 就是 dom 元素在 js 中作为对象拥有的属性。</li><li>对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的，但是对于自定义的属性来说，他们是不同步的。</li></ul><h4 id="50-对-web-标准可用性、可访问性、可维护性的理解"><a href="#50-对-web-标准可用性、可访问性、可维护性的理解" class="headerlink" title="50. 对 web 标准可用性、可访问性、可维护性的理解"></a>50. 对 web 标准可用性、可访问性、可维护性的理解</h4><p>&ensp;&ensp;可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力</p><p>可访问性（Accessibility）：Web 内容对于残障用户的可阅读和可理解性<br>可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。<br>二是代码是否容易被人理解，是否容易修改和增强功能。</p><h4 id="51-IE-各版本和-Chrome-可以并行下载多少个资源？"><a href="#51-IE-各版本和-Chrome-可以并行下载多少个资源？" class="headerlink" title="51. IE 各版本和 Chrome 可以并行下载多少个资源？"></a>51. IE 各版本和 Chrome 可以并行下载多少个资源？</h4><ol><li>IE6 2 个并发</li><li>iE7 升级之后的 6 个并发，之后版本也是 6 个</li><li>Firefox，chrome 也是6个</li></ol><h4 id="52-Flash、Ajax-各自的优缺点，在使用中如何取舍？"><a href="#52-Flash、Ajax-各自的优缺点，在使用中如何取舍？" class="headerlink" title="52. Flash、Ajax 各自的优缺点，在使用中如何取舍？"></a>52. Flash、Ajax 各自的优缺点，在使用中如何取舍？</h4><p>Flash：</p><ol><li>Flash 适合处理多媒体、矢量图形、访问机器</li><li>对 CSS、处理文本上不足，不容易被搜索</li></ol><p>Ajax：</p><ol><li>Ajax 对 CSS、文本支持很好，支持搜索</li><li>媒体、矢量图形、机器访问不足</li></ol><p>共同点：</p><ol><li>与服务器的无刷新传递消息</li><li>可以检测用户离线和在线状态</li><li>操作 DOM</li></ol><h4 id="53-怎么重构页面？"><a href="#53-怎么重构页面？" class="headerlink" title="53. 怎么重构页面？"></a>53. 怎么重构页面？</h4><ol><li>编写 CSS</li><li>让页面结构更合理化，提升用户体验</li><li>实现良好的页面效果和提升性能</li></ol><h4 id="54-浏览器架构"><a href="#54-浏览器架构" class="headerlink" title="54. 浏览器架构"></a>54. 浏览器架构</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 用户界面<br><span class="hljs-bullet">      *</span> 主进程<br><span class="hljs-bullet">      *</span> 内核<br><span class="hljs-bullet">          *</span> 渲染引擎<br><span class="hljs-bullet">          *</span> JS 引擎<br><span class="hljs-bullet">              *</span> 执行栈<br><span class="hljs-bullet">          *</span> 事件触发线程<br><span class="hljs-bullet">              *</span> 消息队列<br><span class="hljs-bullet">                  *</span> 微任务<br><span class="hljs-bullet">                  *</span> 宏任务<br><span class="hljs-bullet">          *</span> 网络异步线程<br><span class="hljs-bullet">          *</span> 定时器线程<br></code></pre></td></tr></table></figure><h4 id="55-常用的-meta-标签"><a href="#55-常用的-meta-标签" class="headerlink" title="55. 常用的 meta 标签"></a>55. 常用的 meta 标签</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta&gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。<br>&lt;meta&gt; 标签位于文档的头部，不包含任何内容。&lt;meta&gt; 标签的属性定义了与文档相关联的名称/值对。<br>&lt;!DOCTYPE html&gt;  H5标准声明，使用 HTML5 doctype，不区分大小写<br>&lt;head <span class="hljs-attribute">lang</span>=”en”&gt; 标准的 lang 属性写法<br>&lt;meta <span class="hljs-attribute">charset</span>=’utf-8′&gt;    声明文档使用的字符编码<br>&lt;meta <span class="hljs-attribute">http-equiv</span>=”X-UA-Compatible” <span class="hljs-attribute">content</span>=”IE=edge,chrome=1″/&gt;   优先使用 IE 最新版本和 Chrome<br>&lt;meta <span class="hljs-attribute">name</span>=”description” <span class="hljs-attribute">content</span>=”不超过150个字符”/&gt;       页面描述<br>&lt;meta <span class="hljs-attribute">name</span>=”keywords” <span class="hljs-attribute">content</span>=””/&gt;      页面关键词者<br>&lt;meta <span class="hljs-attribute">name</span>=”author” <span class="hljs-attribute">content</span>=”name, email@gmail.com”/&gt;    网页作<br>&lt;meta <span class="hljs-attribute">name</span>=”robots” <span class="hljs-attribute">content</span>=”index,follow”/&gt;      搜索引擎抓取<br>&lt;meta <span class="hljs-attribute">name</span>=”viewport” <span class="hljs-attribute">content</span>=”initial-scale=1, <span class="hljs-attribute">maximum-scale</span>=3, <span class="hljs-attribute">minimum-scale</span>=1, <span class="hljs-attribute">user-scalable</span>=<span class="hljs-literal">no</span>”&gt; 为移动设备添加 viewport<br>&lt;meta <span class="hljs-attribute">name</span>=”apple-mobile-web-app-title” <span class="hljs-attribute">content</span>=”标题”&gt; iOS 设备 begin<br>&lt;meta <span class="hljs-attribute">name</span>=”apple-mobile-web-app-capable” <span class="hljs-attribute">content</span>=”yes”/&gt;  添加到主屏后的标题（iOS 6 新增）<br>是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏<br>&lt;meta <span class="hljs-attribute">name</span>=”apple-itunes-app” <span class="hljs-attribute">content</span>=”app-id=myAppStoreID, <span class="hljs-attribute">affiliate-data</span>=myAffiliateData, <span class="hljs-attribute">app-argument</span>=myURL”&gt;<br>添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）<br>&lt;meta <span class="hljs-attribute">name</span>=”apple-mobile-web-app-status-bar-style” <span class="hljs-attribute">content</span>=”black”/&gt;<br>&lt;meta <span class="hljs-attribute">name</span>=”format-detection” <span class="hljs-attribute">content</span>=”telphone=no, <span class="hljs-attribute">email</span>=<span class="hljs-literal">no</span>”/&gt;  设置苹果工具栏颜色<br>&lt;meta <span class="hljs-attribute">name</span>=”renderer” <span class="hljs-attribute">content</span>=”webkit”&gt;  启用360浏览器的极速模式(webkit)<br>&lt;meta <span class="hljs-attribute">http-equiv</span>=”X-UA-Compatible” <span class="hljs-attribute">content</span>=”IE=edge”&gt;     避免IE使用兼容模式<br>&lt;meta <span class="hljs-attribute">http-equiv</span>=”Cache-Control” <span class="hljs-attribute">content</span>=”no-siteapp” /&gt;    不让百度转码<br>&lt;meta <span class="hljs-attribute">name</span>=”HandheldFriendly” <span class="hljs-attribute">content</span>=”true”&gt;     针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓<br>&lt;meta <span class="hljs-attribute">name</span>=”MobileOptimized” <span class="hljs-attribute">content</span>=”320″&gt;   微软的老式浏览器<br>&lt;meta <span class="hljs-attribute">name</span>=”screen-orientation” <span class="hljs-attribute">content</span>=”portrait”&gt;   uc强制竖屏<br>&lt;meta <span class="hljs-attribute">name</span>=”x5-orientation” <span class="hljs-attribute">content</span>=”portrait”&gt;    QQ强制竖屏<br>&lt;meta <span class="hljs-attribute">name</span>=”full-screen” <span class="hljs-attribute">content</span>=”yes”&gt;              UC强制全屏<br>&lt;meta <span class="hljs-attribute">name</span>=”x5-fullscreen” <span class="hljs-attribute">content</span>=”true”&gt;       QQ强制全屏<br>&lt;meta <span class="hljs-attribute">name</span>=”browsermode” <span class="hljs-attribute">content</span>=”application”&gt;   UC应用模式<br>&lt;meta <span class="hljs-attribute">name</span>=”x5-page-mode” <span class="hljs-attribute">content</span>=”app”&gt;    QQ应用模式<br>&lt;meta <span class="hljs-attribute">name</span>=”msapplication-tap-highlight” <span class="hljs-attribute">content</span>=”no”&gt;    windows phone 点击无高光<br>设置页面不缓存<br>&lt;meta <span class="hljs-attribute">http-equiv</span>=”pragma” <span class="hljs-attribute">content</span>=”no-cache”&gt;<br>&lt;meta <span class="hljs-attribute">http-equiv</span>=”cache-control” <span class="hljs-attribute">content</span>=”no-cache”&gt;<br>&lt;meta <span class="hljs-attribute">http-equiv</span>=”expires” <span class="hljs-attribute">content</span>=”0″&gt;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.cnblogs.com/qiumohanyu/p/5431859.html">Meta 标签用法大全</a></p><h4 id="56-css-reset-和-normalize-css-有什么区别？"><a href="#56-css-reset-和-normalize-css-有什么区别？" class="headerlink" title="56. css reset 和 normalize.css 有什么区别？"></a>56. css reset 和 normalize.css 有什么区别？</h4><p>相关知识点：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs stylus">为什么会有 CSS Reset 的存在呢？那是因为早期的浏览器支持和理解的 CSS 规范不同，导致渲染页面时效果不一致，会出现很多<br>兼容性问题。<br><br>reset 的目的，是将所有的浏览器的自带样式重置掉，这样更易于保持各浏览器渲染的一致性。<br><br>normalize 的理念则是尽量保留浏览器的默认样式，不进行太多的重置，而尽力让这些样式保持一致并尽可能与现代标准相符合。<br><br><span class="hljs-number">1</span><span class="hljs-selector-class">.Normalize</span><span class="hljs-selector-class">.css</span> 保护了有价值的默认值<br><br>Reset 通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。 相比之下，Normalize<span class="hljs-selector-class">.css</span> 保持了许多默认的浏<br>览器样式。 这就意味着你不用再为所有公共的排版元素重新设置样式。 当一个元素在不同的浏览器中有不同的默认值时，Normali<br>ze<span class="hljs-selector-class">.css</span> 会力求让这些样式保持一致并尽可能与现代标准相符合。<br><br><span class="hljs-number">2</span><span class="hljs-selector-class">.Normalize</span><span class="hljs-selector-class">.css</span> 修复了浏览器的 bug<br><br>它修复了常见的桌面端和移动端浏览器的 bug。这往往超出了 Reset 所能做到的范畴。关于这一点，Normalize<span class="hljs-selector-class">.css</span> 修复的问题<br>包含了 HTML5 元素的显示设置、预格式化文字的 <span class="hljs-attribute">font-size</span> 问题、在 IE9 中 SVG 的溢出、许多出现在各浏览器和操作系统中<br>的与表单相关的 bug。<br><br><span class="hljs-number">3</span><span class="hljs-selector-class">.Normalize</span><span class="hljs-selector-class">.css</span> 没有复杂的继承链<br><br>使用 Reset 最让人困扰的地方莫过于在浏览器调试工具中大段大段的继承链。在 Normalize<span class="hljs-selector-class">.css</span> 中就不会有这样的问题，因为在<br>我们的准则中对多选择器的使用是非常谨慎的，我们仅会有目的地对目标元素设置样式。<br><br><span class="hljs-number">4</span><span class="hljs-selector-class">.Normalize</span><span class="hljs-selector-class">.css</span> 是模块化的<br><br>这个项目已经被拆分为多个相关却又独立的部分，这使得你能够很容易也很清楚地知道哪些元素被设置了特定的值。因此这能让你自己<br>选择性地移除掉某些永远不会用到部分（比如表单的一般化）。<br><br><span class="hljs-number">5</span><span class="hljs-selector-class">.Normalize</span><span class="hljs-selector-class">.css</span> 拥有详细的文档<br><br>Normalize<span class="hljs-selector-class">.css</span> 的代码基于详细而全面的跨浏览器研究与测试。这个文件中拥有详细的代码说明并在 Github Wiki 中有进一步的<br>说明。这意味着你可以找到每一行代码具体完成了什么工作、为什么要写这句代码、浏览器之间的差异，并且你可以更容易地进行自己<br>的测试。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">css reset 是最早的一种解决浏览器间样式不兼容问题的方案，它的基本思想是将浏览器的所有样式都重置掉，从而达到所有浏览器<br>样式保持一致的效果。但是使用这种方法，可能会带来一些性能上的问题，并且对于一些元素的不必要的样式的重置，其实反而会造成<br>画蛇添足的效果。<br><br>后面出现一种更好的解决浏览器间样式不兼容的方法，就是 <span class="hljs-keyword">normalize.css </span>，它的思想是尽量的保留浏览器自带的样式，通过在原<br>有的样式的基础上进行调整，来保持各个浏览器间的样式表现一致。相对与 css reset，<span class="hljs-keyword">normalize.css </span>的方法保留了有价值的默<br>认值，并且修复了一些浏览器的 <span class="hljs-keyword">bug，而且使用 </span><span class="hljs-keyword">normalize.css </span>不会造成元素复杂的继承链。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000003021766#articleHeader0">关于CSS Reset 那些事（一）之 历史演变与 Normalize.css</a><br><a href="https://segmentfault.com/q/1010000000117189">Normalize.css 和 Reset CSS 有什么本质区别没？</a></p><h4 id="57-用于预格式化文本的标签是？"><a href="#57-用于预格式化文本的标签是？" class="headerlink" title="57. 用于预格式化文本的标签是？"></a>57. 用于预格式化文本的标签是？</h4><p>&ensp;&ensp;预格式化就是保留文字在源码中的格式 最后显示出来样式与源码中的样式一致 所见即所得。<br>&ensp;&ensp;<code>&lt;pre&gt;</code> 定义预格式文本，保持文本原有的格式</p><h4 id="58-DHTML-是什么？"><a href="#58-DHTML-是什么？" class="headerlink" title="58. DHTML 是什么？"></a>58. DHTML 是什么？</h4><p>&ensp;&ensp;DHTML 将 HTML、JavaScript、DOM 以及 CSS 组合在一起，用于创造动态性更强的网页。通过 JavaScript 和 HTML DOM，能够动态地改变 HTML 元素的样式。</p><p>&ensp;&ensp;DHTML 实现了网页从 Web 服务器下载后无需再经过服务器的处理，而在浏览器中直接动态地更新网页的内容、排版样式和动画的功能。例如，当鼠标指针移到文章段落中时，段落能够变成蓝色，或者当鼠标指针移到一个超级链接上时，会自动生成一个下拉式子链接目录等。</p><p>包括：</p><ol><li>动态内容（Dynamic Content）：动态地更新网页内容，可“动态”地插入、修改或删除网页的元件，如文字、图像、标记等。</li><li>动态排版样式（Dynamic Style Sheets）：W3C 的 CSS 样式表提供了设定 HTML 标记的字体大小、字形、样式、粗细、文字颜色、行高度、加底线或加中间横线、缩排、与边缘距离、靠左右或置中、背景图片或颜色等排版功能，而“动态排版样式”即可以“动态”地改变排版样式。</li></ol><h4 id="59-head-标签中必不少的是？"><a href="#59-head-标签中必不少的是？" class="headerlink" title="59. head 标签中必不少的是？"></a>59. head 标签中必不少的是？</h4><p>&ensp;&ensp;<code>&lt;head&gt;</code> 标签用于定义文档的头部，它是所有头部元素的容器。<code>&lt;head&gt;</code> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。<br>&ensp;&ensp;文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。<br>&ensp;&ensp;下面这些标签可用在 head 部分：<code>&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;</code>, 以及 <code>&lt;title&gt;。&lt;title&gt;</code> 定义文档的标题，它是 head 部分中唯一必需的元素。</p><h4 id="60-HTML5-新增的表单元素有？"><a href="#60-HTML5-新增的表单元素有？" class="headerlink" title="60. HTML5 新增的表单元素有？"></a>60. HTML5 新增的表单元素有？</h4><p>&ensp;&ensp;datalist 规定输入域的选项列表，通过 option 创建！<br>&ensp;&ensp; keygen 提供一种验证用户的可靠方法，密钥对生成器，私钥存于客户端，公钥发到服务器，用于之后验证客户端证书！<br>&ensp;&ensp; output 元素用于不同类型的输出！</p><h4 id="61-在-HTML5-中，哪个方法用于获得用户的当前位置？"><a href="#61-在-HTML5-中，哪个方法用于获得用户的当前位置？" class="headerlink" title="61. 在 HTML5 中，哪个方法用于获得用户的当前位置？"></a>61. 在 HTML5 中，哪个方法用于获得用户的当前位置？</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">getCurrentPosition</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><h4 id="62-文档的不同注释方式？"><a href="#62-文档的不同注释方式？" class="headerlink" title="62. 文档的不同注释方式？"></a>62. 文档的不同注释方式？</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">HTML 的注释方法 <span class="hljs-comment">&lt;!--注释内容--&gt;</span> <br>  <br>CSS 的注释方法 /*注释内容*/ <br>  <br>JavaScript 的注释方法 /* 多行注释方式 */ //单行注释方式<br></code></pre></td></tr></table></figure><h4 id="63-disabled-和-readonly-的区别？"><a href="#63-disabled-和-readonly-的区别？" class="headerlink" title="63. disabled 和 readonly 的区别？"></a>63. disabled 和 readonly 的区别？</h4><p>&ensp;&ensp;disabled 指当 input 元素加载时禁用此元素。input 内容不会随着表单提交。<br>&ensp;&ensp;readonly 规定输入字段为只读。input 内容会随着表单提交。<br>&ensp;&ensp;无论设置 readonly 还是 disabled，通过 js 脚本都能更改 input 的 value</p><h4 id="64-主流浏览器内核私有属性-css-前缀？"><a href="#64-主流浏览器内核私有属性-css-前缀？" class="headerlink" title="64. 主流浏览器内核私有属性 css 前缀？"></a>64. 主流浏览器内核私有属性 css 前缀？</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">mozilla 内核 （firefox,<span class="hljs-keyword">flock</span> 等）    -moz<br>webkit  内核 （safari,chrome 等）   -webkit<br>opera   内核 （opera 浏览器）        -o<br>trident 内核 （ie 浏览器）           -ms<br></code></pre></td></tr></table></figure><h4 id="65-前端性能优化？"><a href="#65-前端性能优化？" class="headerlink" title="65. 前端性能优化？"></a>65. 前端性能优化？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。<br><br>第一个方面是页面的内容方面<br><br>  （<span class="hljs-number">1</span>）通过文件合并、css 雪碧图、使用 <span class="hljs-keyword">base64 </span>等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。<br><br>  （<span class="hljs-number">2</span>）通过 DNS 缓存等机制来减少 DNS 的查询次数。<br><br>  （<span class="hljs-number">3</span>）通过设置缓存策略，对常用不变的资源进行缓存。<br><br>  （<span class="hljs-number">4</span>）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。<br><br>  （<span class="hljs-number">5</span>）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。<br><br>第二个方面是服务器方面<br><br>  （<span class="hljs-number">1</span>）使用 CDN 服务，来提高用户对于资源请求时的响应速度。<br><br>  （<span class="hljs-number">2</span>）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。<br><br>  （<span class="hljs-number">3</span>）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie<br><br>第三个方面是 CSS 和 <span class="hljs-keyword">JavaScript </span>方面<br><br>  （<span class="hljs-number">1</span>）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。<br><br>  （<span class="hljs-number">2</span>）避免使用 @import 标签。<br><br>  （<span class="hljs-number">3</span>）尽量把 <span class="hljs-keyword">js </span>脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。<br><br>  （<span class="hljs-number">4</span>）通过对 <span class="hljs-keyword">JavaScript </span>和 CSS 的文件进行压缩，来减小文件的体积。<br></code></pre></td></tr></table></figure><p>详细的资料可以参考：<br><a href="https://juejin.im/post/5b73ef38f265da281e048e51#heading-10">前端性能优化之雅虎35条军规</a><br><a href="https://juejin.im/entry/58709b9a128fe1006b29cd5d">你真的了解 gzip 吗？</a><br><a href="https://segmentfault.com/a/1190000012571492">前端性能优化之 gzip</a></p><h4 id="66-Chrome-中的-Waterfall-？"><a href="#66-Chrome-中的-Waterfall-？" class="headerlink" title="66. Chrome 中的 Waterfall ？"></a>66. Chrome 中的 Waterfall ？</h4><p>详细资料可以参考：<br><a href="https://blog.csdn.net/carian_violet/article/details/84954360">前端性能之 Chrome 的 Waterfall</a><br><a href="https://blog.csdn.net/csdn_girl/article/details/54911632">教你读懂网络请求的瀑布图</a><br><a href="https://www.zhihu.com/question/27085552/answer/35194131">前端妹子跟我抱怨她们的页面加载很慢的时候，如何在她面前优雅地装逼？</a></p><h4 id="67-扫描二维码登录网页是什么原理，前后两个事件是如何联系的？"><a href="#67-扫描二维码登录网页是什么原理，前后两个事件是如何联系的？" class="headerlink" title="67. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？"></a>67. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs applescript">核心过程应该是：浏览器获得一个临时 <span class="hljs-built_in">id</span>，通过长连接等待客户端扫描带有此 <span class="hljs-built_in">id</span> 的二维码后，从长连接中获得客户端上报给 serv<br>er的帐号信息进行展示。并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。在超时、网络断开、其他设备<br>上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。<br><br>我的理解<br><br>二维码登录网页的基本原理是，用户进入登录网页后，服务器生成一个 uid 来标识一个用户。对应的二维码对应了一个对应 uid <br>的链接，任何能够识别二维码的应用都可以获得这个链接，但是它们没有办法和对应登录的服务器响应。比如微信的二维码登录，只<br>有用微信识这个二维码才有效。当微信客户端打开这个链接时，对应的登录服务器就获得了用户的相关信息。这个时候登录网页根据<br>先前的长连接获取到服务器传过来的用户信息进行显示。然后提前预加载一些登录后可能用到的信息。当客户端点击确认授权登陆后，<br>服务器生成一个权限令牌给网页，网页之后使用这个令牌进行信息的交互过程。由于整个授权的过程都是在手机端进行的，因此能够<br>很好的防止 PC 上泛滥的病毒。并且在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程能够形成<br>有效的安全防护。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/20368066">微信扫描二维码登录网页</a></p><h4 id="68-Html-规范中为什么要求引用资源不加协议头http或者https？"><a href="#68-Html-规范中为什么要求引用资源不加协议头http或者https？" class="headerlink" title="68. Html 规范中为什么要求引用资源不加协议头http或者https？"></a>68. Html 规范中为什么要求引用资源不加协议头<code>http</code>或者<code>https</code>？</h4><p>&ensp;&ensp;如果用户当前访问的页面是通过 HTTPS 协议来浏览的，那么网页中的资源也只能通过 HTTPS 协议来引用，否则浏览器会出现警告信息，不同浏览器警告信息展现形式不同。</p><p>&ensp;&ensp;为了解决这个问题，我们可以省略 URL 的协议声明，省略后浏览器照样可以正常引用相应的资源，这项解决方案称为protocol-relative URL，暂且可译作协议相对 URL。</p><p>&ensp;&ensp;如果使用协议相对 URL，无论是使用 HTTPS，还是 HTTP 访问页面，浏览器都会以相同的协议请求页面中的资源，避免弹出类似的警告信息，同时还可以节省5字节的数据量。</p><p>详细资料可以参考：<br><a href="https://www.ludou.org/the-protocol-relative-url.html">协议相对 URL</a><br><a href="https://www.tuicool.com/articles/nEjU7b">Why you need protocol-relative URLs <em>now</em></a></p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Worker详解</title>
    <link href="/2023/10/24/Worker%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/10/24/Worker%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>Web Worker是一项 HTML5 的新特性，可以再web页面中创建后台线程，从而可以让 JavaSscript 在主线程运行的同时，在后台线程中执行耗时的操作。这使得 Web 应用程序更加的流畅，而不会出现 UI 卡顿或其它性能问题。在本文中，我们将详细讨论 Web Worker，包括用法、示例和使用场景。</p><h3 id="什么是Web-Worker"><a href="#什么是Web-Worker" class="headerlink" title="什么是Web Worker?"></a>什么是Web Worker?</h3><p>Web Worker是浏览器提供的JavaScript API，它允许在后台进程中运行脚本，而不会阻塞主线程。这意味着，及时脚本运行了很长时间，Web应用程序的UI仍然保持响应。</p><p>Web Worker有两种类型: Dedicated Worker 和 Shared Worker。Dedicated Worker 是指与一个页面绑定的 Worker，它仅能由该页面的脚本使用。而 Shared Worker 则可以被多个页面共享使用，这使得多个页面可以同时访问同一个后台线程。</p><h3 id="Web-Worker-的用法"><a href="#Web-Worker-的用法" class="headerlink" title="Web Worker 的用法"></a>Web Worker 的用法</h3><p>Web Worker 的用法非常简单，只需要调用 Worker() 构造函数即可创建一个 Worker 对象。例如，以下代码创建了一个 Dedicated Worker：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建 Dedicated Worker</span><br><span class="hljs-keyword">const</span> myWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;worker.js&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们将 Worker() 构造函数传递给要执行的脚本的 URL。此时，浏览器会创建一个新的后台线程，加载该 URL 指定的脚本，并在该线程中执行。</p><p>然后，我们可以在主线程中使用 postMessage() 方法向后台线程发送消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 向 Dedicated Worker 发送消息</span><br>myWorker.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在后台线程中，我们可以通过监听 message 事件来接收消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 监听消息</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;收到消息：&#x27;</span> + e.<span class="hljs-property">data</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用 addEventListener() 方法来监听 message 事件，并在事件处理程序中打印收到的消息。</p><h3 id="Web-Worker-的示例"><a href="#Web-Worker-的示例" class="headerlink" title="Web Worker 的示例"></a>Web Worker 的示例</h3><p>下面是一个使用 Web Worker 的简单示例。该示例中，我们将使用 Dedicated Worker 计算斐波那契数列的第 n 项，以展示 Web Worker 的使用方法。</p><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;title&gt;Web Worker 示例&lt;/title&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;h1&gt;Web Worker 示例&lt;/h1&gt;<br>    &lt;p&gt;计算斐波那契数列的第 &lt;input type=&quot;number&quot; id=&quot;num&quot; min=&quot;1&quot; value=&quot;1&quot;&gt; 项&lt;/p&gt;<br>    &lt;button id=&quot;calculate&quot;&gt;计算&lt;/button&gt;<br>    &lt;p id=&quot;result&quot;&gt;&lt;/p&gt;<br>    &lt;script src=&quot;worker.js&quot;&gt;&lt;/script&gt;<br>    &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-comment">// 获取元素</span><br><span class="hljs-keyword">const</span> numInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;num&#x27;</span>);<br><span class="hljs-keyword">const</span> calculateButton = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;calculate&#x27;</span>);<br><span class="hljs-keyword">const</span> resultElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;result&#x27;</span>);<br><br><span class="hljs-comment">// 创建 Dedicated Worker</span><br><span class="hljs-keyword">const</span> myWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;worker.js&#x27;</span>);<br><br><span class="hljs-comment">// 监听消息</span><br>myWorker.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  resultElement.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;结果：&#x27;</span> + e.<span class="hljs-property">data</span>;<br>&#125;);<br><br><span class="hljs-comment">// 监听错误</span><br>myWorker.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Worker 错误：&#x27;</span> + e.<span class="hljs-property">filename</span> + <span class="hljs-string">&#x27;:&#x27;</span> + e.<span class="hljs-property">lineno</span> + <span class="hljs-string">&#x27;: &#x27;</span> + e.<span class="hljs-property">message</span>);<br>&#125;);<br><br><span class="hljs-comment">// 处理点击事件</span><br>calculateButton.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> num = <span class="hljs-title class_">Number</span>(numInput.<span class="hljs-property">value</span>);<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(num) || num &lt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;请输入一个大于等于 1 的数字！&#x27;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 向 Dedicated Worker 发送消息</span><br>  myWorker.<span class="hljs-title function_">postMessage</span>(num);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="worker-js"><a href="#worker-js" class="headerlink" title="worker.js"></a>worker.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 监听消息</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-keyword">const</span> num = e.<span class="hljs-property">data</span>;<br><br>  <span class="hljs-comment">// 计算斐波那契数列的第 num 项</span><br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">fibonacci</span>(num);<br><br>  <span class="hljs-comment">// 向主线程发送消息</span><br>  self.<span class="hljs-title function_">postMessage</span>(result);<br>&#125;);<br><br><span class="hljs-comment">// 计算斐波那契数列的第 n 项</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span> || n === <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fibonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title function_">fibonacci</span>(n - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们首先获取页面中的一些元素，并创建了一个 Dedicated Worker。然后，我们监听了 message 事件和 error 事件，并分别在事件处理程序中更新页面中的结果元素或打印错误消息。</p><p>在处理点击事件时，我们首先验证了用户输入的数字，并向 Dedicated Worker 发送了一个消息。在后台线程中，我们计算了斐波那契数列的第 n 项，并向主线程发送了一个消息。最后，在 message 事件处理程序中，我们更新了页面中的结果元素。</p><h3 id="Web-Worker-的使用场景"><a href="#Web-Worker-的使用场景" class="headerlink" title="Web Worker 的使用场景"></a>Web Worker 的使用场景</h3><p>Web Worker 可以在很多场景下使用，特别是在需要处理大量数据或计算密集型任务时。以下是一些 Web Worker 的使用场景：</p><ul><li><strong>图像处理</strong>：Web Worker 可以用于处理图像操作，如旋转、裁剪、缩放、滤镜等。这可以提高图像处理的性能和响应速度。</li><li><strong>数据处理</strong>：Web Worker 可以用于处理大量数据，如数据集的过滤、排序、归纳、转换等。这可以提高数据处理的效率和准确性。</li><li><strong>计算密集型任务</strong>：Web Worker 可以用于处理计算密集型任务，如模拟、优化、预测、统计等。这可以提高计算任务的速度和精度。</li><li><strong>实时通信</strong>：Web Worker 可以用于实现实时通信，如聊天室、游戏、视频会议等。这可以提高实时通信的稳定性和性能。</li><li><strong>离线缓存</strong>：Web Worker 可以用于离线缓存，可以将常用的资源预先下载到客户端本地缓存中，并在无法访问互联网时使用缓存中的资源。这可以提高应用程序的可用性和响应速度，尤其是在移动设备上。</li><li><strong>多线程处理</strong>：Web Worker 可以用于实现多线程处理，如并行计算、任务分发、负载均衡等。这可以提高系统的并发性和可伸缩性。</li></ul><p>总之，Web Worker 可以用于任何需要在后台执行长时间运行的任务，以避免阻塞 UI 线程和提高应用程序的性能和响应速度。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>Web Worker 是一个非常有用的 API，它可以使我们在浏览器中使用多线程处理和提高应用程序的性能。虽然 Web Worker 的使用并不复杂，但我们需要注意一些事项，如数据传递、脚本加载、生命周期管理等。希望可以帮助你理解 Web Worker，并在实际项目中应用它。</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue3-hooks方法</title>
    <link href="/2023/09/16/Vue3-hooks%E6%96%B9%E6%B3%95/"/>
    <url>/2023/09/16/Vue3-hooks%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1-hooks定义"><a href="#1-hooks定义" class="headerlink" title="1. hooks定义"></a>1. hooks定义</h3><p>一些可复用的方法像钩子一样挂着，可以随时被引入和调用以实现高内聚低耦合的目标，应该都能算是hook</p><h3 id="2-为什么Vue3要用自定义Hook？"><a href="#2-为什么Vue3要用自定义Hook？" class="headerlink" title="2. 为什么Vue3要用自定义Hook？"></a>2. 为什么Vue3要用自定义Hook？</h3><p>结论：就是为了让Compoosition Api更好用更丰满，让写Vue3更畅快！像写诗一样写代码！<br>其实这个问题更深意义是为什么Vue3比Vue2更好！无外呼性能大幅度提升，其实编码体验也是Vue3的优点<strong>Composition Api的引入（解决Option Api在代码量大的情况下的强耦合）</strong> 让开发者有更好的开发体验。<br>个人碎碎念：但是这些所谓的提高开发体验都是需要开发者不断学习养成编码好习惯</p><h3 id="3-定义表格请求-hooks-uselist"><a href="#3-定义表格请求-hooks-uselist" class="headerlink" title="3. 定义表格请求 hooks uselist"></a>3. 定义表格请求 hooks uselist</h3><h4 id="3-1-js版"><a href="#3-1-js版" class="headerlink" title="3.1 js版"></a>3.1 js版</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElMessage</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus&#x27;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取数据操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> Function </span>&#125; api 请求的方法 required</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; <span class="hljs-variable">page</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; <span class="hljs-variable">size</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; isAuto 是否是分页请求</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; key  返回数据的键值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> callback </span>&#125; <span class="hljs-variable">cb</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type"> Object </span>&#125; &#123;<span class="hljs-type"> page,size,total,showSearch,loading,query,tableData,getList,reset </span>&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useList</span>(<span class="hljs-params">api, params, cb</span>) &#123;<br>  <span class="hljs-keyword">if</span>(!api) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;api is not found&#x27;</span>)<br>  <span class="hljs-keyword">const</span> page = <span class="hljs-title function_">ref</span>(params.<span class="hljs-property">page</span> || <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">const</span> size = <span class="hljs-title function_">ref</span>(params.<span class="hljs-property">size</span> || <span class="hljs-number">10</span>)<br>  <span class="hljs-keyword">const</span> total = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> query = <span class="hljs-title function_">ref</span>(&#123;&#125;)<br>  <span class="hljs-keyword">const</span> loading = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)<br>  <span class="hljs-keyword">const</span> showSearch = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">const</span> isAuto = <span class="hljs-title function_">ref</span>(params.<span class="hljs-property">isAuto</span> || <span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">const</span> tableData = <span class="hljs-title function_">ref</span>([])<br>  <span class="hljs-keyword">const</span> key = params.<span class="hljs-property">key</span> || <span class="hljs-string">&#x27;rows&#x27;</span><br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getList</span>(<span class="hljs-params">obj = &#123;&#125;</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!loading.<span class="hljs-property">value</span>) &#123;<br>      loading.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">const</span> defaultParams = params.<span class="hljs-property">params</span> || &#123;&#125;<br>      <span class="hljs-keyword">const</span> data = isAuto.<span class="hljs-property">value</span> ? <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(obj, &#123; <span class="hljs-attr">pageNum</span>: page.<span class="hljs-property">value</span>, <span class="hljs-attr">pageSize</span>: size.<span class="hljs-property">vlaue</span> &#125;, query.<span class="hljs-property">value</span>, defaultParams) : <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(obj, query.<span class="hljs-property">value</span>, defaultParams)<br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title function_">api</span>(data).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span><br>        tableData.<span class="hljs-property">value</span> = cb ? <span class="hljs-title function_">cb</span>(res[key]) : res[key]<br>        total.<span class="hljs-property">value</span> = res.<span class="hljs-property">total</span> || <span class="hljs-number">0</span><br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> &#123;<br>        loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span><br>        <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(c)<br>      &#125;)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params"></span>) &#123;<br>    query.<span class="hljs-property">value</span> = &#123;&#125;<br>    <span class="hljs-title function_">getList</span>()<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    page,<br>    size,<br>    total,<br>    query,<br>    loading,<br>    showSearch,<br>    tableData,<br>    getList,<br>    reset<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-ts版"><a href="#3-2-ts版" class="headerlink" title="3.2 ts版"></a>3.2 ts版</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; ref, <span class="hljs-title class_">Ref</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElMessage</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus&#x27;</span><br><br><span class="hljs-keyword">interface</span> resultData&lt;T&gt; &#123;<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span><br>  rows?: <span class="hljs-title class_">Array</span>&lt;T&gt;<br>  <span class="hljs-attr">data</span>: <span class="hljs-title class_">Array</span>&lt;T&gt;<br>  total?: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">msg</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> paramsFace &#123;<br>  page?: <span class="hljs-built_in">number</span><br>  size?: <span class="hljs-built_in">number</span><br>  isAuto?: <span class="hljs-built_in">boolean</span><br>  key?: <span class="hljs-built_in">string</span><br>  params?: <span class="hljs-built_in">any</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> resultFn&lt;searchForm, tableForm&gt; &#123;<br>  <span class="hljs-attr">page</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">number</span>&gt;<br>  <span class="hljs-attr">size</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">number</span>&gt;<br>  <span class="hljs-attr">total</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">number</span>&gt;<br>  <span class="hljs-attr">loading</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">boolean</span>&gt;<br>  <span class="hljs-attr">showSearch</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">boolean</span>&gt;<br>  <span class="hljs-attr">query</span>: <span class="hljs-title class_">Ref</span>&lt;searchForm&gt;<br>  <span class="hljs-attr">tableData</span>: <span class="hljs-title class_">Ref</span>&lt;tableForm[]&gt;<br>  <span class="hljs-attr">getList</span>: <span class="hljs-title class_">Function</span><br>  <span class="hljs-attr">reset</span>: <span class="hljs-title class_">Function</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取数据操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> Function </span>&#125; api 请求的方法 required</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> paramsFace </span>&#125; <span class="hljs-variable">params</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> callback </span>&#125; <span class="hljs-variable">cb</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type"> resultFn </span>&#125; &#123;<span class="hljs-type"> page,size,total,loading,query,tableData,getList,reset </span>&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> useList&lt;searchForm, tableForm&gt;(<span class="hljs-attr">api</span>: <span class="hljs-title class_">Function</span>, <span class="hljs-attr">params</span>: paramsFace, <span class="hljs-attr">cb</span>: <span class="hljs-title class_">Function</span>): resultFn &#123;<br>  <span class="hljs-keyword">if</span>(!api) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;api is not found&#x27;</span>)<br>  <span class="hljs-keyword">const</span> page = ref&lt;<span class="hljs-built_in">number</span>&gt;(params.<span class="hljs-property">page</span> || <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">const</span> size = ref&lt;<span class="hljs-built_in">number</span>&gt;(params.<span class="hljs-property">size</span> || <span class="hljs-number">10</span>)<br>  <span class="hljs-keyword">const</span> total = ref&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> query = ref&lt;searchForm&gt;(&#123;&#125;)<br>  <span class="hljs-keyword">const</span> loading = ref&lt;<span class="hljs-built_in">boolean</span>&gt;(<span class="hljs-literal">false</span>)<br>  <span class="hljs-keyword">const</span> showSearch = ref&lt;<span class="hljs-built_in">boolean</span>&gt;(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">const</span> isAuto = ref&lt;<span class="hljs-built_in">boolean</span>&gt;(params.<span class="hljs-property">isAuto</span> || <span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">const</span> tableData = ref&lt;tableForm[]&gt;([])<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span> = params.<span class="hljs-property">key</span> || <span class="hljs-string">&#x27;rows&#x27;</span><br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getList</span>(<span class="hljs-params">obj = &#123;&#125;</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!loading.<span class="hljs-property">value</span>) &#123;<br>      loading.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">const</span> <span class="hljs-attr">defaultParams</span>: searchForm = params.<span class="hljs-property">params</span> || &#123;&#125;<br>      <span class="hljs-keyword">const</span> data = isAuto.<span class="hljs-property">value</span> ? <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(obj, &#123; <span class="hljs-attr">pageNum</span>: page.<span class="hljs-property">value</span>, <span class="hljs-attr">pageSize</span>: size.<span class="hljs-property">vlaue</span> &#125;, query.<span class="hljs-property">value</span>, defaultParams) : <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(obj, query.<span class="hljs-property">value</span>, defaultParams)<br>      <span class="hljs-title function_">api</span>(data).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res: resultData&lt;tableForm&gt;</span>) =&gt;</span> &#123;<br>        loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span><br>        tableData.<span class="hljs-property">value</span> = cb ? <span class="hljs-title function_">cb</span>(res[key]) : res[key]<br>        total.<span class="hljs-property">value</span> = res.<span class="hljs-property">total</span> || <span class="hljs-number">0</span><br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> &#123;<br>        loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span><br>        <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(c)<br>      &#125;)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params"></span>) &#123;<br>    query.<span class="hljs-property">value</span> = &#123;&#125;<br>    <span class="hljs-title function_">getList</span>()<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    page,<br>    size,<br>    total,<br>    query,<br>    loading,<br>    showSearch,<br>    tableData,<br>    getList,<br>    reset<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-弹窗-useModal"><a href="#4-弹窗-useModal" class="headerlink" title="4. 弹窗 useModal"></a>4. 弹窗 useModal</h3><h4 id="4-1-js版"><a href="#4-1-js版" class="headerlink" title="4.1 js版"></a>4.1 js版</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref, <span class="hljs-title class_">Ref</span>, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 弹窗操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; defaultForm 默认参数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; add </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; edit </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type"> Object </span>&#125; &#123;<span class="hljs-type"></span></span><br><span class="hljs-type"><span class="hljs-comment"> *  visible,</span></span><br><span class="hljs-type"><span class="hljs-comment">    isTitle,</span></span><br><span class="hljs-type"><span class="hljs-comment">    modalForm,</span></span><br><span class="hljs-type"><span class="hljs-comment">    modalFormRefs,</span></span><br><span class="hljs-type"><span class="hljs-comment">    title,</span></span><br><span class="hljs-type"><span class="hljs-comment">    open,</span></span><br><span class="hljs-type"><span class="hljs-comment">    close,</span></span><br><span class="hljs-type"><span class="hljs-comment">    submit</span></span><br><span class="hljs-type"><span class="hljs-comment">    </span>&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useModal</span>(<span class="hljs-params">params</span>) &#123;<br>  <span class="hljs-keyword">const</span> visible = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)<br>  <span class="hljs-keyword">const</span> isTitle = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">const</span> modalForm = <span class="hljs-title function_">ref</span>(params.<span class="hljs-property">defaultForm</span> || &#123;&#125;)<br>  <span class="hljs-keyword">const</span> modalFormRefs = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-keyword">const</span> title = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> isTitle.<span class="hljs-property">value</span> ? <span class="hljs-string">&#x27;添加&#x27;</span> : <span class="hljs-string">&#x27;修改&#x27;</span>)<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">open</span>(<span class="hljs-params"></span>) &#123;<br>    visible.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span><br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">close</span>(<span class="hljs-params"></span>) &#123;<br>    visible.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span><br>    isTitle.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span><br>    modalForm.<span class="hljs-property">value</span> = params.<span class="hljs-property">defaultForm</span> || &#123;&#125;<br>    modalFormRefs.<span class="hljs-property">value</span> &amp;&amp; modalFormRefs.<span class="hljs-property">value</span>.<span class="hljs-title function_">resetFields</span>()<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">submit</span>(<span class="hljs-params"></span>) &#123;<br>    modalFormRefs.<span class="hljs-property">value</span> &amp;&amp; modalFormRefs.<span class="hljs-property">value</span>.<span class="hljs-title function_">validate</span>(<span class="hljs-function"><span class="hljs-params">valid</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span>(!valid) <span class="hljs-keyword">return</span><br>      isTitle.<span class="hljs-property">value</span> ? params.<span class="hljs-title function_">add</span>(modalForm.<span class="hljs-property">value</span>) : params.<span class="hljs-title function_">edit</span>(modalForm.<span class="hljs-property">value</span>)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    visible,<br>    isTitle,<br>    modalForm,<br>    modalFormRefs,<br>    title,<br>    open,<br>    close,<br>    submit<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-ts版"><a href="#4-2-ts版" class="headerlink" title="4.2 ts版"></a>4.2 ts版</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; ref, <span class="hljs-title class_">Ref</span>, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">interface</span> resultFn&lt;T&gt; &#123;<br>  <span class="hljs-attr">visible</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">boolean</span>&gt;<br>  <span class="hljs-attr">isTitle</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">boolean</span>&gt;<br>  <span class="hljs-attr">modalForm</span>: T<br>  <span class="hljs-attr">modalFormRefs</span>: <span class="hljs-built_in">any</span><br>  <span class="hljs-attr">title</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">string</span>&gt;<br>  <span class="hljs-attr">open</span>: <span class="hljs-title class_">Function</span><br>  <span class="hljs-attr">close</span>: <span class="hljs-title class_">Function</span><br>  <span class="hljs-attr">submit</span>: <span class="hljs-title class_">Function</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> defaultFace&lt;T&gt; &#123;<br>  defaultForm?: T<br>  add?: <span class="hljs-title class_">Function</span><br>  edit?: <span class="hljs-title class_">Function</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 弹窗操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; defaultForm 默认参数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; add </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; edit </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type"> resultFn </span>&#125; </span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> useModal&lt;paramsForm, resultForm&gt;(<span class="hljs-attr">params</span>: defaultFace&lt;paramsForm&gt;): resultFn&lt;resultForm&gt; &#123;<br>  <span class="hljs-keyword">const</span> visible = ref&lt;<span class="hljs-built_in">boolean</span>&gt;(<span class="hljs-literal">false</span>)<br>  <span class="hljs-keyword">const</span> isTitle = ref&lt;<span class="hljs-built_in">boolean</span>&gt;(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">const</span> modalForm = ref&lt;resultForm&gt;(params.<span class="hljs-property">defaultForm</span> || &#123;&#125;)<br>  <span class="hljs-keyword">const</span> modalFormRefs = ref&lt;<span class="hljs-built_in">any</span>&gt;(<span class="hljs-literal">null</span>)<br>  <span class="hljs-keyword">const</span> title = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> isTitle.<span class="hljs-property">value</span> ? <span class="hljs-string">&#x27;添加&#x27;</span> : <span class="hljs-string">&#x27;修改&#x27;</span>)<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">open</span>(<span class="hljs-params"></span>) &#123;<br>    visible.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span><br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">close</span>(<span class="hljs-params"></span>) &#123;<br>    visible.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span><br>    isTitle.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span><br>    modalForm.<span class="hljs-property">value</span> = params.<span class="hljs-property">defaultForm</span> || &#123;&#125;<br>    modalFormRefs.<span class="hljs-property">value</span> &amp;&amp; modalFormRefs.<span class="hljs-property">value</span>.<span class="hljs-property">resetFileds</span> &amp;&amp; modalFormRefs.<span class="hljs-property">value</span>.<span class="hljs-title function_">resetFileds</span>()<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">submit</span>(<span class="hljs-params"></span>) &#123;<br>    modalFormRefs.<span class="hljs-property">value</span> &amp;&amp; modalFormRefs.<span class="hljs-property">value</span>.<span class="hljs-title function_">validate</span>(<span class="hljs-function"><span class="hljs-params">valid</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span>(!valid) <span class="hljs-keyword">return</span><br>      isTitle.<span class="hljs-property">value</span> ? params.<span class="hljs-title function_">add</span>(modalForm.<span class="hljs-property">value</span>) : params.<span class="hljs-title function_">edit</span>(modalForm.<span class="hljs-property">value</span>)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    visible,<br>    isTitle,<br>    modalForm,<br>    modalFormRefs,<br>    title,<br>    open,<br>    close,<br>    submit<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue2组件通信方式</title>
    <link href="/2023/09/14/Vue2%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/09/14/Vue2%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-通过-props-和-emit-实现父子组件的传参"><a href="#1-通过-props-和-emit-实现父子组件的传参" class="headerlink" title="1. 通过 props 和 $emit 实现父子组件的传参"></a>1. 通过 props 和 $emit 实现父子组件的传参</h3><p>父组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">:message</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attr">update-message</span>=<span class="hljs-string">&quot;updateMessage&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Child.vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Parent&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">Child</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Parent Component&quot;</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello World&quot;</span> &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">updateMessage</span>(<span class="hljs-params">newMessage</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = newMessage</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>子组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;updateMessage&quot;</span>&gt;</span>更新<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Child&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">message</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">default</span>: <span class="hljs-string">&#x27;&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">updateMessage</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update-message&#x27;</span>, <span class="hljs-string">&#x27;更新了&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="2-通过-parent-和-children-实现父子组件通信"><a href="#2-通过-parent-和-children-实现父子组件通信" class="headerlink" title="2. 通过 $parent 和 $children 实现父子组件通信"></a>2. 通过 $parent 和 $children 实现父子组件通信</h3><ul><li>通过 $parent 访问到的是上一级父组件的实例，可以使用 $root 来访问根组件的实例</li><li>在组件中使用$children拿到的是所有的子组件的实例，它是一个数组，并且是无序的</li><li>在根组件 #app 上拿 $parent 得到的是 new Vue()的实例，在这实例上再拿 $parent 得到的是undefined，而在最底层的子组件拿 $children 是个空数组<br>$children 的值是数组，而 $parent是个对象</li></ul><p>父组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Child.vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Parent&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">Child</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Parent Component&quot;</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello World&quot;</span> &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>子组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Child&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;测试&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello word&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>.<span class="hljs-property">title</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="3-兄弟组件传值-eventBus-事件总线"><a href="#3-兄弟组件传值-eventBus-事件总线" class="headerlink" title="3. 兄弟组件传值 eventBus 事件总线"></a>3. 兄弟组件传值 eventBus 事件总线</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">新建一个.<span class="hljs-property">js</span>的文件作为中间件，作为事件中心管理组件之间的通信，通过 $emit 自定义事件，$on 监听自定义事件<br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">// 定义一个新的vue实例作为事件中心，利用它来监听本身的自定义事件</span><br><span class="hljs-keyword">const</span> tmpCom = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> tmpCom<br></code></pre></td></tr></table></figure><p>A组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>A组件<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;我是A组件&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;maxbrother&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-comment">//引入中间件</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> tmpCom <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/router/middleware&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  data () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">brotherdata</span>: <span class="hljs-string">&#x27;我是大兄弟&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    maxbrother () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-comment">// 触发事件中心的max-brother事件 </span></span></span><br><span class="language-javascript"><span class="language-xml">      tmpCom.$emit(<span class="hljs-string">&#x27;max-brother&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">brotherdata</span>)</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">brotherdata</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  created () &#123;&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>B组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>B组件<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;brother&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">//引入中间件</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> tmpCom <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/router/middleware&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  data () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">brother</span>: <span class="hljs-string">&#x27;我是B组件&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  mounted () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 监听事件中心的max-brother事件</span></span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-comment">// 这里的第二个参数必须使用箭头函数</span></span></span><br><span class="language-javascript"><span class="language-xml">    tmpCom.$on(<span class="hljs-string">&#x27;max-brother&#x27;</span>, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">brother</span> = val</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="4-注入依赖-provide-inject-使用"><a href="#4-注入依赖-provide-inject-使用" class="headerlink" title="4. 注入依赖 provide&#x2F;inject 使用"></a>4. 注入依赖 provide&#x2F;inject 使用</h3><p>这种方式就是vue中依赖注入，该方法用于 父子组件之间 的通信。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方式来进行传值。就不用一层一层的传递数据了。</p><p>provide和inject是vue提供的两个钩子，和data、methods是同级的。并且provide的书写形式和data一样。</p><ul><li>provide 钩子用来发送数据或方法。</li><li>inject钩子用来接收数据或方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//父组件  </span><br>data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">pimsg</span>: <span class="hljs-string">&#x27;我是父组件的值&#x27;</span>,<br>      <span class="hljs-attr">num</span>: <span class="hljs-number">99999</span><br>    &#125;<br>  &#125;,<br>  provide () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">num</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span><br>    &#125;<br>  &#125;<br><br><span class="hljs-comment">//子组件</span><br> <span class="hljs-attr">inject</span>: [<span class="hljs-string">&#x27;num&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="5-ref-refs"><a href="#5-ref-refs" class="headerlink" title="5. ref &#x2F; $refs"></a>5. ref &#x2F; $refs</h3><p>这种方式也是实现父子组件之间的通信</p><p>ref：这个属性用在子组件上，它的用法就指向了子组件的实例，可以通过实例来访问组件的数据和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//子组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;我是张三&#x27;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    sayHello () &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是李四&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//父组件</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">components</span>: &#123; child &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    mounted () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">child</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// &#x27;我是张三&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">child</span>.<span class="hljs-title function_">sayHello</span>();  <span class="hljs-comment">// 我是李四</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>markdown基础语法</title>
    <link href="/2023/09/12/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/09/12/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>之前写文章做记录都是直接码字，码字虽然方便，但是遇到代码部分就很dan疼，尤其是代码格式化很麻烦，开始用markdown之后就觉得特别方便，简单记录下基础语法。</p><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h3><p>标题主要是通过在文字前边加不同数量的 # 去完成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">一级标题</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 二级标题</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## 三级标题</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">### 四级标题</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#### 五级标题</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">##### 六级标题</span></span><br></code></pre></td></tr></table></figure><img src="/images/markdown/title.png" /><h3 id="2-正文内容"><a href="#2-正文内容" class="headerlink" title="2. 正文内容"></a>2. 正文内容</h3><p>正文内容直接去打字写就可以了，需要注意的是如果要另起一段的话，是需要按两次回车的，也就是两段之间需要空一行</p><h3 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3. 代码块"></a>3. 代码块</h3><p>代码块内容直接放在两个 中间即可，可以在上边后边加上语言类型，会高亮显示语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span> is javascript language<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">name</span>(<span class="hljs-params"></span>)&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="4-行内代码"><a href="#4-行内代码" class="headerlink" title="4. 行内代码"></a>4. 行内代码</h3><p>行内代码讲代码写在行内的 &#96;&#96; 中间即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">行内代码可以直接书写，`this is inline code` 样式<br></code></pre></td></tr></table></figure><p>行内代码可以直接书写，<code>this is inline code</code> 样式</p><h3 id="5-有序列表和无序列表"><a href="#5-有序列表和无序列表" class="headerlink" title="5. 有序列表和无序列表"></a>5. 有序列表和无序列表</h3><p>有序列表通过文字前边添加1.2.3.4等即可，二级结构通过前边加空格或tab就可以</p><p>无序列表通过文字前边添加 * 或者 - 就可以，二级结构同样的方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">有序列表: <br>1. 第一个<br>2. 第二个<br>3. 第三个<br>  1. 第三点的第一个<br>  2. 第三点的第二个<br><br>无序列表: <br>* 第一个<br>- 第二个<br>  - 第二个的第一个<br>  - 第二个的第二个<br>- 第三个<br></code></pre></td></tr></table></figure><p>有序列表: </p><ol><li>第一个</li><li>第二个</li><li>第三个</li><li>第三点的第一个</li><li>第三点的第二个</li></ol><p>无序列表: </p><ul><li>第一个</li></ul><ul><li>第二个<ul><li>第二个的第一个</li><li>第二个的第二个</li></ul></li><li>第三个</li></ul><h3 id="6-文本加粗、倾斜和删除线"><a href="#6-文本加粗、倾斜和删除线" class="headerlink" title="6. 文本加粗、倾斜和删除线"></a>6. 文本加粗、倾斜和删除线</h3><p>文本的特殊格式比较简单，加粗是文本两侧加<strong>，倾斜是文本两侧加<em>，加粗和倾斜一起是文本两侧加</em></strong>，删除线是文本两侧加~~</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">**加粗**<br>*倾斜*<br>***加粗和倾斜***<br>~~删除线~~<br></code></pre></td></tr></table></figure><p><strong>加粗</strong><br><em>倾斜</em><br><em><strong>加粗和倾斜</strong></em><br><del>删除线</del></p><h3 id="7-引用文本"><a href="#7-引用文本" class="headerlink" title="7. 引用文本"></a>7. 引用文本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">引用文本</span><br></code></pre></td></tr></table></figure><blockquote><p>引用文本</p></blockquote><h3 id="8-分割线"><a href="#8-分割线" class="headerlink" title="8. 分割线"></a>8. 分割线</h3><p>分割线写法很简单，只需要使用三个或三个以上 *** 或者 — 即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">***<br>******<br>---<br>------<br></code></pre></td></tr></table></figure><hr><hr><hr><hr><h3 id="9-图片"><a href="#9-图片" class="headerlink" title="9. 图片"></a>9. 图片</h3><ol><li>[alt](url title)方式</li></ol><p>图片的引用的基本语法是：[alt](url title)，alt为图片下方文字，title为图片说明，即鼠标放上去后显示文案，url为图片路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">![风景图](https://gimg2.baidu.com/image_search/src=http%3A%2F%2F1812.img.pp.sohu.com.cn%2Fimages%2Fblog%2F2009%2F11%2F18%2F18%2F8%2F125b6560a6ag214.jpg&amp;refer=http%3A%2F%2F1812.img.pp.sohu.com.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1621561120&amp;t=d99b987e1a68ed50f149aa611e2ab62a &quot;风景图片&quot;)<br></code></pre></td></tr></table></figure><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F1812.img.pp.sohu.com.cn%2Fimages%2Fblog%2F2009%2F11%2F18%2F18%2F8%2F125b6560a6ag214.jpg&refer=http%3A%2F%2F1812.img.pp.sohu.com.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1621561120&t=d99b987e1a68ed50f149aa611e2ab62a" alt="风景图" title="风景图片"></p><ol start="2"><li>html标签方式</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;div align=center&gt;&lt;img width=400 src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2F1812.img.pp.sohu.com.cn%2Fimages%2Fblog%2F2009%2F11%2F18%2F18%2F8%2F125b6560a6ag214.jpg&amp;refer=http%3A%2F%2F1812.img.pp.sohu.com.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1621561120&amp;t=d99b987e1a68ed50f149aa611e2ab62a&quot; /&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><div align=center><img width=400 src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F1812.img.pp.sohu.com.cn%2Fimages%2Fblog%2F2009%2F11%2F18%2F18%2F8%2F125b6560a6ag214.jpg&refer=http%3A%2F%2F1812.img.pp.sohu.com.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1621561120&t=d99b987e1a68ed50f149aa611e2ab62a" /></div><h3 id="10-超链接"><a href="#10-超链接" class="headerlink" title="10. 超链接"></a>10. 超链接</h3><p>超链接的格式和图片结构基本差不多，[超链接名称](url title)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[程序员学习圣地: 掘金](https://juejin.cn/)<br></code></pre></td></tr></table></figure><p><a href="https://juejin.cn/">程序员学习圣地: 掘金</a></p><h3 id="11-表格"><a href="#11-表格" class="headerlink" title="11. 表格"></a>11. 表格</h3><p>表格的写法看上去很有意思，第一行可以写标题，然后第二行通过特殊标识区分表头和表内容，同时默认表格文字左对齐，如果想文本居中，可以通过第二行标识进行控制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">默认表格：<br>姓名 | 年龄 | 班级 | 成绩<br>-|:-|:-|:-|<br>张三 | 20 | 一班 | 90<br>张三 | 20 | 一班 | 80<br>张三 | 20 | 一班 | 70<br>张三 | 20 | 一班 | 99<br><br>表格文本居中：(注意第二行变化)<br>姓名 | 年龄 | 班级 | 成绩<br>:-:|:-:|:-:|:-:|<br>张三 | 20 | 一班 | 90<br>张三 | 20 | 一班 | 80<br>张三 | 20 | 一班 | 70<br>张三 | 20 | 一班 | 99<br></code></pre></td></tr></table></figure><p>默认表格：</p><table><thead><tr><th>姓名</th><th align="left">年龄</th><th align="left">班级</th><th align="left">成绩</th></tr></thead><tbody><tr><td>张三</td><td align="left">20</td><td align="left">一班</td><td align="left">90</td></tr><tr><td>张三</td><td align="left">20</td><td align="left">一班</td><td align="left">80</td></tr><tr><td>张三</td><td align="left">20</td><td align="left">一班</td><td align="left">70</td></tr><tr><td>张三</td><td align="left">20</td><td align="left">一班</td><td align="left">99</td></tr></tbody></table><p>表格文本居中：(注意第二行变化)</p><table><thead><tr><th align="center">姓名</th><th align="center">年龄</th><th align="center">班级</th><th align="center">成绩</th></tr></thead><tbody><tr><td align="center">张三</td><td align="center">20</td><td align="center">一班</td><td align="center">90</td></tr><tr><td align="center">张三</td><td align="center">20</td><td align="center">一班</td><td align="center">80</td></tr><tr><td align="center">张三</td><td align="center">20</td><td align="center">一班</td><td align="center">70</td></tr><tr><td align="center">张三</td><td align="center">20</td><td align="center">一班</td><td align="center">99</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>函数节流与防抖</title>
    <link href="/2023/09/12/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/"/>
    <url>/2023/09/12/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/</url>
    
    <content type="html"><![CDATA[<h3 id="1-初步了解函数节流与防抖"><a href="#1-初步了解函数节流与防抖" class="headerlink" title="1. 初步了解函数节流与防抖"></a>1. 初步了解函数节流与防抖</h3><blockquote><p>函数节流与防抖是优化高频执行js代码的一种手段，js中的一些事件，如浏览器的: resize、scroll、鼠标的mousemove、mouseover、input输入框的keypress等事件<br>在触发时，会不断的调用绑定的回调函数，极大的浪费了资源，降低前端性能，为了优化体验，需要对这类事件进行调用次数的限制。即: 限制函数的执行次数</p></blockquote><blockquote><p>节流: 减少一段时间的触发频率(控制触发次数)<br>防抖: 通过setTimeout的方式，在一定时间间隔内，将多次触发变为最后一次触发</p></blockquote><h3 id="2-函数防抖"><a href="#2-函数防抖" class="headerlink" title="2. 函数防抖"></a>2. 函数防抖</h3><ol><li>为什么需要防抖</li></ol><blockquote><p>前端开发过程中，有一些事件，常见的例如，onresize，scroll，mousemove ,mousehover等，会被频繁触发（短时间内多次触发），不做限制的话，有可能一秒之内执<br>行几十次、几百次，如果在这些函数内部执行了其他函 数，尤其是执行了操作DOM 的函数（浏览器操作 DOM 是很耗费性能的），那不仅会浪费计算机资源，还会降低程<br>序运行速度，甚至造成浏览器卡死、崩溃。</p></blockquote><ol start="2"><li>概念与应用</li></ol><blockquote><p>概念：函数防抖（debounce），就是指触发事件后，在 n 秒内函数只能执行一次，如果触发事件后在 n 秒内又触发了事件，则会重新计算函数延执行时间。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> id=<span class="hljs-string">&quot;test&quot;</span> /&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> test = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#test&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span></span></span><br><span class="language-javascript"><span class="language-xml">  test.<span class="hljs-property">oninput</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">if</span>(timer) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-built_in">clearTimeout</span>(timer)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;, <span class="hljs-number">400</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>进行封装</li></ol><blockquote><p>对函数进行封装，封装后：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> id=<span class="hljs-string">&quot;test&quot;</span> /&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> test = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#test&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span></span></span><br><span class="language-javascript"><span class="language-xml">  test.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, time = <span class="hljs-number">500</span></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">if</span>(timer) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-built_in">clearTimeout</span>(timer)</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        fn.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;, time)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="4"><li>函数防抖应用场景</li></ol><ul><li>搜索框搜索输入。只需用户最后一次输入完，再发送请求；</li><li>用户名、手机号、邮箱输入验证；</li><li>浏览器窗口大小改变后，只需窗口调整完后，再执行 resize 事件中的代码，防止重复渲染</li></ul><h3 id="3-函数节流"><a href="#3-函数节流" class="headerlink" title="3. 函数节流"></a>3. 函数节流</h3><ol><li>函数节流概念与应用</li></ol><blockquote><p>概念： 限制一个函数在一定时间内只能执行一次。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body style=<span class="hljs-string">&quot;height: 2000px;&quot;</span>&gt;&lt;/body&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span>= <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">if</span>(flag)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;@&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">              flag = <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">          &#125;,<span class="hljs-number">500</span>)  </span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      flag = <span class="hljs-literal">false</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="2"><li>函数封装</li></ol><blockquote><p>对函数进行封装，封装后：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body style=<span class="hljs-string">&quot;height: 2000px;&quot;</span>&gt;&lt;/body&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span>= <span class="hljs-title function_">throttle</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;@&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, time = <span class="hljs-number">500</span></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">if</span>(flag) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">           flag = <span class="hljs-literal">false</span></span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">             fn.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)</span></span><br><span class="language-javascript"><span class="language-xml">             flag = <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">          &#125;, time)</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>节流的应用场景</li></ol><ul><li>懒加载、滚动加载、加载更多或监听滚动条位置；</li><li>百度搜索框，搜索联想功能；</li><li>防止高频点击提交，防止表单重复提交；</li></ul><h3 id="4-函数防抖和节流的比较"><a href="#4-函数防抖和节流的比较" class="headerlink" title="4. 函数防抖和节流的比较"></a>4. 函数防抖和节流的比较</h3><ol><li>相同点</li></ol><blockquote><p>都可以通过使用 setTimeout 实现。<br>目的都是，降低回调执行频率，节省计算资源。</p></blockquote><ol start="2"><li>不同点</li></ol><blockquote><p>函数防抖: 在一段连续操作结束后，处理回调，关注一定时间连续触发的事件只在最后执行一次。<br>函数节流: 在一段连续操作中，每一段时间只执行一次，侧重于一段时间内只执行一次。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 博客搭建和使用教程</title>
    <link href="/2023/08/28/init-hexo/"/>
    <url>/2023/08/28/init-hexo/</url>
    
    <content type="html"><![CDATA[<p>从零搭建一个属于自己的静态博客网站，使用Hexo博客框架并部署到 Github，让您可以在不用购买云服务器的情况下拥有一个属于自己的博客网站。</p><h3 id="Hexo-介绍"><a href="#Hexo-介绍" class="headerlink" title="Hexo 介绍"></a>Hexo 介绍</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>官方地址: <u><a href="https://hexo.io/zh-cn/index.html">Hexo</a></u></p><h3 id="第一章-前期准备"><a href="#第一章-前期准备" class="headerlink" title="第一章 前期准备"></a>第一章 前期准备</h3><h4 id="1-1-安装前所需环境介绍"><a href="#1-1-安装前所需环境介绍" class="headerlink" title="1.1 安装前所需环境介绍"></a>1.1 安装前所需环境介绍</h4><p>安装 Hexo 之前，需要确保您的 PC 中已经安装以下工具:</p><ul><li>Node.js <u><a href="https://nodejs.org/en">地址: Node.js (nodejs.org)</a></u></li><li>Git <u><a href="https://git-scm.com/">地址: Git (git-scm.com)</a></u></li></ul><p>如果您的电脑已经具备所需工具，那么您可以直接进入第二章开始安装 Hexo 了。</p><p>如果您还未安装这两款工具，那么请按照以下步骤进行安装。</p><h4 id="1-2-安装-Git"><a href="#1-2-安装-Git" class="headerlink" title="1.2 安装 Git"></a>1.2 安装 Git</h4><ul><li>官方下载地址: <u><a href="https://git-scm.com/download/win">Git - Downloading Package (git-scm.com)</a></u></li><li>注意事项: 建议选择 64-bit Git for Windows Setup，并且安装时要勾选 Add to PATH 选项</li></ul><img src="/images/initHexo/Git.png" /><ul><li>安装后验证: 在 cmd 中输入命令 git –version, 查看 Git 版本</li></ul><h4 id="1-3-安装-Node-js"><a href="#1-3-安装-Node-js" class="headerlink" title="1.3 安装 Node.js"></a>1.3 安装 Node.js</h4><ul><li>官方下载地址: <u><a href="https://nodejs.org/en">Node.js (nodejs.org)</a></u></li><li>注意事项: 使用 Node.js 官方安装程序时，请确保勾选 Add to PATH 选项（默认已勾选）</li></ul><img src="/images/initHexo/Node.png" /><ul><li>安装后验证: 在 cmd 中输入命令 node -v, 查看 Node 版本</li></ul><hr><p>至此，您已经完成了安装 Hexo 所需的所有额外环境，接下来就可以安装 Hexo 了</p><h3 id="第二章-安装-Hexo"><a href="#第二章-安装-Hexo" class="headerlink" title="第二章 安装 Hexo"></a>第二章 安装 Hexo</h3><h4 id="2-1-安装-Hexo"><a href="#2-1-安装-Hexo" class="headerlink" title="2.1 安装 Hexo"></a>2.1 安装 Hexo</h4><ul><li>命令: npm install -g hexo-cli<br>说明: -g 表示全局安装，hexo-cli 为所安装的包</li><li>安装后验证: 在 cmd 中输入命令 hexo -v, 可查看 hexo 版本</li></ul><img src="/images/initHexo/hexo.png" /><h4 id="2-2-注意事项"><a href="#2-2-注意事项" class="headerlink" title="2.2 注意事项"></a>2.2 注意事项</h4><p>建议永远安装最新版本的 Hexo，以及 <u><a href="https://hexo.io/zh-cn/docs/index.html#%E5%AE%89%E8%A3%85%E5%89%8D%E6%8F%90">推荐的 Node.js 版本</a></u></p><table><thead><tr><th>Hexo版本</th><th>Node版本</th></tr></thead><tbody><tr><td>6.0+</td><td>12.13.0</td></tr><tr><td>5.0+</td><td>10.13.0</td></tr><tr><td>4.1 - 4.2</td><td>8.10</td></tr><tr><td>4.0</td><td>8.6</td></tr><tr><td>3.3 - 3.9</td><td>6.9</td></tr><tr><td>3.2 - 3.3</td><td>0.12</td></tr><tr><td>3.0 - 3.1</td><td>0.10 or iojs</td></tr><tr><td>0.01 - 2.8</td><td>0.10</td></tr></tbody></table><hr><p>至此，您已成成功安装了 Hexo，接下来进入 Github 的配置吧!</p><h3 id="第三章-配置-Github"><a href="#第三章-配置-Github" class="headerlink" title="第三章 配置 Github"></a>第三章 配置 Github</h3><p>如果您还没有 Gihub 账户，请注册一个 Github 账户吧!</p><h4 id="3-1-在-Github-上创建仓库"><a href="#3-1-在-Github-上创建仓库" class="headerlink" title="3.1 在 Github 上创建仓库"></a>3.1 在 Github 上创建仓库</h4><ul><li>新建一个名为: <u><a href="http://username.github.io/">http://username.github.io</a></u> 的仓库(username 为您的 Github 用户名)</li><li>比如，如果您的 github 用户名是 test，那么您就新建名为 <u><a href="http://test.github.io/">http://test.github.io</a></u> 的仓库（必须是您的用户名，其它名称无效），将来你的网站访问地址就是 <u><a href="https://test.github.io/">https://test.github.io</a></u> 了。由此可见，每一个 github 账户最多只能创建一个这样可以直接使用域名访问的仓库。</li></ul><img style="display: flex;width:80%;margin: 0 auto;" src="/images/initHexo/github.png"/><ul><li>注意事项:<br>注册的邮箱一定要验证，否则不会成功;<br>仓库名字必须是：<u><a href="http://username.github.io/">http://username.github.io</a></u>，其中 username 是你的用户名;<br>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久</li></ul><h4 id="3-2-配置-SSH-免密登录"><a href="#3-2-配置-SSH-免密登录" class="headerlink" title="3.2 配置 SSH 免密登录"></a>3.2 配置 SSH 免密登录</h4><p>为什么要配置这个呢？因为您提交代码肯定要拥有您的 github 权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用 ssh key 来解决本地和服务器的连接问题。<br>注: 如果您已经配置过 SSH，可跳过此步骤</p><p>步骤:</p><ol><li><p>首先打开电脑文件夹，找到 C:\Users\您的用户名\ .ssh文件夹并删除(如果没有，则直接进入第二步)</p></li><li><p>在 C:\Users\您的用户名 文件夹下右键打开 Git Bash Here 输入命令: ssh-keygen -t rsa -C “你的github登录邮箱” 生成.ssh秘钥，输入后连敲三次回车，出现下图情况代表成功</p></li></ol><img src="/images/initHexo/github-ssh.png" /><ol start="3"><li><p>生成了一个新的 C:\Users\您的用户名\ .ssh文件夹，打开这个文件夹，找到 .ssh\id_rsa.pub 文件，记事本打开并复制里面的内容</p></li><li><p>打开您的 github 主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key，把复制的内容粘贴进去，title 随便填，保存即可，我们的公钥就添加成功了，设置好如下图:</p></li></ol><img src="/images/initHexo/github-key.png" /><ol start="5"><li>检测是否设置成功:</li></ol><p>输入命令: ssh -T <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#x74;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;">&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#x74;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;</a></p><img src="/images/initHexo/github-success.png" /><p>看到以上信息说明 SSH 已配置成功!</p><ol start="6"><li>此外您还需要如下配置:</li></ol><p>命令: git config –global user.name “您的 Github username” &#x2F;&#x2F; 注意是 username, 而非昵称</p><p>命令: git config –global user.email “<a href="mailto:&#x78;&#120;&#x78;&#64;&#x71;&#113;&#46;&#99;&#111;&#x6d;">&#x78;&#120;&#x78;&#64;&#x71;&#113;&#46;&#99;&#111;&#x6d;</a>“ &#x2F;&#x2F; 填写您的 github 注册邮箱</p><hr><p>至此，您已经成功配置好了 Github，接下来开始搭建个人博客吧!</p><h3 id="第四章-使用-Hexo-搭建博客"><a href="#第四章-使用-Hexo-搭建博客" class="headerlink" title="第四章 使用 Hexo 搭建博客"></a>第四章 使用 Hexo 搭建博客</h3><h4 id="4-1-初始化"><a href="#4-1-初始化" class="headerlink" title="4.1 初始化"></a>4.1 初始化</h4><ol><li><p>在电脑的某个磁盘或路径新建一个名为 hexo 的文件夹(名字可以随便取)，比如我的是 D:\hexo，由于这个文件夹将来就作为您存放代码的地方，所以最好不要随便放</p></li><li><p>在 D:\hexo 文件夹下右键打开 Git Bash Here(控制台)，输入命令: hexo init 进行初始化</p></li></ol><img src="/images/initHexo/hexo-init.png" /><ul><li>hexo 会自动下载一些文件到这个目录，包括 node_modules，目录结构如下图:</li></ul><img src="/images/initHexo/hexo-file.png" /><ol start="3"><li><p>执行命令: hexo g 会在 public 文件夹下生成相关的 html 文件，这些文件将来需要提交到 Github 上</p></li><li><p>执行命令: hexo s 可以开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到博客内容</p></li></ol><h4 id="4-2-将博客部署到-Github"><a href="#4-2-将博客部署到-Github" class="headerlink" title="4.2 将博客部署到 Github"></a>4.2 将博客部署到 Github</h4><ol><li>在 D:\hexo 目录下安装 hexo-deployer-git 插件</li></ol><ul><li>命令: <code>npm install hexo-deployer-git --save</code></li></ul><ol start="2"><li>编辑 D:\hexo 目录下的 _config.yml 文件，在文件末尾添加如下内容:</li></ol><img src="/images/initHexo/upload-git.png" /><ul><li>注意: 其中 repository 中的内容即为 github 个人主页链接地址</li></ul><ol start="3"><li>在 D:\hexo 目录下，输入命令: hexo d 将本地 blog 推送到 github 远程仓库，也可能需要输入 username &amp; pwd</li></ol><p>推送成功后，即可通过 <a href="https://jqstudy.gitee.io/">https://jqstudy.gitee.io/</a> 访问个人博客了!</p><hr><p>至此，您已经会使用 Hexo 搭建博客了，但是您会发现此时访问博客主页，页面很不美观，那么接下来就对您的博客进行美化吧!</p><h3 id="第五章-更换主题"><a href="#第五章-更换主题" class="headerlink" title="第五章 更换主题"></a>第五章 更换主题</h3><p>在 D:\hexo 目录下有一个 themes 文件夹，该文件夹下存放着 hexo 所使用的主题</p><h4 id="5-1-搜索主题"><a href="#5-1-搜索主题" class="headerlink" title="5.1 搜索主题"></a>5.1 搜索主题</h4><ul><li>hexo 官方提供了很多主题供我们使用，地址: <a href="https://hexo.io/themes/">Themes | Hexo</a>, 选择喜欢的主题并点击即可跳转至 github</li><li>笔者使用了 github 上面一个大佬制作的主题，地址: <a href="https://github.com/JoeyBling/hexo-theme-yilia-plus">JoeyBling&#x2F;hexo-theme-yilia-plus: 一个简洁优雅的hexo主题 A simple and elegant theme for hexo. (github.com)</a></li><li>您可以在 github 中直接搜索 hexo 主题</li></ul><h4 id="5-2-下载主题"><a href="#5-2-下载主题" class="headerlink" title="5.2 下载主题"></a>5.2 下载主题</h4><ol><li><p>在 D:\hexo 目录下右键 Git Bash Here(控制台)</p></li><li><p>执行命令: <code>git clone 主题http链接 themes/主题名称</code> 将主题下载至 themes 文件夹下</p></li></ol><img src="/images/initHexo/git-clone.png" /><ul><li>可以在该文件夹下查看是否下载成功</li></ul><img src="/images/initHexo/git-clone-file.png" /><h4 id="5-3-使用主题"><a href="#5-3-使用主题" class="headerlink" title="5.3 使用主题"></a>5.3 使用主题</h4><ul><li>打开 D:\hexo 目录下的 _config.yml 文件，在里面找到 theme: landscape改为theme: yilia-plus(yilia-plus为我们要使用的主题名)，然后执行 <code>hexo clean</code> 先删除旧的 html 文件，再执行 <code>hexo g</code> 重新生成，再执行 <code>hexo d</code> 推送到远程仓库</li></ul><img src="/images/initHexo/theme.png" /><ul><li>在浏览器输入相应域名，发现主题已更换</li><li>注意: 可能需要等一段时间刷新才更换 please be patient</li></ul><h4 id="5-4-修改主题内容"><a href="#5-4-修改主题内容" class="headerlink" title="5.4 修改主题内容"></a>5.4 修改主题内容</h4><p>您可以在 themes&#x2F;fluid 文件夹中查看该主题的内容，并可编辑该文件夹中的 _config.yml 文件修改主题样式</p><img src="/images/initHexo/update-theme.png" /><ul><li>注意: 记得编辑根目录下的 _config.yml 文件，将信息修改为自己的</li></ul><img src="/images/initHexo/Site.png" /><h3 id="第六章-使用-Typora-编写博客"><a href="#第六章-使用-Typora-编写博客" class="headerlink" title="第六章 使用 Typora 编写博客"></a>第六章 使用 Typora 编写博客</h3><h4 id="6-1-Typora-介绍"><a href="#6-1-Typora-介绍" class="headerlink" title="6.1 Typora 介绍"></a>6.1 Typora 介绍</h4><p>Typora 是一款轻便简洁的 Markdown 编辑器，支持即时渲染技术，这也是与其他 Markdown 编辑器最显著的区别。即时渲染使得你写Markdown 就像是写 Word 文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。</p><p>优点:</p><ul><li>简洁美观</li><li>实时预览</li><li>扩展语法</li><li>跨平台</li></ul><h4 id="6-2-安装-Typora"><a href="#6-2-安装-Typora" class="headerlink" title="6.2 安装 Typora"></a>6.2 安装 Typora</h4><p>官网: <a href="https://typoraio.cn/">Typora 官方中文站 (typoraio.cn)</a></p><p>遗憾的是去年 Typora 还是免费的，今年的新版居然开始收费了。</p><p>为此，我为大家准备了旧版免费的安装包 <a href="https://www.aliyundrive.com/s/7Mfocz2n4fc">typora-setup-x64.exe</a> 提取码: <code>ah61</code></p><h4 id="6-3-写博客"><a href="#6-3-写博客" class="headerlink" title="6.3 写博客"></a>6.3 写博客</h4><ol><li><p>在 D:\hexo 目录下，通过输入命令: hexo new “文章 title” 会在 &#x2F;source 文件夹下生成对应文章的 .md 文件，然后就可以通过 Typora 打开此文件编写文章并保存了</p></li><li><p>当您写完该篇文章后，依次输入以下命令:</p></li></ol><p><code>hexo clean</code> 删除 public 文件夹，即删除旧的博客文章</p><p><code>hexo g</code> 生成 public 文件夹，即生成新的博客文章相关 html 文件</p><p><code>hexo d</code> 将博客推送到 github</p><h4 id="6-4-向-Hexo-博客中插入图片"><a href="#6-4-向-Hexo-博客中插入图片" class="headerlink" title="6.4 向 Hexo 博客中插入图片"></a>6.4 向 Hexo 博客中插入图片</h4><p>Hexo 有多种图片插入方式，可以将图片存放在本地引用或者将图片放在 CDN 上引用。</p><ol><li>本地引用–绝对路径</li></ol><p>当 Hexo 项目中只用到少量图片时，可以将图片统一放在 source&#x2F;images 文件夹中，通过 markdown 语法访问它们。</p><p><code>![可以写关于图片的描述](/images/image.jpg)</code></p><p>图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p><ol start="2"><li>本地引用–相对路径</li></ol><p>图片除了可以放在统一的 images 文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置 _config.yml 来生成。</p><p>打开项目根目录中的 _config.yml 文件，将 _config.yml文件中的配置项 post_asset_folder 设为 true 后，执行命令 hexo new “post_name”，在 source&#x2F;posts 中会生成文章 post_name.md 和同名文件夹 post_name。</p><img src="/images/initHexo/post_name.png" /><p>将图片资源放在 post_name 文件夹中，文章就可以使用相对路径引用图片资源了。</p><p><code>![](image.jpg)</code></p><p>但是使用这种引用方式，图片只能在文章中显示，但无法在首页中正常显示。</p><p>如果希望图片在文章和首页中同时显示，可以使用标签插件语法(推荐使用这种引用方法)。</p><p><code>&#123;% asset_img image.jpg This is an image %&#125;</code></p><ol start="3"><li>CDN 引用(不推荐)</li></ol><p>除了在本地存储图片，还可以将图片上传到一些免费的 CDN 服务中。</p><p>比如Cloudinary （梯子访问）提供的图片CDN服务，在 Cloudinary 中上传图片后，会生成对应的 url 地址，将地址直接拿来引用即可。或者上传到路过图床（不用梯子）。</p><h3 id="第七章-总结"><a href="#第七章-总结" class="headerlink" title="第七章 总结"></a>第七章 总结</h3><p>以上就是本人搭建博客的过程以及遇到的一些问题和解决办法，按照本人搭建博客的步骤就可以搭建一个相当不错的静态博客网站了。</p><p>如果想要让 baidu 和 google 搜索引擎收录自己的网站地址，可自行必应搜索。</p><p>谢谢大家!</p><p>参考教程: <a href="https://www.bilibili.com/video/BV1Yb411a7ty/?share_source=copy_web&vd_source=d698f3adeb829e7ec38eaffd67915950">www.bilibili.com/video</a></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
