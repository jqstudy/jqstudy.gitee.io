<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript总结</title>
    <link href="/2024/05/09/JavaScript%E6%80%BB%E7%BB%93/"/>
    <url>/2024/05/09/JavaScript%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4 id="1-介绍-js-的基本数据类型。"><a href="#1-介绍-js-的基本数据类型。" class="headerlink" title="1. 介绍 js 的基本数据类型。"></a>1. 介绍 js 的基本数据类型。</h4><p>&nbsp;&nbsp;<code>js</code>一共有七种基本数据类型，分别是<code>Undefined、Null、Boolean、Number、String</code>，还有在 <code>ES6</code> 中新增的 <code>Symbol</code> 和 <code>ES10</code> 中新增的 <code>BigInt</code> 类型。<br>&nbsp;&nbsp;<code>Symbol</code> 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。<br>&nbsp;&nbsp;<code>BigInt</code> 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 <code>BigInt</code> 可以安全地存储和操作大整数，即使这个数已经超出了 <code>Number</code> 能够表示的安全整数范围。</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS总结</title>
    <link href="/2023/12/18/CSS%E6%80%BB%E7%BB%93/"/>
    <url>/2023/12/18/CSS%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4 id="1-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？"><a href="#1-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？" class="headerlink" title="1. 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？"></a>1. 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</h4><ol><li>有两种盒子模型：IE盒模型（border-box）、W3C标准盒模型（content-box）</li><li>盒模型：分为内容（content）、填充（padding）、边界（margin）、边框（border）四个部分</li></ol><p>IE盒模型和W3C标准盒模型的区别：</p><ol><li>W3C标准盒模型：属性width，height只包含内容content，不包含border和padding</li><li>IE盒模型：属性width，height包含content、border和padding，指的是content<br>+padding+border。</li></ol><p>&nbsp;&nbsp;在ie8+浏览器中使用哪个盒模型可以由box-sizing（CSS新增的属性）控制，默认值为content-box，即标准盒模型；如果将box-sizing设为border-box则用的是IE盒模型。如果在ie6，7，8中DOCTYPE缺失会将盒子模型解释为IE盒子模型。若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。</p><p>回答：</p><p>&nbsp;&nbsp;盒模型都是由四个部分组成的，分别是margin、border、padding和content。<br>&nbsp;&nbsp;标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content。<br>&nbsp;&nbsp;一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。</p><h4 id="2-CSS-选择器有哪些？"><a href="#2-CSS-选择器有哪些？" class="headerlink" title="2. CSS 选择器有哪些？"></a>2. CSS 选择器有哪些？</h4><ol><li>id选择器(#myid)</li><li>类选择器(.myclassname)</li><li>标签选择器(div,h1,p)</li><li>后代选择器(h1,p)</li><li>子选择器(ul&gt;li)</li><li>兄弟选择器(所有)(li~a)</li><li>相邻兄弟选择器(li+a)</li><li>属性选择器(a[rel&#x3D;”external”])</li><li>伪类选择器(a:hover,li:nth-child)</li><li>伪元素选择器(::before、::after)</li><li>通配符选择器(*)</li></ol><h4 id="3-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用"><a href="#3-before-和-after-中双冒号和单冒号有什么区别？解释一下这-2-个伪元素的作用" class="headerlink" title="3. ::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用"></a>3. ::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用</h4><p>相关知识点：</p><ul><li>单冒号 (:) 用于CSS3伪类，双冒号 (::) 用于CSS3伪元素。(伪元素由双冒号和伪元素名称组成)</li><li>双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。</li><li>想让插入的内容出现在其它内容前，使用::before，否者，使用::after；</li><li>在代码顺序上，::after生成的内容也比::before生成的内容靠后。如果按堆栈视角，::after生成的内容会在::before生成的内容之上。</li></ul><p>回答：<br>&nbsp;&nbsp;在css3中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号来表示伪元素。<br>&nbsp;&nbsp;伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等。</p><h4 id="4-伪类与伪元素的区别"><a href="#4-伪类与伪元素的区别" class="headerlink" title="4. 伪类与伪元素的区别"></a>4. 伪类与伪元素的区别</h4><p>&nbsp;&nbsp;css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。</p><p>&nbsp;&nbsp;伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。</p><p>&nbsp;&nbsp;伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</p><p>&nbsp;&nbsp;有时你会发现伪元素使用了两个冒号（::）而不是一个冒号（:）。这是CSS3的一部分，并尝试区分伪类和伪元素。大多数浏览器都支持这两个值。按照规则应该使用（::）而不是（:），从而区分伪类和伪元素。但是，由于在旧版本的W3C规范并未对此进行特别区分，因此目前绝大多数的浏览器都支持使用这两种方式表示伪元素。</p><h4 id="5-CSS-中哪些属性可以继承？"><a href="#5-CSS-中哪些属性可以继承？" class="headerlink" title="5. CSS 中哪些属性可以继承？"></a>5. CSS 中哪些属性可以继承？</h4><p>相关资料：</p><ul><li>每个CSS属性定义的概述都指出了这个属性是默认继承的，还是默认不继承的。这决定了当你没有为元素的属性指定值时该如何计算值。</li><li>当元素的一个继承属性没有指定值时，则取父元素的同属性的计算值。只有文档根元素取该属性的概述中给定的初始值（这里的意思应该是在该属性本身的定义中的默认值）。</li><li>当元素的一个非继承属性（在Mozilla code里有时称之为reset property）没有指定值时，则取属性的初始值initial value（该值在该属性的概述里被指定）。</li></ul><p>有继承性的属性：</p><ul><li>字体系列属性font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust</li><li>文本系列属性text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、<br>text-transform、direction、color</li><li>表格布局属性caption-side border-collapse empty-cells</li><li>列表属性list-style-type、list-style-image、list-style-position、list-style</li><li>光标属性cursor</li><li>元素可见性visibility</li><li>还有一些不常用的；speak，page，设置嵌套引用的引号类型quotes等属性</li></ul><p>注意：当一个属性不是继承属性时，可以使用inherit关键字指定一个属性应从父元素继承它的值，inherit关键字用于显式地指定继承性，可用于任何继承性&#x2F;非继承性属性。</p><p>回答：<br>&nbsp;&nbsp;每一个属性在定义中都给出了这个属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，会使用父元素的同属性的值来作为自己的值。</p><p>&nbsp;&nbsp;一般具有继承性的属性有，字体相关的属性，font-size和font-weight等。文本相关的属性，color和text-align等。表格的一些布局属性、列表属性如list-style等。还有光标属性cursor、元素可见性visibility。</p><p>&nbsp;&nbsp;当一个属性不是继承属性的时候，我们也可以通过将它的值设置为inherit来使它从父元素那获取同名的属性值来继承。</p><h4 id="6-CSS-优先级算法如何计算？"><a href="#6-CSS-优先级算法如何计算？" class="headerlink" title="6. CSS 优先级算法如何计算？"></a>6. CSS 优先级算法如何计算？</h4><p>相关知识点：</p><p>CSS的优先级是根据样式声明的特殊性值来判断的。<br>选择器的特殊性值分为四个等级，如下：</p><ol><li>内联样式选择器x,0,0,0</li><li>ID选择器0,x,0,0</li><li>class选择器&#x2F;属性选择器&#x2F;伪类选择器0,0,x,0</li><li>元素和伪元素选择器0,0,0,x</li></ol><p>计算方法：</p><ol><li>每个等级的初始值为0</li><li>每个等级的叠加为选择器出现的次数相加</li><li>不可进位，比如0,99,99,99</li><li>依次表示为：0,0,0,0</li><li>每个等级计数之间没关联</li><li>等级判断从左向右，如果某一位数值相同，则判断下一位数值</li><li>如果两个优先级相同，则最后出现的优先级高，!important也适用</li><li>通配符选择器的特殊性值为：0,0,0,0</li><li>继承样式优先级最低，通配符样式优先级高于继承样式</li><li>!important（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0。</li></ol><p>计算实例：</p><ol><li>#demo a{color: orange;}&#x2F;<em>特殊性值：0,1,0,1</em>&#x2F;</li><li>div#demo a{color: red;}&#x2F;<em>特殊性值：0,1,0,2</em>&#x2F;</li></ol><p>注意：</p><ol><li>样式应用时，css会先查看规则的权重（!important），加了权重的优先级最高，当权重相同的时候，会比较规则的特殊性。</li><li>特殊性值越大的声明优先级越高。</li><li>相同特殊性值的声明，根据样式引入的顺序，后声明的规则优先级高（距离元素出现最近的）</li><li>部分浏览器由于字节溢出问题出现的进位表现不做考虑</li></ol><p>回答：<br>&nbsp;&nbsp;判断优先级时，首先我们会判断一条属性声明是否有权重，也就是是否在声明后面加上了!important。一条声明如果加上了权重，那么它的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的特殊性。</p><p>&nbsp;&nbsp;一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。选择器的特殊性可以分为四个等级，第一个等级是行内样式，为1000，第二个等级是id选择器，为0100，第三个等级是类选择器、伪类选择器和属性选择器，为0010，第四个等级是元素选择器和伪元素选择器，为0001。规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以1开头的特殊性值比所有以0开头的特殊性值要大。比如说特殊性值为1000的的规则优先级就要比特殊性值为0999的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引入的顺序，后出现的规则的优先级最高。</p><h4 id="7-关于伪类-LVHA-的解释"><a href="#7-关于伪类-LVHA-的解释" class="headerlink" title="7. 关于伪类 LVHA 的解释?"></a>7. 关于伪类 LVHA 的解释?</h4><p>&nbsp;&nbsp;a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active；</p><p>当链接未访问过时：</p><ol><li>当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪类后面声明；</li><li>当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），必须将:active声明放到:link和:hover之后。因此得出LVHA这个顺序。<br>&nbsp;&nbsp;当链接访问过时，情况基本同上，只不过需要将:link换成:visited。<br>&nbsp;&nbsp;这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖的问题。</li></ol><h4 id="8-CSS3-新增伪类有那些？"><a href="#8-CSS3-新增伪类有那些？" class="headerlink" title="8. CSS3 新增伪类有那些？"></a>8. CSS3 新增伪类有那些？</h4><ol><li>elem:nth-child(n)选中父元素下的第n个子元素，并且这个子元素的标签名为elem，n可以接受具体的数值，也可以接受函数。</li><li>elem:nth-last-child(n)作用同上，不过是从后开始查找。</li><li>elem:last-child选中最后一个子元素。</li><li>elem:only-child如果elem是父元素下唯一的子元素，则选中之。</li><li>elem:nth-of-type(n)选中父元素下第n个elem类型元素，n可以接受具体的数值，也可以接受函数。</li><li>elem:first-of-type选中父元素下第一个elem类型元素。\</li><li>elem:last-of-type选中父元素下最后一个elem类型元素。</li><li>elem:only-of-type如果父元素下的子元素只有一个elem类型元素，则选中该元素。</li><li>elem:empty选中不包含子元素和内容的elem类型元素。</li><li>elem:target选择当前活动的elem元素。</li><li>:not(elem)选择非elem元素的每个元素。</li><li>:enabled 控制表单控件的禁用状态。</li><li>:disabled控制表单控件的禁用状态。</li><li>:checked单选框或复选框被选中。</li></ol><h4 id="9-如何居中-div？"><a href="#9-如何居中-div？" class="headerlink" title="9. 如何居中 div？"></a>9. 如何居中 div？</h4><ul><li>水平居中：给 div 设置一个宽度，然后添加 margin:0 auto 属性<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>水平居中，利用 text-align:center 实现<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>让绝对定位的 div 居中<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">margin</span>: auto;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>水平垂直居中一<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*确定容器的宽高宽500高300的层设置层的外边距div&#123;*/</span><br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<span class="hljs-comment">/*绝对定位*/</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">margin</span>: -<span class="hljs-number">150px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> -<span class="hljs-number">250px</span>;<span class="hljs-comment">/*外边距为自身宽高的一半*/</span><br>  <span class="hljs-attribute">background-color</span>: pink;<span class="hljs-comment">/*方便看效果*/</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>水平垂直居中二<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*未知容器的宽高，利用`transform`属性*/</span><br><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute; <span class="hljs-comment">/*相对定位或绝对定位均可*/</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>  <span class="hljs-attribute">background-color</span>: pink; <span class="hljs-comment">/*方便看效果*/</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>水平垂直居中三<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*利用flex布局实际使用时应考虑兼容性*/</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: center; <span class="hljs-comment">/*垂直居中*/</span><br>  <span class="hljs-attribute">justify-content</span>: center; <span class="hljs-comment">/*水平居中*/</span><br>&#125;<br><span class="hljs-selector-class">.containerdiv</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink; <span class="hljs-comment">/*方便看效果*/</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>水平垂直居中四<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*利用text-align:center和vertical-align:middle属性*/</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">position</span>: fixed;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>);<br>  <span class="hljs-attribute">text-align</span>: center;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>  <span class="hljs-attribute">overflow</span>: auto;<br>&#125;<br><br><span class="hljs-selector-class">.container</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">vertical-align</span>: middle;<br>&#125;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">white-space</span>: normal;<br>  <span class="hljs-attribute">vertical-align</span>: middle;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>回答：</p><ul><li>对于宽高固定的元素<ol><li>我们可以利用margin:0 auto来实现元素的水平居中。</li><li>利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。</li><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素<br>的中心点到页面的中心。</li><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素<br>的中心点到页面的中心。</li><li>使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对<br>齐，然后它的子元素也可以实现垂直和水平的居中。<br>&nbsp;&nbsp;对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。</li></ol></li></ul><h4 id="10-display-有哪些值？说明他们的作用。"><a href="#10-display-有哪些值？说明他们的作用。" class="headerlink" title="10. display 有哪些值？说明他们的作用。"></a>10. display 有哪些值？说明他们的作用。</h4><ul><li>block块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</li><li>none元素不显示，并从文档流中移除。</li><li>inline行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</li><li>inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。</li><li>list-item像块类型元素一样显示，并添加样式列表标记。</li><li>table此元素会作为块级表格来显示。</li><li>inherit规定应该从父元素继承display属性的值。</li></ul><h4 id="11-position-的值-relative-和-absolute-定位原点是？"><a href="#11-position-的值-relative-和-absolute-定位原点是？" class="headerlink" title="11. position 的值 relative 和 absolute 定位原点是？"></a>11. position 的值 relative 和 absolute 定位原点是？</h4><p>相关知识点：</p><ul><li>absolute 生成绝对定位的元素，相对于值不为static的第一个父元素的padding box进行定位，也可以理解为离自己这一级元素最近的一级position设置为absolute或者relative的父元素的padding box的左上角为原点的。</li><li>fixed（老IE不支持）生成固定定位的元素，相对于浏览器窗口进行定位。</li><li>relative 生成相对定位的元素，相对于其元素本身所在文档流中的位置进行定位。</li><li>static 默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right,z-index声明）。</li><li>inherit 规定从父元素继承position属性的值。</li></ul><p>回答：</p><p>&nbsp;&nbsp;relative 定位的元素，是相对于元素本身所在文档流中的位置进行定位的。<br>&nbsp;&nbsp;absolute 定位的元素，是相对于它的第一个position值不为static的祖先元素的padding box来进行定位的。这句话我们可以这样来理解，我们首先需要找到绝对定位元素的一个position的值不为static的祖先元素，然后相对于这个祖先元素的padding box来定位，也就是说在计算定位距离的时候，padding的值也要算进去。</p><h4 id="12-CSS3-有哪些新特性？（根据项目回答）"><a href="#12-CSS3-有哪些新特性？（根据项目回答）" class="headerlink" title="12. CSS3 有哪些新特性？（根据项目回答）"></a>12. CSS3 有哪些新特性？（根据项目回答）</h4><ul><li>新增各种CSS选择器(:not(.input)：所有class不是“input”的节点)</li><li>圆角 (border-radius:8px)</li><li>多列布局 (multi-column layout)</li><li>阴影和反射 (Shadow\Reflect)</li><li>文字特效 (text-shadow)</li><li>文本修饰 (Text-decoration)</li><li>线性渐变   (linear-gradient)</li><li>旋转 (transform：rotate) 缩放，平移，倾斜，动画，多背景<br>例如：transform:\scale(0.85,0.90)\translate(0px,-30px)\skew(-9deg,0deg)\Animation:</li></ul><h4 id="13-请解释一下-CSS3-的-Flex-box（弹性盒布局模型），以及适用场景？"><a href="#13-请解释一下-CSS3-的-Flex-box（弹性盒布局模型），以及适用场景？" class="headerlink" title="13. 请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？"></a>13. 请解释一下 CSS3 的 Flex box（弹性盒布局模型），以及适用场景？</h4><p>相关知识点：<br>&nbsp;&nbsp;Flex是FlexibleBox的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>&nbsp;&nbsp;任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。<br>&nbsp;&nbsp;采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex元素（flex item），简称”元素”。<br>&nbsp;&nbsp;容器默认存在两根轴：水平的主轴（main axis）和垂直的辅轴（cross axis），元素默认沿主轴排列。</p><p>以下6个属性设置在容器上:</p><ol><li>flex-direction属性决定主轴的方向（即元素的排列方向）。</li><li>flex-wrap属性定义，如果一条轴线排不下，如何换行。</li><li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</li><li>justify-content属性定义了元素在主轴上的对齐方式。 可选值：flex-start, flex-end, center, space-around,space-between, stretch</li><li>align-items属性定义元素在辅轴上如何对齐。 可选值：flex-start, flex-end, center， stretch</li><li>align-content属性定义了多根轴线的对齐方式。如果元素只有一根轴线，该属性不起作用。</li></ol><p>以下6个属性设置在元素上:</p><ol><li>order属性定义元素的排列顺序。数值越小，排列越靠前，默认为0</li><li>flex-grow属性定义元素的增长系数，默认为0，即如果存在剩余空间，也不放大。</li><li>flex-shrink属性定义了项目的缩减系数，默认为1，即如果空间不足，该项目将缩小。</li><li>flex-basis属性定义了在分配多余空间之前，元素占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li><li>flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li><li>align-self属性允许单个元素有与其他元素不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父<br>元素的align-items属性，如果没有父元素，则等同于stretch。</li></ol><p>回答：</p><p>&nbsp;&nbsp;flex布局是CSS3新增的一种布局方式，我们可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的弹性元素。</p><p>&nbsp;&nbsp;一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的辅轴。我们可以使用flex-direction来指定主轴的方向。我们可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在辅轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。</p><p>&nbsp;&nbsp;对于容器中的弹性元素，我们可以使用order属性来指定元素的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，元素的增长系数。还可以使用flex-shrink来指定当排列空间不足时，元素的缩减系数。</p><h4 id="14-用纯-CSS-创建一个三角形的原理是什么？"><a href="#14-用纯-CSS-创建一个三角形的原理是什么？" class="headerlink" title="14. 用纯 CSS 创建一个三角形的原理是什么？"></a>14. 用纯 CSS 创建一个三角形的原理是什么？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  采用的是相邻边框连接处的均分原理。</span><br><span class="hljs-comment">  将元素的宽高设为0，只设置border，把任意三条边隐藏掉（颜色设为transparent），剩下的就是一个三角形。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-selector-id">#demo</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">border-width</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">border-style</span>: solid;<br>  <span class="hljs-attribute">border-color</span>: transparent transparent red transparent;<br>  <span class="hljs-attribute">border-top</span>: none;   <span class="hljs-comment">/*加上这一行可以让三角形顶格， 不加三角形会下移20px*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="15-一个满屏品字布局如何设计"><a href="#15-一个满屏品字布局如何设计" class="headerlink" title="15.一个满屏品字布局如何设计?"></a>15.一个满屏品字布局如何设计?</h4><p>简单的方式:<br>  上面div宽度为100%<br>  下面两个div宽度为50%<br>  然后用float或者inline使其不换行即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  *&#123;    <span class="hljs-comment">/* 去除所有元素默认的内外边距的值 */</span></span><br><span class="language-css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span>&#123;   <span class="hljs-comment">/* 默认HTML，body的高度为0，为其设置高度以使后面的div可以用百分比设置高度 */</span></span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  </span><br><span class="language-css">  <span class="hljs-selector-class">.header</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: orange;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.main</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.main</span> <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.main</span> <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">    <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="16-CSS-多列等高如何实现？"><a href="#16-CSS-多列等高如何实现？" class="headerlink" title="16.CSS 多列等高如何实现？"></a>16.CSS 多列等高如何实现？</h4><ol><li><p>利用padding-bottom|margin-bottom正负值相抵，不会影响页面布局的特点。设置父容器超出隐藏（overflow:hidden），这样父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。</p></li><li><p>利用table-cell所有单元格高度都相等的特性，来实现多列等高。</p></li><li><p>利用flex布局中弹性元素align-items属性默认为stretch，如果弹性元素未设置高度或设为auto，将占满整个容器的高度<br>的特性，来实现多列等高。</p></li></ol><p>详细资料可以参考：<br><a href="https://juejin.im/post/5b0fb34151882515662238fd">《前端应该掌握的 CSS 实现多列等高布局》</a><br><a href="https://codepen.io/yangbo5207/post/equh">《CSS：多列等高布局》</a></p><h4 id="17-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用-hack-的技巧？"><a href="#17-经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用-hack-的技巧？" class="headerlink" title="17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？"></a>17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？</h4><ol><li><p>png24位的图片在iE6浏览器上出现背景<br>解决方案：做成PNG8，也可以引用一段脚本处理。</p></li><li><p>浏览器默认的margin和padding不同<br>解决方案：加一个全局的*{margin:0;padding:0;}来统一。</p></li><li><p>IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。<br>#box{float:left;width:10px;margin:0 0 0 10px;} 这种情况之下IE会产生20px的距离<br>解决方案：在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</p></li><li><p>渐进识别的方式，从总体中逐渐排除局部。<br>解决方案: 首先，巧妙的使用”\9”这一标记，将IE浏览器从所有情况中分离出来。<br>     接着，再次使用”+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。<br>     .bb{<br>       background-color:#f1ee18;&#x2F;<em>所有识别</em>&#x2F;<br>       background-color:#00deff\9;&#x2F;<em>IE6、7、8识别</em>&#x2F;<br>       +background-color:#a200ff;&#x2F;<em>IE6、7识别</em>&#x2F;<br>       _background-color:#1e0bd1;&#x2F;<em>IE6识别</em>&#x2F;<br>     }</p></li><li><p>IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性<br>解决方法：统一通过getAttribute()获取自定义属性。</p></li><li><p>IE下，event对象有x、y属性，但是没有pageX、pageY属性;Firefox下，event对象有pageX、pageY属性，但是没有x、y属性。<br>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p></li><li><p>Chrome中文界面下默认会将小于12px的文本强制按照12px显示</p><ul><li>可通过加入CSS属性-webkit-text-size-adjust:none;解决。但是，在chrome更新到27版本之后就不可以用了。</li><li>还可以使用-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);收缩的是整个span的大小，这时候，必须要将span转换成块元素，可以使用display：block&#x2F;inline-block&#x2F;…；</li></ul></li><li><p>超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了<br>解决方法：改变CSS属性的排列顺序L-V-H-A</p></li><li><p>怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好 养成书写DTD声明的好习惯。</p></li></ol><h4 id="18-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#18-li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="18.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>18.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h4><p>  浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个<code>&lt;li&gt;</code>放在一行，这导致<code>&lt;li&gt;</code>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。<br>  解决办法：</p><ol><li>为<code>&lt;li&gt;</code>设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</li><li>将所有<code>&lt;li&gt;</code>写在同一行。不足：代码不美观。</li><li>将<code>&lt;ul&gt;</code>内的字符尺寸直接设为0，即font-size:0。不足：<code>&lt;ul&gt;</code>中的其他字符尺寸也被设为0，需要额外重新设定其他<br>字符尺寸，且在Safari浏览器依然会出现空白间隔。</li><li>消除<code>&lt;ul&gt;</code>的字符间隔letter-spacing:-8px，不足：这也设置了<code>&lt;li&gt;</code>内的字符间隔，因此需要将<code>&lt;li&gt;</code>内的字符<br>间隔设为默认letter-spacing:normal。</li></ol><h4 id="19-为什么要初始化-CSS-样式？"><a href="#19-为什么要初始化-CSS-样式？" class="headerlink" title="19.为什么要初始化 CSS 样式？"></a>19.为什么要初始化 CSS 样式？</h4><ol><li>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</li><li>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。<br>最简单的初始化方法：*{padding:0;margin:0;}（强烈不建议）</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*淘宝初始化样式*/</span><br><span class="hljs-selector-tag">body</span>,<span class="hljs-selector-tag">h1</span>,<span class="hljs-selector-tag">h2</span>,<span class="hljs-selector-tag">h3</span>,<span class="hljs-selector-tag">h4</span>,<span class="hljs-selector-tag">h5</span>,<span class="hljs-selector-tag">h6</span>,hr,<span class="hljs-selector-tag">p</span>,<span class="hljs-selector-tag">blockquote</span>,<span class="hljs-selector-tag">dl</span>,<span class="hljs-selector-tag">dt</span>,<span class="hljs-selector-tag">dd</span>,<span class="hljs-selector-tag">ul</span>,<span class="hljs-selector-tag">ol</span>,<span class="hljs-selector-tag">li</span>,pre,<span class="hljs-selector-tag">form</span>,<span class="hljs-selector-tag">fieldset</span>,<span class="hljs-selector-tag">legend</span><br>,<span class="hljs-selector-tag">button</span>,<span class="hljs-selector-tag">input</span>,<span class="hljs-selector-tag">textarea</span>,<span class="hljs-selector-tag">th</span>,<span class="hljs-selector-tag">td</span>&#123;<span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;<span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;&#125;<br><span class="hljs-selector-tag">body</span>,<span class="hljs-selector-tag">button</span>,<span class="hljs-selector-tag">input</span>,select,<span class="hljs-selector-tag">textarea</span>&#123;<span class="hljs-attribute">font</span>:<span class="hljs-number">12px</span>/<span class="hljs-number">1.5</span>tahoma,arial,\<span class="hljs-number">5</span>b8b\<span class="hljs-number">4</span>f53;&#125;<br><span class="hljs-selector-tag">h1</span>,<span class="hljs-selector-tag">h2</span>,<span class="hljs-selector-tag">h3</span>,<span class="hljs-selector-tag">h4</span>,<span class="hljs-selector-tag">h5</span>,<span class="hljs-selector-tag">h6</span>&#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">100%</span>;&#125;<br><span class="hljs-selector-tag">address</span>,<span class="hljs-selector-tag">cite</span>,<span class="hljs-selector-tag">dfn</span>,<span class="hljs-selector-tag">em</span>,<span class="hljs-selector-tag">var</span>&#123;<span class="hljs-attribute">font-style</span>:normal;&#125;<br><span class="hljs-selector-tag">code</span>,<span class="hljs-selector-tag">kbd</span>,pre,<span class="hljs-selector-tag">samp</span>&#123;<span class="hljs-attribute">font-family</span>:couriernew,courier,monospace;&#125;<br>small&#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">12px</span>;&#125;<br><span class="hljs-selector-tag">ul</span>,<span class="hljs-selector-tag">ol</span>&#123;<span class="hljs-attribute">list-style</span>:none;&#125;<br><span class="hljs-selector-tag">a</span>&#123;<span class="hljs-attribute">text-decoration</span>:none;&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span>&#123;<span class="hljs-attribute">text-decoration</span>:underline;&#125;<br><span class="hljs-selector-tag">sup</span>&#123;<span class="hljs-attribute">vertical-align</span>:text-top;&#125;<br>sub&#123;<span class="hljs-attribute">vertical-align</span>:text-bottom;&#125;<br><span class="hljs-selector-tag">legend</span>&#123;<span class="hljs-attribute">color</span>:<span class="hljs-number">#000</span>;&#125;<br><span class="hljs-selector-tag">fieldset</span>,<span class="hljs-selector-tag">img</span>&#123;<span class="hljs-attribute">border</span>:<span class="hljs-number">0</span>;&#125;<br><span class="hljs-selector-tag">button</span>,<span class="hljs-selector-tag">input</span>,select,<span class="hljs-selector-tag">textarea</span>&#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">100%</span>;&#125;<br><span class="hljs-selector-tag">table</span>&#123;<span class="hljs-attribute">border-collapse</span>:collapse;<span class="hljs-attribute">border-spacing</span>:<span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><h4 id="20-什么是包含块，对于包含块的理解"><a href="#20-什么是包含块，对于包含块的理解" class="headerlink" title="20.什么是包含块，对于包含块的理解?"></a>20.什么是包含块，对于包含块的理解?</h4><p> 包含块（containing block）就是元素用来计算和定位的一个框。</p><ol><li>根元素（很多场景下可以看成是<html>）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。</li><li>对于其他元素，如果该元素的position是relative或者static，则“包含块”由其最近的块级祖先元素的content box边界形成。</li><li>如果元素position:fixed，则“包含块”是“初始包含块”。</li><li>如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素建立，具体方式如下：<br>如果该祖先元素是纯inline元素，则规则略复杂：<ul><li>假设给内联元素的前后各生成一个宽度为0的内联盒子（inline box），则这两个内联盒子的padding box外面的包围盒就是内联元素的“包含块”；</li><li>如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范并没有明确定义，浏览器自行发挥否则，“包含块”由该祖先的padding box边界形成。<br>如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">简单描述：默认情况下包含块就是离当前元素最近的块级祖先元素；<br>对于开启了绝对定位的元素来说，包含块是离它最近的开启了定位（且position不为static）的祖先元素，<br>如果所有的祖先元素都没有开启定位，则其包含块就是初始包含块。<br></code></pre></td></tr></table></figure></li></ul></li></ol><h4 id="21-CSS-里的-visibility-属性有个-collapse-属性值是干嘛用的？在不同浏览器下以后什么区别？"><a href="#21-CSS-里的-visibility-属性有个-collapse-属性值是干嘛用的？在不同浏览器下以后什么区别？" class="headerlink" title="21.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？"></a>21.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？</h4><ul><li>对于一般的元素，它的表现跟visibility：hidden;是一样的。元素是不可见的，但此时仍占用页面空间。</li><li>但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟display:none一样，也就是说，它们占用的空间也会释放。<br>在不同浏览器下的区别：<br>  在谷歌浏览器里，使用collapse值和使用hidden值没有什么区别。<br>  在火狐浏览器、Opera和IE11里，使用collapse值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。</li></ul><h4 id="22-width-auto-和-width-100-的区别"><a href="#22-width-auto-和-width-100-的区别" class="headerlink" title="22.width:auto 和 width:100%的区别"></a>22.width:auto 和 width:100%的区别</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">一般而言<br>  width:100%会使元素box的宽度等于父元素的content box的宽度。<br>  width:auto会使元素撑满整个父元素，margin、border、padding、content区域会自动分配水平空间。<br></code></pre></td></tr></table></figure><h4 id="23-绝对定位元素与非绝对定位元素的百分比计算的区别"><a href="#23-绝对定位元素与非绝对定位元素的百分比计算的区别" class="headerlink" title="23.绝对定位元素与非绝对定位元素的百分比计算的区别"></a>23.绝对定位元素与非绝对定位元素的百分比计算的区别</h4><p>绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的padding box来计算的。<br>非绝对定位元素的宽高百分比则是相对于父元素的content box来计算的。</p><h4 id="24-简单介绍使用图片-base64-编码的优点和缺点。"><a href="#24-简单介绍使用图片-base64-编码的优点和缺点。" class="headerlink" title="24.简单介绍使用图片 base64 编码的优点和缺点。"></a>24.简单介绍使用图片 base64 编码的优点和缺点。</h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的<br>url属性。<br><br>使用base64的优点是：<br><br> 1. 减少一个图片的HTTP请求<br><br>使用base64的缺点是：<br><br>  1. 根据base64的编码原理，编码后的大小会比原文件大小大1/3，如果把大图片编码到html/css中，不仅会造成文件体<br>  积的增加，影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。<br><br>  2. 使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如HTML或者CSS，这相比于直接缓存图片的效果要<br>  差很多。<br><br>  3. 兼容性的问题，ie8以前的浏览器不支持。<br><br> 一般一些网站的小图标可以使用base64图片来引入。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/coco1s/p/4375774.html">《玩转图片 base64 编码》</a><br><a href="https://www.zhihu.com/question/31155574">《前端开发中，使用 base64 图片的弊端是什么？》</a><br><a href="https://www.zhangxinxu.com/wordpress/2012/04/base64-url-image-%E5%9B%BE%E7%89%87-%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">《小 tip:base64:URL 背景图片与 web 页面性能优化》</a></p><h4 id="25-’display’、’position’和’float’的相互关系？"><a href="#25-’display’、’position’和’float’的相互关系？" class="headerlink" title="25.’display’、’position’和’float’的相互关系？"></a>25.’display’、’position’和’float’的相互关系？</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs maxima">（<span class="hljs-number">1</span>）首先我们判断<span class="hljs-built_in">display</span>属性是否为none，如果为none，则<span class="hljs-built_in">position</span>和<span class="hljs-built_in">float</span>属性的值不影响元素最后的表现。<br><br>（<span class="hljs-number">2</span>）然后判断<span class="hljs-built_in">position</span>的值是否为absolute或者fixed，如果是，则<span class="hljs-built_in">float</span>属性失效，并且<span class="hljs-built_in">display</span>的值应该被<br>设置为table或者<span class="hljs-built_in">block</span>，具体转换需要看初始转换值。<br><br>（<span class="hljs-number">3</span>）如果<span class="hljs-built_in">position</span>的值不为absolute或者fixed，则判断<span class="hljs-built_in">float</span>属性的值是否为none，如果不是，则<span class="hljs-built_in">display</span><br>的值则按上面的规则转换。注意，如果<span class="hljs-built_in">position</span>的值为relative并且<span class="hljs-built_in">float</span>属性的值存在，则relative相对<br>于浮动后的最终位置定位。<br><br>（<span class="hljs-number">4</span>）如果<span class="hljs-built_in">float</span>的值为none，则判断元素是否为根元素，如果是根元素则<span class="hljs-built_in">display</span>属性按照上面的规则转换，如果不是，<br>则保持指定的<span class="hljs-built_in">display</span>属性值不变。<br><br>总的来说，可以把它看作是一个类似优先级的机制，<span class="hljs-string">&quot;position:absolute&quot;</span>和<span class="hljs-string">&quot;position:fixed&quot;</span>优先级最高，有它存在<br>的时候，浮动不起作用，&#x27;<span class="hljs-built_in">display</span>&#x27;的值也需要调整；其次，元素的&#x27;<span class="hljs-built_in">float</span>&#x27;特性的值不是<span class="hljs-string">&quot;none&quot;</span>的时候或者它是根元素<br>的时候，调整&#x27;<span class="hljs-built_in">display</span>&#x27;的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，&#x27;<span class="hljs-built_in">display</span>&#x27;特性值同设置值。<br><br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://www.cnblogs.com/jackyWHJ/p/3756087.html">《position 跟 display、margincollapse、overflow、float 这些特性相互叠加后会怎么样？》</a></p><h4 id="26-margin-重叠问题的理解。"><a href="#26-margin-重叠问题的理解。" class="headerlink" title="26.margin 重叠问题的理解。"></a>26.margin 重叠问题的理解。</h4><p>相关知识点：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs css">块级元素的上外边距（<span class="hljs-attribute">margin-top</span>）与下外边距（<span class="hljs-attribute">margin-bottom</span>）有时会合并为单个外边距，这样的现象称为“<span class="hljs-attribute">margin</span>合<br>并”。<br><br>产生折叠的必备条件：<span class="hljs-attribute">margin</span>必须是邻接的!<br><br>而根据w3c规范，两个<span class="hljs-attribute">margin</span>是邻接的必须满足以下条件：<br><br>•必须是处于常规文档流（非<span class="hljs-attribute">float</span>和绝对定位）的块级盒子，并且处于同一个BFC当中。<br>•没有线盒，没有空隙，没有<span class="hljs-attribute">padding</span>和<span class="hljs-attribute">border</span>将他们分隔开<br>•都属于垂直方向上相邻的外边距，可以是下面任意一种情况<br>•元素的<span class="hljs-attribute">margin-top</span>与其第一个常规文档流的子元素的<span class="hljs-attribute">margin-top</span><br>•元素的<span class="hljs-attribute">margin-bottom</span>与其下一个常规文档流的兄弟元素的<span class="hljs-attribute">margin-top</span><br>•<span class="hljs-attribute">height</span>为auto的元素的<span class="hljs-attribute">margin-bottom</span>与其最后一个常规文档流的子元素的<span class="hljs-attribute">margin-bottom</span><br>•高度为<span class="hljs-number">0</span>并且最小高度也为<span class="hljs-number">0</span>，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的<span class="hljs-attribute">margin-top</span>和<span class="hljs-attribute">margin-bottom</span><br><br><span class="hljs-attribute">margin</span>合并的<span class="hljs-number">3</span>种场景：<br><br>（<span class="hljs-number">1</span>）相邻兄弟元素<span class="hljs-attribute">margin</span>合并。<br><br>解决办法：<br>•设置块状格式化上下文元素（BFC），即开启BFC<br><br>（<span class="hljs-number">2</span>）父级和第一个/最后一个子元素的<span class="hljs-attribute">margin</span>合并。<br><br>解决办法：<br><br>对于<span class="hljs-attribute">margin-top</span>合并，可以进行如下操作（满足一个条件即可）：<br>•父元素设置为块状格式化上下文元素；即开启BFC<br>•父元素设置<span class="hljs-attribute">border-top</span>值；<br>•父元素设置<span class="hljs-attribute">padding-top</span>值；<br>•父元素和第一个子元素之间添加内联元素进行分隔。<br><br>对于<span class="hljs-attribute">margin-bottom</span>合并，可以进行如下操作（满足一个条件即可）：<br>•父元素设置为块状格式化上下文元素；<br>•父元素设置<span class="hljs-attribute">border-bottom</span>值；<br>•父元素设置<span class="hljs-attribute">padding-bottom</span>值；<br>•父元素和最后一个子元素之间添加内联元素进行分隔；<br>•父元素设置<span class="hljs-attribute">height</span>、<span class="hljs-attribute">min-height</span>或<span class="hljs-attribute">max-height</span>。<br><br>（<span class="hljs-number">3</span>）空块级元素的<span class="hljs-attribute">margin</span>合并。<br><br>解决办法：<br>•设置垂直方向的<span class="hljs-attribute">border</span>；<br>•设置垂直方向的<span class="hljs-attribute">padding</span>；<br>•里面添加内联元素（直接Space键空格是没用的）；<br>•设置<span class="hljs-attribute">height</span>或者<span class="hljs-attribute">min-height</span>。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">margin</span>重叠指的是在垂直方向上，两个相邻元素的<span class="hljs-attribute">margin</span>发生重叠的情况。<br><br>一般来说可以分为四种情形：<br><br>第一种是相邻兄弟元素的marin-<span class="hljs-attribute">bottom</span>和<span class="hljs-attribute">margin-top</span>的值发生重叠。这种情况下我们可以通过设置其中一个元素为BFC<br>来解决。<br><br>第二种是父元素的<span class="hljs-attribute">margin-top</span>和子元素的<span class="hljs-attribute">margin-top</span>发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这<br>一点来解决这个问题。我们可以为父元素设置<span class="hljs-attribute">border-top</span>、<span class="hljs-attribute">padding-top</span>值来分隔它们，当然我们也可以将父元素设置为BFC<br>来解决。<br><br>第三种是高度为auto的父元素的<span class="hljs-attribute">margin-bottom</span>和子元素的<span class="hljs-attribute">margin-bottom</span>发生重叠。它们发生重叠一个是因为它们相<br>邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置<span class="hljs-attribute">border-bottom</span>、<span class="hljs-attribute">padding-bottom</span>来分隔它们，也可以为<br>父元素设置一个高度，<span class="hljs-attribute">max-height</span>和<span class="hljs-attribute">min-height</span>也能解决这个问题。当然将父元素设置为BFC是最简单的方法。<br><br>第四种情况，是没有内容的元素，自身的<span class="hljs-attribute">margin-top</span>和<span class="hljs-attribute">margin-bottom</span>发生的重叠。我们可以通过为其设置<span class="hljs-attribute">border</span>、pa<br>dding或者高度来解决这个问题。<br></code></pre></td></tr></table></figure><h4 id="27-对-BFC-规范（块级格式化上下文：block-formatting-context）的理解？"><a href="#27-对-BFC-规范（块级格式化上下文：block-formatting-context）的理解？" class="headerlink" title="27.对 BFC 规范（块级格式化上下文：block formatting context）的理解？"></a>27.对 BFC 规范（块级格式化上下文：block formatting context）的理解？</h4><p>相关知识点：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino">块级格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒<br>子的区域，也是浮动元素与其他元素的交互限定区域。<br><br>通俗来讲<br><br>•BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。<br>•如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。<br><br>创建BFC<br><br>（<span class="hljs-number">1</span>）根元素或包含根元素的元素<br>（<span class="hljs-number">2</span>）浮动元素<span class="hljs-type">float</span>＝left|right或inherit（≠none）<br>（<span class="hljs-number">3</span>）绝对定位元素position＝absolute或fixed<br>（<span class="hljs-number">4</span>）display＝<span class="hljs-keyword">inline</span>-block|flex|<span class="hljs-keyword">inline</span>-flex|table-cell或table-caption<br>（<span class="hljs-number">5</span>）overflow＝hidden|<span class="hljs-keyword">auto</span>或<span class="hljs-built_in">scroll</span>(≠visible)<br><br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">BFC指的是块级格式化上下文，一个元素开启了BFC之后，那么它内部元素产生的布局不会影响到外部元素，外部元素的布局也<br>不会影响到BFC中的内部元素。一个BFC就像是一个隔离区域，和其他区域互不影响。<br><br>一般来说根元素是一个BFC区域，浮动和绝对定位的元素也会形成BFC，<span class="hljs-attribute">display</span>属性的值为inline-block、<span class="hljs-attribute">flex</span>这些<br>属性时也会创建BFC。还有就是元素的<span class="hljs-attribute">overflow</span>的值不为visible时都会创建BFC。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html">《深入理解 BFC 和 MarginCollapse》</a><br><a href="https://segmentfault.com/a/1190000013647777">《前端面试题-BFC（块格式化上下文）》</a></p><h4 id="28-IFC-是什么？"><a href="#28-IFC-是什么？" class="headerlink" title="28.IFC 是什么？"></a>28.IFC 是什么？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">IFC指的是行级格式化上下文，它有这样的一些布局规则：<br><br>（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。<br>（2）当一行不够的时候会自动切换到下一行。<br>（3）行级上下文的高度由内部最高的内联盒子的高度决定。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000004466536#articleHeader5">《[译]:BFC 与 IFC》</a><br><a href="https://blog.csdn.net/paintandraw/article/details/80401741">《BFC 和 IFC 的理解（布局）》</a></p><h4 id="29-请解释一下为什么需要清除浮动？清除浮动的方式"><a href="#29-请解释一下为什么需要清除浮动？清除浮动的方式" class="headerlink" title="29.请解释一下为什么需要清除浮动？清除浮动的方式"></a>29.请解释一下为什么需要清除浮动？清除浮动的方式</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，<br>不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框<br>的高度小于浮动框的时候，此时就会出现“高度塌陷”。<br><br>清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。<br><br>清除浮动的方式<br><br>（<span class="hljs-number">1</span>）使用clear属性清除浮动。参考<span class="hljs-number">30</span>。<br><br>（<span class="hljs-number">2</span>）使用<span class="hljs-keyword">BFC块级格式化上下文来清除浮动。参考26。</span><br><span class="hljs-keyword"></span><br>因为<span class="hljs-keyword">BFC元素不会影响外部元素的特点，所以BFC元素也可以用来清除浮动的影响，因为如果不清除，子元素浮动则父元</span><br><span class="hljs-keyword"></span>素高度塌陷，必然会影响后面元素布局和定位，这显然有违<span class="hljs-keyword">BFC元素的子元素不会影响外部元素的设定。</span><br></code></pre></td></tr></table></figure><h4 id="30-使用-clear-属性清除浮动的原理？"><a href="#30-使用-clear-属性清除浮动的原理？" class="headerlink" title="30.使用 clear 属性清除浮动的原理？"></a>30.使用 clear 属性清除浮动的原理？</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs coq">使用<span class="hljs-built_in">clear</span>属性清除浮动，其语法如下：<span class="hljs-built_in">clear</span>:none|<span class="hljs-type">left</span>|<span class="hljs-type">right</span>|<span class="hljs-type">both</span><br><br>如果单看字面意思，<span class="hljs-built_in">clear</span>:<span class="hljs-built_in">left</span>应该是“清除左浮动”，<span class="hljs-built_in">clear</span>:<span class="hljs-built_in">right</span>应该是“清除右浮动”的意思，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。<br><br>官方对<span class="hljs-built_in">clear</span>属性的解释是：“元素盒子的边不能和前面的浮动元素相邻。”，我们对元素设置<span class="hljs-built_in">clear</span>属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。<br><br>还需要注意的一点是<span class="hljs-built_in">clear</span>属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”<span class="hljs-number">3</span>个字，也就是<span class="hljs-built_in">clear</span>属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是<span class="hljs-built_in">left</span>，要么是<span class="hljs-built_in">right</span>，不可能同时存在，同时由于<span class="hljs-built_in">clear</span>属性对“后面的”浮动元素不闻不问，因此，当<span class="hljs-built_in">clear</span>:<span class="hljs-built_in">left</span>有效的时候，<span class="hljs-built_in">clear</span>:<span class="hljs-built_in">right</span>必定无效，也就是此时<span class="hljs-built_in">clear</span>:<span class="hljs-built_in">left</span>等同于设置<span class="hljs-built_in">clear</span>:both；同样地，<span class="hljs-built_in">clear</span>:<span class="hljs-built_in">right</span>如果有效也是等同于设置<span class="hljs-built_in">clear</span>:both。由此可见，<span class="hljs-built_in">clear</span>:<span class="hljs-built_in">left</span>和<span class="hljs-built_in">clear</span>:<span class="hljs-built_in">right</span>这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用<span class="hljs-built_in">clear</span>:both吧。<br><br>一般使用伪元素的方式清除浮动<br>.<span class="hljs-built_in">clear</span>::<span class="hljs-built_in">before</span>,  // 解决外边距重叠的问题<br>.<span class="hljs-built_in">clear</span>::<span class="hljs-built_in">after</span>&#123;   // 解决高度塌陷的问题<br>  content:&#x27;&#x27;;<br>  display:table;//也可以是&#x27;block&#x27;，或者是&#x27;list-item&#x27;<br>  <span class="hljs-built_in">clear</span>:both;<br>&#125;<br><br><span class="hljs-built_in">clear</span>属性只有块级元素才有效的，而::<span class="hljs-built_in">after</span>等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。<br></code></pre></td></tr></table></figure><h4 id="31-zoom-1-的清除浮动原理"><a href="#31-zoom-1-的清除浮动原理" class="headerlink" title="31.zoom:1 的清除浮动原理?"></a>31.zoom:1 的清除浮动原理?</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gauss">清除浮动，触发hasLayout；<br>zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。譬如外边距（<span class="hljs-built_in">margin</span>）<br>的重叠，浮动清除，触发ie的haslayout属性等。<br><br>来龙去脉大概如下：<br>当设置了zoom的值之后，所设置的元素就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发<br>生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。<br><br>zoom属性是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标<br>准化，出现在CSS3<span class="hljs-number">.0</span>规范草案中。<br><br>目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？可以通过css3里面的动画属性<span class="hljs-built_in">scale</span>进行缩放。<br></code></pre></td></tr></table></figure><h4 id="32-移动端的布局用过媒体查询吗？"><a href="#32-移动端的布局用过媒体查询吗？" class="headerlink" title="32.移动端的布局用过媒体查询吗？"></a>32.移动端的布局用过媒体查询吗？</h4><p>&nbsp;&nbsp;假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法</p><p>&nbsp;&nbsp;当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规则被应用。当媒体查询返回假，标签上带有媒体查询的样式表仍将被下载（只不过不会被应用）。</p><p>&nbsp;&nbsp;包含了一个媒体类型和至少一个使用宽度、高度和颜色等媒体属性来限制样式表范围的表达式。CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。</p><p>详细资料可以参考：<br><a href="http://www.runoob.com/cssref/css3-pr-mediaquery.html">《CSS3@media 查询》</a><br><a href="http://caibaojian.com/356.html">《响应式布局和自适应布局详解》</a></p><h4 id="33-使用-CSS-预处理器吗？喜欢哪个？"><a href="#33-使用-CSS-预处理器吗？喜欢哪个？" class="headerlink" title="33.使用 CSS 预处理器吗？喜欢哪个？"></a>33.使用 CSS 预处理器吗？喜欢哪个？</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">SASS（SASS、<span class="hljs-keyword">LESS</span>没有本质区别，只因为团队前端都是用的SASS）<br></code></pre></td></tr></table></figure><h4 id="34-CSS-优化、提高性能的方法有哪些？"><a href="#34-CSS-优化、提高性能的方法有哪些？" class="headerlink" title="34.CSS 优化、提高性能的方法有哪些？"></a>34.CSS 优化、提高性能的方法有哪些？</h4><p><strong>加载性能：</strong></p><ol><li>css压缩：将写好的css进行打包压缩，可以减少很多的体积。</li><li>css单一样式：当需要下边距和左边距的时候，很多时候选择<code>margin:top 0 bottom 0</code>但<code>margin-bottom:bottom;margin-left:left;</code>执行的效率更高。</li><li>减少使用<code>@import</code>,而建议使用<code>link</code>，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</li></ol><p><strong>选择器性能：</strong></p><ol><li>关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择器是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</li><li>如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</li><li>避免使用通配规则，如*{}计算次数惊人！只对需要用到的元素进行选择。</li><li>尽量少的去对标签进行选择，而是用class。</li><li>尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li><li>了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</li></ol><p><strong>渲染性能：</strong></p><ol><li>慎重使用高性能属性：浮动、定位。</li><li>尽量减少页面重排、重绘。</li><li>去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</li><li>属性值为0时，不加单位。</li><li>属性值为浮动小数0.**，可以省略小数点之前的0。</li><li>标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li><li>不使用@import前缀，它会影响css的加载速度。</li><li>选择器优化嵌套，尽量避免层级过深。</li><li>css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li><li>正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</li><li>不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏<br>览器在下载web fonts时会阻塞页面渲染损伤性能。</li></ol><p><strong>可维护性、健壮性：</strong></p><ol><li>将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</li><li>样式与内容分离：将css代码定义到外部css中。</li></ol><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19886806">《CSS 优化、提高性能的方法有哪些？》</a><br><a href="https://www.jianshu.com/p/4e673bf24a3b">《CSS 优化，提高性能的方法》</a></p><h4 id="35-浏览器是怎样解析-CSS-选择器的？"><a href="#35-浏览器是怎样解析-CSS-选择器的？" class="headerlink" title="35.浏览器是怎样解析 CSS 选择器的？"></a>35.浏览器是怎样解析 CSS 选择器的？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直<br>到和规则匹配，或者是因为不匹配而放弃该规则。<br><br>试想一下，如果采用从左至右的方式读取CSS规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样做会费时耗能，<br>最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://juejin.im/entry/5a123c55f265da432240cc90">《探究 CSS 解析原理》</a></p><h4 id="36-在网页中应该使用奇数还是偶数的字体？为什么呢？"><a href="#36-在网页中应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="36.在网页中应该使用奇数还是偶数的字体？为什么呢？"></a>36.在网页中应该使用奇数还是偶数的字体？为什么呢？</h4><ol><li>偶数字号相对更容易和web设计的其他部分构成比例关系。比如：当我用了14px的正文字号，我可能会在一些地方用14×0.5&#x3D;7px的margin，在另一些地方用14×1.5&#x3D;21px的标题字号。</li><li>浏览器缘故，低版本的浏览器ie6会把奇数字体强制转化为偶数，即13px渲染为14px。</li><li>系统差别，早期的Windows里，中易宋体点阵只有12和14、15、16px，唯独缺少13px。</li></ol><p>详细资料可以参考：<br><a href="https://blog.csdn.net/jian_xi/article/details/79346477">《谈谈网页中使用奇数字体和偶数字体》</a><br><a href="https://www.zhihu.com/question/20440679">《现在网页设计中的为什么少有人用 11px、13px、15px 等奇数的字体？》</a></p><h4 id="37-margin-和-padding-分别适合什么场景使用？"><a href="#37-margin-和-padding-分别适合什么场景使用？" class="headerlink" title="37.margin 和 padding 分别适合什么场景使用？"></a>37.margin 和 padding 分别适合什么场景使用？</h4><p>margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。<br>margin用于布局分开元素使元素与元素互不相干。<br>padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段距离。</p><p>何时应当使用margin：</p><ul><li>需要在border外侧添加空白时。</li><li>空白处不需要背景（色）时。</li><li>上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。</li></ul><p>何时应当时用padding：</p><ul><li>需要在border内测添加空白时。</li><li>空白处需要背景（色）时。</li><li>上下相连的两个盒子之间的空白，不需要相互抵消时。如15px+20px的margin，将得到35px的空白。</li></ul><h4 id="38-抽离样式模块怎么写，说出思路，有无实践经验？-阿里航旅的面试题"><a href="#38-抽离样式模块怎么写，说出思路，有无实践经验？-阿里航旅的面试题" class="headerlink" title="38.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]"></a>38.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题]</h4><p>&nbsp;&nbsp;<strong>我的理解是把常用的css样式单独做成css文件……通用的和业务相关的分离出来，通用的做成样式模块儿共享，业务相关的，放进业务相关的库里面做成对应功能的模块儿。</strong></p><p>详细资料可以参考：<a href="http://nec.netease.com/standard/css-sort.html">《CSS 规范-分类方法》</a></p><h4 id="39-简单说一下-css3-的-all-属性。"><a href="#39-简单说一下-css3-的-all-属性。" class="headerlink" title="39.简单说一下 css3 的 all 属性。"></a>39.简单说一下 css3 的 all 属性。</h4><p>&nbsp;&nbsp;all属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction这两个CSS属性。支持三个CSS通用属性值，initial,inherit,unset。</p><p><strong>initial:</strong> initial是初始值的意思，也就是该元素除了<code>unicode-bidi</code>和<code>direction</code>以外的CSS属性都使用属性的默认初始值。</p><p><strong>inherit:</strong> inherit是继承的意思，也就是该元素除了<code>unicode-bidi</code>和<code>direction</code>以外的CSS属性都继承父元素的属性值。</p><p><strong>unset:</strong> unset是取消设置的意思，也就是当前元素浏览器或用户设置的CSS忽略，然后如果是具有继承特性的CSS，如<code>color</code>，则使用继承值；如果是没有继承特性的CSS属性，如<code>background-color</code>，则使用初始值。</p><p>详细资料可以参考：<a href="https://www.zhangxinxu.com/wordpress/2016/03/know-about-css3-all/">《简单了解 CSS3 的 all 属性》</a></p><h4 id="40-为什么不建议使用统配符初始化-css-样式。"><a href="#40-为什么不建议使用统配符初始化-css-样式。" class="headerlink" title="40.为什么不建议使用统配符初始化 css 样式。"></a>40.为什么不建议使用统配符初始化 css 样式。</h4><p>&nbsp;&nbsp;采用<code>*&#123;padding:0;margin:0;&#125;</code>这样的写法好处是写起来很简单，但是是通配符，需要把所有的标签都遍历一遍，当网站较大时，样式比较多，这样写就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间，因此一般大型的网站都有分层次的一套初始化样式。</p><p>&nbsp;&nbsp;出于性能的考虑，并不是所有标签都会有<code>padding</code>和<code>margin</code>，因此对常见的具有默认<code>padding</code>和<code>margin</code>的元素初始化即可，并不需使用通配符*来初始化。</p><h4 id="41-absolute-的-containingblock（包含块）计算方式跟正常流有什么不同？"><a href="#41-absolute-的-containingblock（包含块）计算方式跟正常流有什么不同？" class="headerlink" title="41.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？"></a>41.absolute 的 containingblock（包含块）计算方式跟正常流有什么不同？</h4><ul><li>内联元素也可以作为“包含块”所在的元素；</li><li>“包含块”所在的元素不是父块级元素，而是最近的position不为static的祖先元素或根元素；</li><li>边界是padding box而不是content box。</li></ul><h4 id="42-对于-hasLayout-的理解？"><a href="#42-对于-hasLayout-的理解？" class="headerlink" title="42.对于 hasLayout 的理解？"></a>42.对于 hasLayout 的理解？</h4><p>&nbsp;&nbsp;hasLayout是IE特有的一个属性。很多的IE下的css bug都与其息息相关。在IE中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完成这些工作。</p><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000010883974">《CSS 基础篇–CSS 中 IE 浏览器的 hasLayout，IE 低版本的 bug 根源》</a><br><a href="https://segmentfault.com/a/1190000004632071">《CSS 魔法堂：hasLayout 原来是这样的！》</a></p><h4 id="43-元素竖向的百分比设定是相对于容器的高度吗？"><a href="#43-元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="43.元素竖向的百分比设定是相对于容器的高度吗？"></a>43.元素竖向的百分比设定是相对于容器的高度吗？</h4><p><strong>如果是height的话，是相对于包含块的高度。</strong><br><strong>如果是padding或者margin竖直方向的属性则是相对于包含块的宽度。</strong></p><h4 id="44-全屏滚动的原理是什么？用到了-CSS-的哪些属性？（待深入实践）"><a href="#44-全屏滚动的原理是什么？用到了-CSS-的哪些属性？（待深入实践）" class="headerlink" title="44.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）"></a>44.全屏滚动的原理是什么？用到了 CSS 的哪些属性？（待深入实践）</h4><p>&nbsp;&nbsp;<strong>原理：</strong> 有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，容器及容器内的页面取当前可视区高度，同时容器的父级元素overflow属性值设为hidden，通过更改容器可视区的位置来实现全屏滚动效果。主要是响应鼠标事件，页面通过CSS的动画效果，进行移动。<br><code>overflow：hidden；transition：all 1000ms ease；</code></p><p>详细资料可以参考：<br><a href="https://blog.csdn.net/liona_koukou/article/details/52680409">《js 实现网页全屏切换（平滑过渡），鼠标滚动切换》</a><br><a href="https://juejin.im/post/5aeef41cf265da0ba0630de0">《用 ES6 写全屏滚动插件》</a></p><h4 id="45-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？（待深入了解）"><a href="#45-什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的-IE？（待深入了解）" class="headerlink" title="45.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）"></a>45.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？（待深入了解）</h4><p>&nbsp;&nbsp;响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。页面头部必须有meta声明的viewport。</p><p>详细资料可以参考：<br><a href="https://blog.csdn.net/dreamerframework/article/details/8994741">《响应式布局原理》</a><br><a href="http://www.mahaixiang.cn/wzsj/278.html">《响应式布局的实现方法和原理》</a></p><h4 id="46-视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）"><a href="#46-视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）" class="headerlink" title="46.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）"></a>46.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）</h4><p>&nbsp;&nbsp;视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。</p><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/20990029">《如何实现视差滚动效果的网页？》</a></p><h4 id="47-如何修改-chrome-记住密码后自动填充表单的黄色背景？"><a href="#47-如何修改-chrome-记住密码后自动填充表单的黄色背景？" class="headerlink" title="47.如何修改 chrome 记住密码后自动填充表单的黄色背景？"></a>47.如何修改 chrome 记住密码后自动填充表单的黄色背景？</h4><p>&nbsp;&nbsp;chrome表单自动填充后，input文本框的背景会变成黄色的，通过审查元素可以看到这是由于chrome会默认给自动填充的input表单加上input:-webkit-autofill私有属性，然后对其赋予以下样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>  <span class="hljs-attribute">background-color</span>:<span class="hljs-built_in">rgb</span>(<span class="hljs-number">250</span>,<span class="hljs-number">255</span>,<span class="hljs-number">189</span>)<span class="hljs-meta">!important</span>;<br>  <span class="hljs-attribute">background-image</span>:none<span class="hljs-meta">!important</span>;<br>  <span class="hljs-attribute">color</span>:<span class="hljs-built_in">rgb</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<span class="hljs-meta">!important</span>;<br>&#125;<br><span class="hljs-comment">/*对chrome默认定义的background-color，background-image，color使用important是不能提高其优先级的，但是其他属性可使用。*/</span><br></code></pre></td></tr></table></figure><p>&nbsp;&nbsp;使用足够大的纯色内阴影来覆盖input输入框的黄色背景，处理如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span>:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill &#123;<br>  -webkit-<span class="hljs-attribute">box-shadow</span>:<span class="hljs-number">000px</span> <span class="hljs-number">1000px</span> white inset;<br>  <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#CCC</span> <span class="hljs-meta">!important</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://blog.csdn.net/zsl_955200/article/details/78276209">《去掉 chrome 记住密码后的默认填充样式》</a><br><a href="https://blog.csdn.net/M_agician/article/details/73381706">《修改谷歌浏览器 chrome 记住密码后自动填充表单的黄色背景》</a></p><h4 id="48-怎么让-Chrome-支持小于-12px-的文字？"><a href="#48-怎么让-Chrome-支持小于-12px-的文字？" class="headerlink" title="48.怎么让 Chrome 支持小于 12px 的文字？"></a>48.怎么让 Chrome 支持小于 12px 的文字？</h4><p>&nbsp;&nbsp;在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</p><p>解决办法：</p><ol><li>可以使用Webkit的内核的<code>-webkit-text-size-adjust</code>的私有CSS属性来解决，只要加了<code>-webkit-text-size-adjust:none;</code>字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持<code>-webkit-text-size-adjust</code>样式，所以要使用时候慎用。</li><li>还可以使用css3的<code>transform</code>缩放属性<code>-webkit-transform:scale(0.5);</code>注意<code>-webkit-transform:scale(0.75);</code>收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用<code>display：block/inline-block/...；</code></li><li>使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</li></ol><p>详细资料可以参考：<a href="https://570109268.iteye.com/blog/2406562">《谷歌浏览器不支持 CSS 设置小于 12px 的文字怎么办？》</a></p><h4 id="49-让页面里的字体变清晰，变细用-CSS-怎么做？"><a href="#49-让页面里的字体变清晰，变细用-CSS-怎么做？" class="headerlink" title="49.让页面里的字体变清晰，变细用 CSS 怎么做？"></a>49.让页面里的字体变清晰，变细用 CSS 怎么做？</h4><p>&nbsp;&nbsp;webkit内核的私有属性<code>：-webkit-font-smoothing</code>，用于字体抗锯齿，使用后字体看起来会更清晰舒服。<br>&nbsp;&nbsp;在MacOS测试环境下面设置<code>-webkit-font-smoothing:antialiased;</code>但是这个属性仅仅是面向MacOS，其他操作系统设置后无效。</p><p>详细资料可以参考：<a href="https://blog.csdn.net/huo_bao/article/details/50251585">《让字体变的更清晰 CSS 中-webkit-font-smoothing》</a></p><h4 id="50-font-style-属性中-italic-和-oblique-的区别？"><a href="#50-font-style-属性中-italic-和-oblique-的区别？" class="headerlink" title="50.font-style 属性中 italic 和 oblique 的区别？"></a>50.font-style 属性中 italic 和 oblique 的区别？</h4><p>&nbsp;&nbsp;<code>italic</code>和<code>oblique</code>这两个关键字都表示“斜体”的意思。<br>&nbsp;&nbsp;它们的区别在于，<code>italic</code>是使用当前字体的斜体字体，而<code>oblique</code>只是单纯地让文字倾斜。如果当前字体没有对应的斜体字体，<br>则退而求其次，解析为<code>oblique</code>，也就是单纯形状倾斜。</p><h4 id="51-设备像素、css-像素、设备独立像素、dpr、ppi-之间的区别？"><a href="#51-设备像素、css-像素、设备独立像素、dpr、ppi-之间的区别？" class="headerlink" title="51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？"></a>51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？</h4><p>&nbsp;&nbsp;设备像素指的是物理像素，一般手机的分辨率指的就是设备像素，一个设备的设备像素是不可变的。</p><p>&nbsp;&nbsp;css像素和设备独立像素是等价的，不管在何种分辨率的设备上，css像素的大小应该是一致的，css像素是一个相对单位，它是相对于设备像素的，一个css像素的大小取决于页面缩放程度和dpr的大小。</p><p>&nbsp;&nbsp;dpr指的是设备像素和设备独立像素的比值，一般的pc屏幕，dpr&#x3D;1。在iphone4时，苹果推出了retina屏幕，它的dpr为2。屏幕的缩放会改变dpr的值。</p><p>&nbsp;&nbsp;ppi指的是每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。</p><p>详细资料可以参考：<br><a href="https://www.cnblogs.com/libin-1/p/7148377.html">《什么是物理像素、虚拟像素、逻辑像素、设备像素，什么又是 PPI,DPI,DPR 和 DIP》</a><br><a href="https://www.jianshu.com/p/af6dad66e49a">《前端工程师需要明白的「像素」》</a><br><a href="https://github.com/jawil/blog/issues/21">《CSS 像素、物理像素、逻辑像素、设备像素比、PPI、Viewport》</a><br><a href="https://github.com/wujunchuan/wujunchuan.github.io/issues/15">《前端开发中像素的概念》</a></p><h4 id="52-layout-viewport、visual-viewport-和-ideal-viewport-的区别？"><a href="#52-layout-viewport、visual-viewport-和-ideal-viewport-的区别？" class="headerlink" title="52.layout viewport、visual viewport 和 ideal viewport 的区别？"></a>52.layout viewport、visual viewport 和 ideal viewport 的区别？</h4><p><strong>相关知识点：</strong></p><ul><li>如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定默认情况下把<code>viewport</code>设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。ppk把这个浏览器默认的<code>viewport</code>叫做<code>layout viewport</code>。</li><li><code>layout viewport</code>的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个<code>viewport</code>来代表浏览器可视区域的大小，ppk把这个<code>viewport</code>叫做<code>visual viewport</code>。</li><li><code>ideal viewport</code>是最适合移动设备的<code>viewport，ideal viewport</code>的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为<code>ideal viewport</code>的宽度（单位用px），那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。<code>ideal viewport</code>的意义在于，无论在何种分辨率的屏幕下，那些针对<code>ideal viewport</code>而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。</li></ul><p><strong>回答：</strong></p><ul><li>移动端一共需要理解三个viewport的概念的理解。</li><li>第一个视口是布局视口，在移动端显示网页时，由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，那么整个页面的布局都会显示错乱。所以移动端浏览器提供了一个<code>layout viewport</code>布局视口的概念，使用这个视口来对页面进行布局展示，一般<code>layout viewport</code>的大小为980px，因此页面布局不会有太大的变化，我们可以通过拖动和缩放来查看到这个页面。</li><li>第二个视口指的是视觉视口，<code>visual viewport</code>指的是移动设备上我们可见的区域的视口大小，一般为屏幕的分辨率的大小。<code>visual viewport</code>和<code>layout viewport</code>的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口中的网页内容。</li><li>第三个视口是理想视口，由于<code>layout viewport</code>一般比<code>visual viewport</code>要大，所以想要看到整个页面必须通过拖动和缩放才能实现。所以又提出了<code>ideal viewport</code>的概念，<code>ideal viewport</code>下用户不用缩放和滚动条就能够查看到整个页面，并且页面在不同分辨率下显示的内容大小相同。<code>ideal viewport</code>其实就是通过修改<code>layout viewport</code>的大小，让它等于设备的宽度，这个宽度可以理解为是设备独立像素，因此根据<code>ideal viewport</code>设计的页面，在不同分辨率的屏幕下，显示应该相同。</li></ul><p>详细资料可以参考：<br>  <a href="https://www.cnblogs.com/2050/p/3877280.html">《移动前端开发之 viewport 的深入理解》</a><br>  <a href="https://www.html.cn/archives/5975">《说说移动前端中 viewport（视口）》</a><br>  <a href="https://juejin.im/post/5b6d21daf265da0f9d1a2ed7#heading-14">《移动端适配知识你到底知多少》</a></p><h4 id="53-position-fixed-在-android-下无效怎么处理？"><a href="#53-position-fixed-在-android-下无效怎么处理？" class="headerlink" title="53.position:fixed;在 android 下无效怎么处理？"></a>53.position:fixed;在 android 下无效怎么处理？</h4><p>&nbsp;&nbsp;因为移动端浏览器默认的viewport叫做layout viewport。在移动端显示时，因为layout viewport的宽度大于移动端屏幕的宽度，所以页面会出现滚动条左右移动，fixed的元素是相对layout viewport来固定位置的，而不是移动端屏幕来固定位置的，所以会出现感觉fixed无效的情况。</p><p>&nbsp;&nbsp;如果想实现fixed相对于屏幕的固定效果，我们需要改变的是viewport的大小为ideal viewport，可以如下设置：<br>&nbsp;&nbsp;<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no"/></p><h4 id="54-如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）"><a href="#54-如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）" class="headerlink" title="54.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）"></a>54.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</h4><p>&nbsp;&nbsp;多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1&#x2F;60*1000ms＝16.7ms</p><h4 id="55-如何去除-inline-block-元素间间距？"><a href="#55-如何去除-inline-block-元素间间距？" class="headerlink" title="55.如何去除 inline-block 元素间间距？"></a>55.如何去除 inline-block 元素间间距？</h4><p>&nbsp;&nbsp;移除空格、使用<code>margin负值</code>、<code>使用font-size:0</code>、<code>letter-spacing</code>、<code>word-spacing</code></p><p>详细资料可以参考：<a href="https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/">《去除 inline-block 元素间间距的 N 种方法》</a></p><h4 id="56-overflow-scroll-时不能平滑滚动的问题怎么处理？"><a href="#56-overflow-scroll-时不能平滑滚动的问题怎么处理？" class="headerlink" title="56.overflow:scroll 时不能平滑滚动的问题怎么处理？"></a>56.overflow:scroll 时不能平滑滚动的问题怎么处理？</h4><p>&nbsp;&nbsp;以下代码可解决这种卡顿的问题<code>-webkit-overflow-scrolling:touch;</code>是因为这行代码启用了硬件加速特性，所以滑动很流畅。</p><p>详细资料可以参考：<a href="https://www.jianshu.com/p/1f4693d0ad2d">《解决页面使用 overflow:scroll 在 iOS 上滑动卡顿的问题》</a></p><h4 id="57-有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度。"><a href="#57-有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度。" class="headerlink" title="57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。"></a>57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。</h4><ol><li>外层<code>div</code>使用<code>position：relative；</code>高度要求自适应的div使用<code>position:absolute;top:100px;bottom:0;left:0;right:0;</code></li><li>使用<code>flex</code>布局，设置主轴为竖轴，第二个div的<code>flex-grow</code>为1。</li></ol><p>详细资料可以参考：<a href="https://blog.csdn.net/xutongbao/article/details/79408522">《有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度(三种方案)》</a></p><h4 id="58-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？"><a href="#58-png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？" class="headerlink" title="58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？"></a>58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？</h4><p><strong>相关知识点：</strong></p><ol><li><code>BMP</code>，是无损的、既支持索引色也支持直接色的、点阵图。这种图片格式几乎没有对数据进行压缩，所以<code>BMP</code>格式的图片通常具有较大的文件大小。</li><li><code>GIF</code>是无损的、采用索引色的、点阵图。采用LZW压缩算法进行编码。文件小，是<code>GIF</code>格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但<code>GIF</code>格式仅支持8bit的索引色，所以<code>GIF</code>格式适用于对色彩要求不高同时需要文件体积较小的场景。</li><li><code>JPEG</code>是有损的、采用直接色的、点阵图。<code>JPEG</code>的图片的优点，是采用了直接色，得益于更丰富的色彩，<code>JPEG</code>非常适合用来<br>存储照片，与<code>GIF</code>相比，<code>JPEG</code>不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，<br>又会导致图片文件较<code>GIF</code>更大。</li><li><code>PNG-8</code>是无损的、使用索引色的、点阵图。<code>PNG是</code>一种比较新的图片格式，<code>PNG-8</code>是非常好的<code>GIF</code>格式替代者，在可能的情况下，应该尽可能的使用<code>PNG-8</code>而不是<code>GIF</code>，因为在相同的图片效果下，<code>PNG-8</code>具有更小的文件体积。除此之外，<code>PNG-8</code>还支持透明度的调节，而<code>GIF</code>并不支持。现在，除非需要动画的支持，否则我们没有理由使用<code>GIF</code>而不是<code>PNG-8</code>。</li><li><code>PNG-24</code>是无损的、使用直接色的、点阵图。<code>PNG-24</code>的优点在于，它压缩了图片的数据，使得同样效果的图片，<code>PNG-24</code>格<br>式的文件大小要比<code>BMP</code>小得多。当然，<code>PNG24</code>的图片还是要比<code>JPEG、GIF、PNG-8</code>大得多。</li><li><code>SVG</code>是无损的、矢量图。<code>SVG</code>是矢量图。这意味着<code>SVG</code>图片由直线和曲线以及绘制它们的方法组成。当你放大一个<code>SVG</code>图片的时候，你看到的还是线和曲线，而不会出现像素点。这意味着<code>SVG</code>图片在放大时，不会失真，所以它非常适合用来绘制企业<code>Logo、Icon</code>等。</li><li><code>WebP</code>是谷歌开发的一种新图片格式，<code>WebP</code>是同时支持有损和无损压缩的、使用直接色的、点阵图。从名字就可以看出来它是为<code>Web</code>而生的，什么叫为<code>Web</code>而生呢？就是说相同质量的图片，<code>WebP</code>具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。</li></ol><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul><p>&nbsp;&nbsp;但是目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p><p><strong>回答：</strong></p><ol><li>jpeg(jpg)：支持的颜色比较丰富，不支持透明效果，不支持动图。一般用来显示照片。</li><li>gif：支持的颜色比较少，支持简单透明，支持动图。适用颜色单一的图片、动图。</li><li>png：支持的颜色丰富，支持复杂透明，不支持动图。专为网页而生。</li><li>webp：这种格式是谷歌推出的专门用来表示网页中的图片的一种格式。<br> 使用webp格式的最大的优点是，在相同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，<br> 因为图片体积的减少，意味着请求时间的减小，这样会提高用户的体验。<br> 缺点是目前在兼容性上不太好。<br> 选取图片规则：效果一样用小的，效果不一样用效果好的。</li></ol><p>详细资料可以参考：<a href="https://www.cnblogs.com/xinzhao/p/5130410.html">《图片格式那么多，哪种更适合你？》</a></p><h4 id="59-浏览器如何判断是否支持-webp-格式图片"><a href="#59-浏览器如何判断是否支持-webp-格式图片" class="headerlink" title="59.浏览器如何判断是否支持 webp 格式图片"></a>59.浏览器如何判断是否支持 webp 格式图片</h4><ol><li><p>宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格式的图片。</p></li><li><p>canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断返回值中是否含有image&#x2F;webp字段，如果包含则说明支持WebP，反之则不支持。</p></li></ol><p>详细资料可以参考：<br><a href="https://blog.csdn.net/jesslu/article/details/82495061">《判断浏览器是否支持 WebP 图片》</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLCanvasElement/toDataURL">《toDataURL()》</a></p><h4 id="60-什么是-Cookie-隔离？（或者说：请求资源的时候不要让它带-cookie-怎么做）"><a href="#60-什么是-Cookie-隔离？（或者说：请求资源的时候不要让它带-cookie-怎么做）" class="headerlink" title="60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）"></a>60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）</h4><p>&nbsp;&nbsp;网站向服务器请求的时候，会自动带上<code>cookie</code>，这样增加表头信息量，使请求变慢。</p><p>&nbsp;&nbsp;如果静态文件都放在主域名下，那静态文件请求的时候都带有的<code>cookie</code>的数据提交给<code>server</code>的，非常浪费流量，所以不如隔离开，静态资源放CDN。</p><p>&nbsp;&nbsp;因为<code>cookie</code>有域的限制，因此不能跨域提交请求，故使用非主域名的时候，请求头中就不会带有<code>cookie</code>数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。</p><p>&nbsp;&nbsp;同时这种方式不会将<code>cookie</code>传入<code>WebServer</code>，也减少了<code>WebServer</code>对<code>cookie</code>的处理分析环节，提高了<code>webserver</code>的http请求的解析速度。</p><p>详细资料可以参考：<a href="https://www.zhihu.com/question/36514327?rf=37353035">《CDN 是什么？使用 CDN 有什么优势？》</a></p><h4 id="61-style-标签写在-body-后与-body-前有什么区别？"><a href="#61-style-标签写在-body-后与-body-前有什么区别？" class="headerlink" title="61.style 标签写在 body 后与 body 前有什么区别？"></a>61.style 标签写在 body 后与 body 前有什么区别？</h4><p>&nbsp;&nbsp;页面加载自上而下当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象(即样式失效导致的页面闪烁问题(结构解析完但样式还没有解析完))</p><h4 id="62-什么是-CSS-预处理器-后处理器？"><a href="#62-什么是-CSS-预处理器-后处理器？" class="headerlink" title="62.什么是 CSS 预处理器&#x2F;后处理器？"></a>62.什么是 CSS 预处理器&#x2F;后处理器？</h4><p>&nbsp;&nbsp;<code>CSS</code>预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为<code>CSS</code>增加了一些编程的特性，将<code>CSS</code>作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，<code>CSS</code>预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的<code>CSS</code>文件。</p><p>&nbsp;&nbsp;预处理器例如：<code>LESS、Sass、Stylus</code>，用来预编译<code>Sass</code>或<code>less</code> ，增强了<code>css</code>代码的复用性，还有<code>层级、mixin、变量、循环、函数</code>等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</p><p>&nbsp;&nbsp;<code>CSS</code>后处理器是对<code>CSS</code>进行处理，并最终生成<code>CSS</code>的预处理器，它属于广义上的<code>CSS</code>预处理器。我们很久以前就在用<code>CSS</code>后处理器了，最典型的例子是<code>CSS</code>压缩工具（如<code>clean-css</code>），只不过以前没单独拿出来说过。还有最近比较火的<code>Autoprefixer</code>，以<code>CanIUse</code>上的浏览器支持数据为基础，自动处理兼容性问题。</p><p>&nbsp;&nbsp;后处理器例如：<code>PostCSS</code>，通常被视为在完成的样式表中根据<code>CSS</code>规范处理<code>CSS</code>，让其更有效；目前最常做的是给<code>CSS</code>属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p><p>详细资料可以参考：<a href="https://blog.csdn.net/yushuangyushuang/article/details/79209752">《CSS 预处理器和后处理器》</a></p><h4 id="63-阐述一下-CSS-Sprites"><a href="#63-阐述一下-CSS-Sprites" class="headerlink" title="63.阐述一下 CSS Sprites"></a>63.阐述一下 CSS Sprites</h4><p>&nbsp;&nbsp;将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的<code>background-image，background-repeat，background-position</code>的组合进行背景定位。利用<code>CSS Sprites</code>能很好地减少网页的http请求，从而很好的提高页面的性能；<code>CSS Sprites</code>能减少图片的字节。</p><p>  优点：<br>  减少HTTP请求数，极大地提高页面加载速度<br>  增加图片信息重复度，提高压缩比，减少图片大小<br>  更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</p><p>  缺点：<br>  图片合并麻烦<br>  维护麻烦，修改一个图片可能需要重新布局整个图片，样式</p><h4 id="64-使用-rem-布局的优缺点？"><a href="#64-使用-rem-布局的优缺点？" class="headerlink" title="64.使用 rem 布局的优缺点？"></a>64.使用 rem 布局的优缺点？</h4><p><strong>优点：</strong><br>&nbsp;&nbsp;在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持rem了，兼容性也非常的好。</p><p><strong>缺点：</strong></p><ol><li>在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。</li><li>使用iframe引用也会出现问题。</li><li>rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问<br>题。</li></ol><p>详细资料可以参考：<br>  <a href="https://www.zhihu.com/question/21504656">《css3 的字体大小单位 rem 到底好在哪？》</a><br>  <a href="https://www.jianshu.com/p/e8ae1c3861dc">《VW:是时候放弃 REM 布局了》</a><br>  <a href="https://blog.csdn.net/Honeymao/article/details/76795089">《为什么设计稿是 750px》</a><br>  <a href="https://github.com/amfe/article/issues/17">《使用 Flexible 实现手淘 H5 页面的终端适配》</a></p><h4 id="65-几种常见的-CSS-布局"><a href="#65-几种常见的-CSS-布局" class="headerlink" title="65.几种常见的 CSS 布局"></a>65.几种常见的 CSS 布局</h4><h5 id="圣杯布局："><a href="#圣杯布局：" class="headerlink" title="圣杯布局："></a><strong>圣杯布局</strong>：</h5><ol><li><p>比较特殊的三栏布局，同样也是<strong>两边固定宽度，中间自适应</strong>，唯一区别是dom结构必须是<strong>先写中间列部分</strong>，这样实现中间列可以优先加载。</p></li><li><p>三个部分都设定为左浮动，否则左右两边内容上不去，就不可能与中间列同一行。然后设置center的宽度为100%(**实现中间列内容自适应)**，此时，left和right部分会跳到下一行。</p></li></ol><p>  <img src="https://user-gold-cdn.xitu.io/2018/10/18/16682cae82722a6a?imageslim" alt="img"></p><ol start="3"><li>通过设置margin-left为负值让left和right部分回到与center部分同一行。</li></ol><p>  <img src="https://user-gold-cdn.xitu.io/2018/10/18/16682c1d72a1ea68?imageslim" alt="img"></p><ol start="4"><li>通过设置父容器的padding-left和padding-right，让左右两边留出间隙。</li></ol><p>  <img src="https://user-gold-cdn.xitu.io/2018/10/18/16682c473f605745?imageslim" alt="img"></p><ol start="5"><li>通过设置相对定位，让left和right部分移动到两边。</li></ol><p>  <img src="https://user-gold-cdn.xitu.io/2018/10/17/16682bf3615502c2?imageslim" alt="img"></p><h5 id="圣杯布局的缺点："><a href="#圣杯布局的缺点：" class="headerlink" title="圣杯布局的缺点："></a>圣杯布局的缺点：</h5><ul><li>center部分的最小宽度不能小于left部分的宽度，否则会left部分掉到下一行</li><li>如果其中一列内容高度拉长，其他两列的背景并不会自动填充。(借助等高布局正padding+负margin可解决，下文会介绍)</li></ul><h5 id="双飞翼布局："><a href="#双飞翼布局：" class="headerlink" title="双飞翼布局："></a>双飞翼布局：</h5><ol><li>同样也是三栏布局，在圣杯布局基础上进一步优化，解决了圣杯布局错乱问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题。</li><li>实现步骤(前两步与圣杯布局一样)<br>1. 三个部分都设定为左浮动，然后设置center的宽度为100%，此时，left和right部分会跳到下一行；<br>2. 通过设置margin-left为负值让left和right部分回到与center部分同一行；<br>3. center部分增加一个内层div，并设margin: 0 200px；</li></ol><h5 id="双飞翼布局的缺点："><a href="#双飞翼布局的缺点：" class="headerlink" title="双飞翼布局的缺点："></a><strong>双飞翼布局的缺点：</strong></h5><pre><code class="hljs"> 多加一层 dom 树节点，增加渲染树生成的计算量。</code></pre><h5 id="两种布局实现方式对比"><a href="#两种布局实现方式对比" class="headerlink" title="两种布局实现方式对比:"></a>两种布局实现方式对比:</h5><ul><li>两种布局方式都是把主列放在文档流最前面，使主列优先加载。</li><li>两种布局方式在实现上也有相同之处，都是让三列浮动，然后通过负外边距形成三列布局。</li><li>两种布局方式的不同之处在于如何处理中间主列的位置： <strong>圣杯布局是利用父容器的左、右内边距+两个从列相对定位</strong>； <strong>双飞翼布局是把主列嵌套在一个新的父级块中利用主列的左、右外边距进行布局调整</strong>。</li></ul><p>详细的资料可以参考：<a href="https://juejin.im/post/5bbcd7ff5188255c80668028#heading-12">《几种常见的 CSS 布局》</a></p><h4 id="66-画一条-0-5px-的线"><a href="#66-画一条-0-5px-的线" class="headerlink" title="66.画一条 0.5px 的线"></a>66.画一条 0.5px 的线</h4><p>&nbsp;&nbsp;采用<code>meta viewport</code>的方式<br>&nbsp;&nbsp;采用<code>border-image</code>的方式<br>&nbsp;&nbsp;&nbsp;回答时答这个就行： 采用<code>transform:scaleY()</code>的方式 &#x2F;&#x2F;注意chrome下实线变虚的问题，可以通过设置<code>transform-origin: 50% 100%</code>解决</p><p>详细资料可以参考：<a href="https://juejin.im/post/5ab65f40f265da2384408a95">《怎么画一条 0.5px 的边（更新）》</a></p><h4 id="67-transition-和-animation-的区别"><a href="#67-transition-和-animation-的区别" class="headerlink" title="67.transition 和 animation 的区别"></a>67.transition 和 animation 的区别</h4><p>&nbsp;&nbsp;<code>transition</code>关注的是<code>CSS property</code>的变化，<code>property</code>值和时间的关系是一个三次贝塞尔曲线。一般结合<code>transforms</code>使用</p><p>&nbsp;&nbsp;<code>animation</code>作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。</p><p>详细资料可以参考：<br>  <a href="https://www.zhihu.com/question/19749045">《CSSanimation 与 CSStransition 有何区别？》</a><br>  <a href="https://blog.csdn.net/cddcj/article/details/53582334">《CSS3Transition 和 Animation 区别及比较》</a><br>  <a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html">《CSS 动画简介》</a><br>  <a href="https://juejin.im/post/5b137e6e51882513ac201dfb">《CSS 动画：animation、transition、transform、translate》</a></p><h4 id="68-什么是首选最小宽度？"><a href="#68-什么是首选最小宽度？" class="headerlink" title="68.什么是首选最小宽度？"></a>68.什么是首选最小宽度？</h4><p>&nbsp;&nbsp;“首选最小宽度”，指的是元素最适合的最小宽度。</p><p>&nbsp;&nbsp;东亚文字（如中文）最小宽度为每个汉字的宽度。</p><p>&nbsp;&nbsp;西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短横线、问号以及其他非英文字符等。</p><p>&nbsp;&nbsp;如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS中的word-break:break-all。</p><h4 id="69-为什么-height-100-会无效？"><a href="#69-为什么-height-100-会无效？" class="headerlink" title="69.为什么 height:100%会无效？"></a>69.为什么 height:100%会无效？</h4><p>&nbsp;&nbsp;对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。</p><p>&nbsp;&nbsp;原因是如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto，因为解释成了auto，所以无法参与计算。</p><p>&nbsp;&nbsp;使用绝对定位的元素会有计算值，即使祖先元素的height计算为auto也是如此。</p><h4 id="70-min-width-max-width-和-min-height-max-height-属性间的覆盖规则？"><a href="#70-min-width-max-width-和-min-height-max-height-属性间的覆盖规则？" class="headerlink" title="70.min-width&#x2F;max-width 和 min-height&#x2F;max-height 属性间的覆盖规则？"></a>70.min-width&#x2F;max-width 和 min-height&#x2F;max-height 属性间的覆盖规则？</h4><ol><li><code>max-width</code>会覆盖<code>width</code>，即使<code>width</code>是行类样式或者设置了<code>!important</code>。</li><li><code>min-width</code>会覆盖<code>max-width</code>，此规则发生在<code>min-width</code>和<code>max-width</code>冲突的时候。</li></ol><h4 id="71-内联盒模型基本概念"><a href="#71-内联盒模型基本概念" class="headerlink" title="71.内联盒模型基本概念"></a>71.内联盒模型基本概念</h4><ol><li>内容区域<code>content area</code>。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子<code>character box</code>；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些元素，内容区域可以看成元素自身。</li><li>内联盒子<code>inline box</code>。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类。</li><li>行框盒子<code>line box</code>，每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。</li><li>包含块<code>containing box</code>，由一行一行的“行框盒子”组成。</li></ol><h4 id="72-什么是幽灵空白节点？"><a href="#72-什么是幽灵空白节点？" class="headerlink" title="72.什么是幽灵空白节点？"></a>72.什么是幽灵空白节点？</h4><p>&nbsp;&nbsp;“幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。</p><h4 id="73-什么是替换元素？"><a href="#73-什么是替换元素？" class="headerlink" title="73.什么是替换元素？"></a>73.什么是替换元素？</h4><p>&nbsp;&nbsp;通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。因此，<code>&lt;img&gt;、&lt;object&gt;、&lt;video&gt;、&lt;iframe&gt;</code>或者表<br>单元素<code>&lt;textarea&gt;</code>和<code>&lt;input&gt;</code>和<code>&lt;select&gt;</code>都是典型的替换元素。</p><p>替换元素除了内容可替换这一特性以外，还有以下一些特性。</p><ol><li><p>内容的外观不受页面上的CSS的影响。用专业的话讲就是样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似<code>appearance</code>属性，或者浏览器自身暴露的一些样式接口，</p></li><li><p>有自己的尺寸。在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如<code>&lt;video&gt;、&lt;iframe&gt;</code>或者<code>&lt;canvas&gt;</code>等，也有少部分替换元素为<code>0</code>像素，如<code>&lt;img&gt;</code>图片，而表单元素的替换元素的尺寸则和浏览器有关，没有明显的规律。</p></li><li><p>在很多CSS属性上有自己的一套表现规则。比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，<code>vertical-align</code>属性值的解释是不一样的。比方说<code>vertical-align</code>的默认值的<code>baseline</code>，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</p></li><li><p>所有的替换元素都是内联水平元素，也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的<code>display</code>值却是不一样的，有的是<code>inline</code>，有的是<code>inline-block</code>。</p></li></ol><h4 id="74-替换元素的计算规则？"><a href="#74-替换元素的计算规则？" class="headerlink" title="74.替换元素的计算规则？"></a>74.替换元素的计算规则？</h4><p>替换元素的尺寸从内而外分为3类：固有尺寸、HTML尺寸和CSS尺寸。</p><ol><li>固有尺寸指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</li><li>HTML尺寸只能通过HTML原生属性改变，这些HTML原生属性包括<code>&lt;img&gt;</code>的<code>width</code>和<code>height</code>属性、<code>&lt;input&gt;</code>的<code>size</code>属性、<code>&lt;textarea&gt;</code>的<code>cols</code>和<code>rows</code>属性等。</li><li>CSS尺寸特指可以通过CSS的<code>width</code>和<code>height</code>或者<code>max-width/min-width</code>和<code>max-height/min-height</code>设置的尺寸，对应盒尺寸中的<code>content box</code>。</li></ol><p>这3层结构的计算规则具体如下: (简单理解为：固有尺寸、HTML尺寸和CSS尺寸优先级依次递增。)</p><ol><li>如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。</li><li>如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。</li><li>如果有CSS尺寸，则最终尺寸由CSS属性决定。</li><li>如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。</li><li>如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。</li><li>内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</li></ol><h4 id="75-content-与替换元素的关系？"><a href="#75-content-与替换元素的关系？" class="headerlink" title="75.content 与替换元素的关系？"></a>75.content 与替换元素的关系？</h4><p><code>content</code>属性生成的对象称为“匿名替换元素”。</p><ol><li>我们使用<code>content</code>生成的文本是无法选中、无法复制的，好像设置了<code>user select:none</code>声明一般，但是普通元素的文本却可以被轻松选中。同时，<code>content</code>生成的文本无法被屏幕阅读设备读取，也无法被搜索引擎抓取，因此，千万不要自以为是地把重要的文本信息使用<code>content</code>属性生成，因为这对可访问性和SEO都很不友好。</li><li><code>content</code>生成的内容不能左右<code>:empty</code>伪类。</li><li><code>content</code>动态生成值无法获取。</li></ol><h4 id="76-margin-auto-的填充规则？"><a href="#76-margin-auto-的填充规则？" class="headerlink" title="76.margin:auto 的填充规则？"></a>76.margin:auto 的填充规则？</h4><p>&nbsp;&nbsp;<code>margin</code>的<code>auto</code>可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发<code>margin:auto</code>计算有一个前提条件，就是<code>width</code>或<code>height</code>为<code>auto</code>时，元素是具有对应方向的自动填充特性的。</p><ol><li>如果一侧定值，一侧<code>auto</code>，则<code>auto</code>为剩余空间大小。</li><li>如果两侧均是<code>auto</code>，则平分剩余空间。</li></ol><h4 id="77-margin-无效的情形"><a href="#77-margin-无效的情形" class="headerlink" title="77.margin 无效的情形"></a>77.margin 无效的情形</h4><ol><li><p><code>display</code>计算值<code>inline</code>的非替换元素的垂直<code>margin</code>是无效的。对于内联替换元素，垂直<code>margin</code>有效，并且没有<code>margin</code>合并的问题。</p></li><li><p>表格中的<code>&lt;tr&gt;</code>和<code>&lt;td&gt;</code>元素或者设置<code>display</code>计算值是<code>table-cell</code>或<code>table-row</code>的元素的<code>margin</code>都是无效的。</p></li><li><p>绝对定位元素非定位方位的<code>margin</code>值“无效”。</p></li><li><p>定高容器的子元素的<code>margin-bottom</code>或者宽度定死的子元素的<code>margin-right</code>的定位“失效”。</p></li></ol><h4 id="78-border-的特殊性？"><a href="#78-border-的特殊性？" class="headerlink" title="78.border 的特殊性？"></a>78.border 的特殊性？</h4><ol><li><code>border-width</code>却不支持百分比。</li><li><code>border-style</code>的默认值是<code>none</code>，有一部分人可能会误以为是<code>solid</code>。这也是单纯设置<code>border-width</code>或<code>border-color</code>没有边框显示的原因。</li><li><code>border-style:double</code>的表现规则：双线宽度永远相等，中间间隔±1。</li><li><code>border-color</code>默认颜色就是<code>color</code>色值。</li><li>默认<code>background</code>背景图片是相对于<code>padding box</code>定位的。</li></ol><h4 id="79-什么是基线和-x-height？"><a href="#79-什么是基线和-x-height？" class="headerlink" title="79.什么是基线和 x-height？"></a>79.什么是基线和 x-height？</h4><p>&nbsp;&nbsp;字母x的下边缘（线）就是我们的基线。</p><p>&nbsp;&nbsp;x-height指的就是小写字母x的高度，术语描述就是基线和等分线（meanline）（也称作中线，midline）之间的距离。在CSS世界中，middle指的是基线往上1&#x2F;2x-height高度。我们可以近似理解为字母x交叉点那个位置。</p><p>&nbsp;&nbsp;ex是CSS中的一个相对单位，指的是小写字母x的高度，没错，就是指x-height。ex的价值就在其副业上不受字体和字号影响的内联元素的垂直居中对齐效果。内联元素默认是基线对齐的，而基线就是x的底部，而1ex就是一个x的高度。</p><h4 id="80-line-height-的特殊性？"><a href="#80-line-height-的特殊性？" class="headerlink" title="80.line-height 的特殊性？"></a>80.line-height 的特殊性？</h4><ol><li>对于非替换元素的纯内联元素，其可视高度完全由line-height决定。对于文本这样的纯内联元素，line-height就是高度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。</li><li>内联元素的高度由固定高度和不固定高度组成，这个不固定的部分就是这里的“行距”。换句话说，line-height之所以起作用，就是通过改变“行距”来实现的。在CSS中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”。</li><li>行距 &#x3D; line-height - font-size。</li><li>border以及line-height等传统CSS属性并没有小数像素的概念。如果标注的是文字上边距，则向下取整；如果是文字下边距，则向上取整。</li><li>对于纯文本元素，line-height直接决定了最终的高度。但是，如果同时有替换元素，则line-height只能决定最小高度。</li><li>对于块级元素，line-height对其本身是没有任何作用的，我们平时改变line-height，块级元素的高度跟着变化实际上是通过改变块级元素里面内联级别元素占据的高度实现的。</li><li>line-height的默认值是normal，还支持数值、百分比值以及长度值。为数值类型时，其最终的计算值是和当前font-size相乘后的值。为百分比值时，其最终的计算值是和当前font-size相乘后的值。为长度值时原意不变。</li><li>如果使用数值作为line-height的属性值，那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值。</li><li>无论内联元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定的。</li><li>只要有“内联盒子”在，就一定会有“行框盒子”，就是每一行内联元素外面包裹的一层看不见的盒子。然后，重点来了，在每个“行框盒子”前面有一个宽度为0的具有该元素的字体和行高属性的看不见的“幽灵空白节点”。</li></ol><h4 id="81-vertical-align-的特殊性？"><a href="#81-vertical-align-的特殊性？" class="headerlink" title="81.vertical-align 的特殊性？"></a>81.vertical-align 的特殊性？</h4><ol><li><code>vertical-align</code>的默认值是<code>baseline</code>，即基线对齐，而基线的定义是字母x的下边缘。因此，内联元素默认都是沿着字母x的下边缘对齐的。对于图片等替换元素，往往使用元素本身的下边缘作为基线。：一个<code>inline-block</code>元素，如果里面没有内联元素，或者<code>overflow</code>不是<code>visible</code>，则该元素的基线就是其<code>margin</code>底边缘；否则其基线就是元素里面最后一行内联元素的基线。</li><li><code>vertical-align:top</code>就是垂直上边缘对齐，如果是内联元素，则和这一行位置最高的内联元素的顶部对齐；如果<code>display</code>计算值是<code>table-cell</code>的元素，我们不妨脑补成<code>&lt;td&gt;</code>元素，则和<code>&lt;tr&gt;</code>元素上边缘对齐。</li><li><code>vertical-align:middle</code>是中间对齐，对于内联元素，元素的垂直中心点和行框盒子基线往上<code>1/2x-height</code>处对齐。对于<code>table-cell</code>元素，单元格填充盒子相对于外面的表格行居中对齐。</li><li><code>vertical-align</code>支持数值属性，根据数值的不同，相对于基线往上或往下偏移，如果是负值，往下偏移，如果是正值，往上偏移。</li><li><code>vertical-align</code>属性的百分比值则是相对于<code>line-height</code>的计算值计算的。</li><li><code>vertical-align</code>起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及<code>display</code>值为<code>table-cell</code>的元素。</li><li><code>table-cell</code>元素设置<code>vertical-align</code>垂直对齐的是子元素，但是其作用的并不是子元素，而是<code>table-cell</code>元素自身。</li></ol><h4 id="82-overflow-的特殊性？"><a href="#82-overflow-的特殊性？" class="headerlink" title="82.overflow 的特殊性？"></a>82.overflow 的特殊性？</h4><ol><li>一个设置了<code>overflow:hidden</code>声明的元素，假设同时存在<code>border</code>属性和<code>padding</code>属性，则当子元素内容超出容器宽度高度限制的时候，剪裁的边界是<code>border box</code>的内边缘，而非<code>padding box</code>的内边缘。</li><li><code>HTML</code>中有两个标签是默认可以产生滚动条的，一个是根元素<code>&lt;html&gt;</code>，另一个是文本域<code>&lt;textarea&gt;</code>。</li><li>滚动条会占用容器的可用宽度或高度。</li><li>元素设置了<code>overflow:hidden</code>声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！</li></ol><h4 id="83-无依赖绝对定位是什么？"><a href="#83-无依赖绝对定位是什么？" class="headerlink" title="83.无依赖绝对定位是什么？"></a>83.无依赖绝对定位是什么？</h4><p>没有设置<code>left/top/right/bottom</code>属性值的绝对定位称为“无依赖绝对定位”。</p><p>无依赖绝对定位其定位的位置和没有设置<code>position:absolute</code>时候的位置相关。</p><h4 id="84-absolute-与-overflow-的关系？"><a href="#84-absolute-与-overflow-的关系？" class="headerlink" title="84.absolute 与 overflow 的关系？"></a>84.absolute 与 overflow 的关系？</h4><ol><li>如果<code>overflow</code>不是定位元素，同时绝对定位元素和<code>overflow</code>容器之间也没有定位元素，则<code>overflow</code>无法对<code>absolute</code>元素进行剪裁。</li><li>如果<code>overflow</code>的属性值不是<code>hidden</code>而是<code>auto</code>或者<code>scroll</code>，即使绝对定位元素高宽比<code>overflow</code>元素高宽还要大，也都不会出现滚动条。</li><li><code>overflow</code>元素自身<code>transform</code>的时候，<code>Chrome和Opera</code>浏览器下的<code>overflow</code>剪裁是无效的。</li></ol><h4 id="85-clip-裁剪是什么？"><a href="#85-clip-裁剪是什么？" class="headerlink" title="85.clip 裁剪是什么？"></a>85.clip 裁剪是什么？</h4><p>&nbsp;&nbsp;所谓“可访问性隐藏”，指的是虽然内容肉眼看不见，但是其他辅助设备却能够进行识别和访问的隐藏。<br>&nbsp;&nbsp;clip剪裁被我称为“最佳可访问性隐藏”的另外一个原因就是，它具有更强的普遍适应性，任何元素、任何场景都可以无障碍使用。</p><h4 id="86-relative-的特殊性？"><a href="#86-relative-的特殊性？" class="headerlink" title="86.relative 的特殊性？"></a>86.relative 的特殊性？</h4><ol><li>相对定位元素的<code>left/top/right/bottom</code>的百分比值是相对于包含块计算的，而不是自身。注意，虽然定位位移是相对自身，但是百分比值的计算值不是。</li><li><code>top</code>和<code>bottom</code>这两个垂直方向的百分比值计算跟<code>height</code>的百分比值是一样的，都是相对高度计算的。同时，如果包含块的高度是auto，那么计算值是0，偏移无效，也就是说，如果父元素没有设定高度或者不是“格式化高度”，那么<code>relative</code>类似<code>top:20%</code>的代码等同于<code>top:0</code>。</li><li>当相对定位元素同时应用对立方向定位值的时候，也就是<code>top/bottom</code>和<code>left/right</code>同时使用的时候，只有一个方向的定位属性会起作用。而谁起作用则是与文档流的顺序有关的，默认的文档流是自上而下、从左往右，因此<code>top/bottom</code>同时使用的时候，<code>bottom</code>失效；<code>left/right</code>同时使用的时候，<code>right</code>失效。</li></ol><h4 id="87-什么是层叠上下文？"><a href="#87-什么是层叠上下文？" class="headerlink" title="87.什么是层叠上下文？"></a>87.什么是层叠上下文？</h4><p>&nbsp;&nbsp;层叠上下文，英文称作stacking context，是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元素在z轴上就“高人一等”。</p><p><strong>层叠上下文元素有如下特性：</strong></p><ol><li>层叠上下文的层叠水平要比普通元素高（原因后面会说明）。</li><li>层叠上下文可以阻断元素的混合模式。</li><li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。</li><li>每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。</li><li>每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</li></ol><p><strong>层叠上下文的创建：</strong></p><ol><li>页面根元素天生具有层叠上下文，称为根层叠上下文。根层叠上下文指的是页面根元素，可以看成是<code>&lt;html&gt;</code>元素。因此，页面中所有的元素一定处于至少一个“层叠结界”中。</li><li>对于<code>position</code>值为<code>relative/absolute</code>以及Firefox&#x2F;IE浏览器（不包括Chrome浏览器）下含有<code>position:fixed</code>声明的定位元素，当其<code>z-index</code>值不是<code>auto</code>的时候，会创建层叠上下文。<code>Chrome</code>等<code>WebKit</code>内核浏览器下，<code>position:fixed</code>元素天然层叠上下文元素，无须<code>z-index</code>为数值。根据我的测试，目前<code>IE和Firefox</code>仍是老套路。</li><li>其他一些<code>CSS3</code>属性，比如元素的<code>opacity</code>值不是1。</li></ol><h4 id="88-什么是层叠水平？"><a href="#88-什么是层叠水平？" class="headerlink" title="88.什么是层叠水平？"></a>88.什么是层叠水平？</h4><p>&nbsp;&nbsp;层叠水平，英文称作<code>stacking level</code>，决定了同一个层叠上下文中元素在z轴上的显示顺序。</p><p>&nbsp;&nbsp;显而易见，所有的元素都有层叠水平，包括层叠上下文元素，也包括普通元素。然而，对普通元素的层叠水平探讨只局限在当前层叠上下文元素中。</p><h4 id="89-元素的层叠顺序？"><a href="#89-元素的层叠顺序？" class="headerlink" title="89.元素的层叠顺序？"></a>89.元素的层叠顺序？</h4><p>&nbsp;&nbsp;层叠顺序，英文称作 <code>stacking order</code>，表示元素发生层叠时有着特定的垂直显示顺序。<br>&nbsp;&nbsp;<img src="https://cavszhouyou-1254093697.cos.ap-chongqing.myqcloud.com/note-15.png" alt="层叠顺序"></p><h4 id="90-层叠准则？"><a href="#90-层叠准则？" class="headerlink" title="90.层叠准则？"></a>90.层叠准则？</h4><ol><li><strong>谁大谁上：</strong> 当具有明显的层叠水平标识的时候，如生效的z-index属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。</li><li><strong>后来居上：</strong> 当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</li></ol><h4 id="91-font-weight-的特殊性？"><a href="#91-font-weight-的特殊性？" class="headerlink" title="91.font-weight 的特殊性？"></a>91.font-weight 的特殊性？</h4><p>&nbsp;&nbsp;如果使用数值作为<code>font-weight</code>属性值，必须是<code>100～900</code>的整百数。因为这里的数值仅仅是外表长得像数值，实际上是一个具有特定含义的关键字，并且这里的数值关键字和字母关键字之间是有对应关系的。一般使用<code>font-weight: bold</code>来加粗。\</p><h4 id="92-text-indent-的特殊性？"><a href="#92-text-indent-的特殊性？" class="headerlink" title="92.text-indent 的特殊性？"></a>92.text-indent 的特殊性？</h4><ol><li><code>text-indent</code>仅对第一行内联盒子内容有效。</li><li>非替换元素以外的<code>display</code>计算值为<code>inlin</code>e的内联元素设置<code>text-indent</code>值无效，如果计算值<code>inline-block/inline-table</code>则会生效。</li><li><code>&lt;input&gt;</code>标签按钮<code>text-indent</code>值无效。</li><li><code>&lt;button&gt;</code>标签按钮<code>text-indent</code>值有效。</li><li><code>text-indent</code>的百分比值是相对于当前元素的“包含块”计算的，而不是当前元素。</li></ol><h4 id="93-letter-spacing-与字符间距？"><a href="#93-letter-spacing-与字符间距？" class="headerlink" title="93.letter-spacing 与字符间距？"></a>93.letter-spacing 与字符间距？</h4><p><code>letter-spacing</code>可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。</p><p><code>letter-spacing</code>具有以下一些特性:</p><ol><li>继承性。</li><li>默认值是normal而不是0。虽然说正常情况下，normal的计算值就是0，但两者还是有差别的，在有些场景下，letter-spacing会调整normal的计算值以实现更好的版面布局。</li><li>支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。</li><li>和text-indent属性一样，无论值多大或多小，第一行一定会保留至少一个字符。</li><li>支持小数值，即使0.1px也是支持的。</li><li>暂不支持百分比值。</li></ol><h4 id="94-word-spacing-与单词间距？"><a href="#94-word-spacing-与单词间距？" class="headerlink" title="94.word-spacing 与单词间距？"></a>94.word-spacing 与单词间距？</h4><p>&nbsp;&nbsp;<code>letter-spacing</code>作用于所有字符，但<code>word-spacing</code>仅作用于空格字符。换句话说，<code>word-spacing</code>的作用就是增加空格的间隙宽度。</p><h4 id="95-white-space-与换行和空格的控制？"><a href="#95-white-space-与换行和空格的控制？" class="headerlink" title="95.white-space 与换行和空格的控制？"></a>95.white-space 与换行和空格的控制？</h4><p>&nbsp;&nbsp;<code>white-space</code>属性声明了如何处理元素内的空白字符，这类空白字符包括<code>Space(空格键)、Enter(回车键)、Tab(制表符键)</code>产生的空白。因此，<code>white-space</code>可以决定图文内容是否在一行显示(回车空格是否生效)，是否显示大段连续空白(空格是否生效)等。</p><p>其属性值包括下面这些:</p><ul><li><strong>normal：</strong> 合并空白字符和换行符。</li><li><strong>pre：</strong> 空白字符不合并，并且内容只在有换行符的地方换行。</li><li><strong>nowrap：</strong> 该值和normal一样会合并空白字符，但不允许文本环绕。</li><li><strong>pre-wrap：</strong> 空白字符不合并，并且内容只在有换行符的地方换行，同时允许文本环绕。</li><li><strong>pre-line：</strong> 合并空白字符，但只在有换行符的地方换行，允许文本环绕。</li></ul><h4 id="96-隐藏元素的-background-image-到底加不加载？"><a href="#96-隐藏元素的-background-image-到底加不加载？" class="headerlink" title="96.隐藏元素的 background-image 到底加不加载？"></a>96.隐藏元素的 background-image 到底加不加载？</h4><p><strong>相关知识点：</strong></p><ul><li>根据测试，一个元素如果display计算值为none，在IE浏览器下（IE8～IE11，更高版本不确定）依然会发送图片请求，Firefox浏览器不会，至于Chrome和Safari浏览器则似乎更加智能一点：如果隐藏元素同时又设置了background-image，则图片依然会去加载；如果是父元素的display计算值为none，则背景图不会请求，此时浏览器或许放心地认为这个背景图暂时是不会使用的。</li><li>如果不是background-image，而是<img>元素，则设置display:none在所有浏览器下依旧都会请求图片资源。</li><li>还需要注意的是如果设置的样式没有对应的元素，则background-image也不会加载。hover情况下的background-image，在触发时加载。</li></ul><p><strong>回答：</strong></p><ol><li>元素的背景图片<br>- 元素本身设置 display:none，会请求图片 -父级元素设置 display:none，不会请求图片 -样式没有元素使用，不会请求<br>- :hover 样式下，触发时请求</li><li>img 标签图片任何情况下都会请求图片</li></ol><p>详细资料可以参考：<a href="https://www.jb51.net/css/469033.html">《CSS 控制前端图片 HTTP 请求的各种情况示例》</a></p><h4 id="97-如何实现单行／多行文本溢出的省略（…）？"><a href="#97-如何实现单行／多行文本溢出的省略（…）？" class="headerlink" title="97.如何实现单行／多行文本溢出的省略（…）？"></a>97.如何实现单行／多行文本溢出的省略（…）？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*单行文本溢出*/</span><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">text-overflow</span>: ellipsis;<br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>&#125;<br><br><span class="hljs-comment">/*多行文本溢出*/</span><br><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5em</span>;<br>  <span class="hljs-comment">/*高度为需要显示的行数*行高，比如这里我们显示两行，则为3*/</span><br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">3em</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;...&#x27;</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br>  <a href="https://zhuanlan.zhihu.com/p/30707916">《【CSS&#x2F;JS】如何实现单行／多行文本溢出的省略》</a><br>  <a href="https://juejin.im/entry/587f453e1b69e60058555a5f">《CSS 多行文本溢出省略显示》</a></p><h4 id="98-常见的元素隐藏方式？"><a href="#98-常见的元素隐藏方式？" class="headerlink" title="98.常见的元素隐藏方式？"></a>98.常见的元素隐藏方式？</h4><ol><li>使用 <code>display:none;</code>隐藏元素，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li><li>使用 <code>visibility:hidden;</code>隐藏元素。元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li><li>使用 <code>opacity:0;</code>将元素的不透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li><li>通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li><li>通过 <code>z-index</code> 负值，来使其他元素遮盖住该元素，以此来实现隐藏。</li><li>通过 <code>clip/clip-path</code> 元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li><li>通过 <code>transform:scale(0,0)</code>来将元素缩放为 0，以此来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li></ol><p>详细资料可以参考：<a href="https://juejin.im/post/584b645a128fe10058a0d625#heading-2">《CSS 隐藏元素的八种方法》</a></p><h4 id="99-css-实现上下固定中间自适应布局？"><a href="#99-css-实现上下固定中间自适应布局？" class="headerlink" title="99.css 实现上下固定中间自适应布局？"></a>99.css 实现上下固定中间自适应布局？</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 利用绝对定位实现 */</span><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-class">.header</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: red;<br>&#125;<br><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">background</span>: green;<br>&#125;<br><br><span class="hljs-selector-class">.footer</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">background</span>: red;<br>&#125;<br><br><span class="hljs-comment">/* 利用flex布局实现 */</span><br><span class="hljs-selector-tag">html</span>,<br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">flex-direction</span>: column;<br>&#125;<br><br><span class="hljs-selector-class">.header</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: red;<br>&#125;<br><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: green;<br>&#125;<br><br><span class="hljs-selector-class">.footer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<a href="https://www.jianshu.com/p/30bc9751e3e8">《css 实现上下固定中间自适应布局》</a></p><h4 id="100-css-两栏布局的实现？"><a href="#100-css-两栏布局的实现？" class="headerlink" title="100.css 两栏布局的实现？"></a>100.css 两栏布局的实现？</h4><p><strong>相关资料：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。*/</span><br><span class="hljs-comment">/*以左边宽度固定为200px为例*/</span><br><br><span class="hljs-comment">/*（1）利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: auto;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-comment">/*（2）第二种是利用flex布局，将左边元素宽度设置为200px。将右边的元素的放大比例设置为1。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br><br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<br><br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-comment">/*（3）第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为absolute定位，并且宽度设置为</span><br><span class="hljs-comment">200px。将右边元素的margin-left的值设置为200px。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br><br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-comment">/*（4）第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br><br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br><br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="http://cavszhouyou.top/Demo-Display/TwoColumnLayout/index.html">《两栏布局 demo 展示》</a></p><p><strong>回答：</strong></p><p>两栏布局一般指的是页面中一共两栏，左边固定，右边自适应的布局，一共有四种实现的方式。</p><p>以左边宽度固定为 200px 为例:</p><ol><li>利用浮动，将左边元素宽度设置为 200px，并且设置向左浮动。将右边元素的 margin-left 设置为 200px，宽度设置为 auto（默认为 auto，撑满整个父元素）。</li><li>第二种是利用flex布局，将左边元素宽度设置为200px。将右边的元素的放大比例设置为1。</li><li>第三种是利用绝对定位布局的方式，将父级元素设置相对定位。左边元素设置为 absolute 定位，并且宽度设置为 200px。将右边元素的 margin-left 的值设置为 200px。</li><li>第四种还是利用绝对定位的方式，将父级元素设置为相对定位。左边元素宽度设置为 200px，右边元素设置为绝对定位，左边定位为 200px，其余方向定位为 0。</li></ol><h4 id="101-css-三栏布局的实现？"><a href="#101-css-三栏布局的实现？" class="headerlink" title="101.css 三栏布局的实现？"></a>101.css 三栏布局的实现？</h4><p>相关资料：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">这里以左边宽度固定为100px，右边宽度固定为200px为例。*/</span><br><br><span class="hljs-comment">/*（1）利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-comment">/*（2）利用flex布局的方式，左右两栏的宽度分别设置为100px和200px，中间一栏增长系数设置为1*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-comment">/*（3）利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。*/</span><br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-comment">/*（4）圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。*/</span><br><span class="hljs-selector-class">.outer</span>&#123;<br>  <span class="hljs-comment">/*  为左右栏腾出空间  */</span><br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">100px</span>;  <br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">200px</span>; <br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.center</span>&#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#bfa</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: orange;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-comment">/*（5）双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元</span><br><span class="hljs-comment">素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。*/</span><br><br><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="http://cavszhouyou.top/Demo-Display/ThreeColumnLayout/index.html">《三栏布局 demo 展示》</a></p><p><strong>回答：</strong></p><p>三栏布局一般指的是页面中一共有三栏，左右两栏宽度固定，中间自适应的布局，一共有五种实现方式。</p><p>这里以左边宽度固定为100px，右边宽度固定为200px为例:</p><ol><li>利用绝对定位的方式，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</li><li>利用flex布局的方式，左右两栏的宽度分别设置为100px和200px，中间一栏增长系数设置为1</li><li>利用浮动的方式，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式，中间一栏必须放到最后。</li><li>圣杯布局，利用浮动和负边距来实现。父级元素设置左右的padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置margin负值将其移动到上一行，再利用相对定位，定位到两边。圣杯布局中间列的宽度不能小于左边列的宽度，否则左边列上不去，而双飞翼布局则不存在这个问题。</li><li>双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的margin值来实现的，而不是通过父元素的padding来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</li></ol><h4 id="102-实现一个宽高自适应的正方形"><a href="#102-实现一个宽高自适应的正方形" class="headerlink" title="102.实现一个宽高自适应的正方形"></a>102.实现一个宽高自适应的正方形</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*1.第一种方式是利用vw来实现*/</span><br><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">10vw</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">10vw</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-comment">/*2.第二种方式是利用元素的margin/padding百分比是相对父元素width的性质来实现*/</span><br><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">20%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">20%</span>;<br>  <span class="hljs-attribute">background</span>: orange;<br>&#125;<br><br><span class="hljs-comment">/*3.第三种方式是利用子元素的margin-top的值来实现的*/</span><br><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">30%</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br><br><span class="hljs-selector-class">.square</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="http://cavszhouyou.top/Demo-Display/AdaptiveSquare/index.html">《自适应正方形 demo 展示》</a></p><h4 id="103-实现一个三角形"><a href="#103-实现一个三角形" class="headerlink" title="103.实现一个三角形"></a>103.实现一个三角形</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*三角形的实现原理是利用了元素边框连接处的等分原理。*/</span><br><span class="hljs-selector-class">.triangle</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">border-width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">border-style</span>: solid;<br>  <span class="hljs-attribute">border-color</span>: transparent transparent tomato;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="http://cavszhouyou.top/Demo-Display/Triangle/index.html">《三角形 demo 展示》</a></p><h4 id="104-一个自适应矩形，水平垂直居中，且宽高比为-2-1"><a href="#104-一个自适应矩形，水平垂直居中，且宽高比为-2-1" class="headerlink" title="104.一个自适应矩形，水平垂直居中，且宽高比为 2:1"></a>104.一个自适应矩形，水平垂直居中，且宽高比为 2:1</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*实现原理参考自适应正方形和水平居中方式*/</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: auto;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">20%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">10vw</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="105-你知道-CSS-中不同属性设置为百分比-时对应的计算基准？"><a href="#105-你知道-CSS-中不同属性设置为百分比-时对应的计算基准？" class="headerlink" title="105.你知道 CSS 中不同属性设置为百分比%时对应的计算基准？"></a>105.你知道 CSS 中不同属性设置为百分比%时对应的计算基准？</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino">公式：当前元素某CSS属性值 = 基准 * 对应的百分比<br>元素的 position 为 relative 和 absolute 时，top和bottom、left和right基准分别为包含块的 height、width<br>元素的 position 为 fixed 时，top和bottom、left和right基准分别为初始包含块（也就是视口）的 height、width，移动设备较为复杂，基准为 Layout viewport 的 height、width<br>元素的 height 和 width 设置为百分比时，基准分别为包含块的 height 和 width<br>元素的 margin 和 padding 设置为百分比时，基准为包含块的 width（易错）<br>元素的 border-width，不支持百分比<br>元素的 text-indent，基准为包含块的 width<br><br>元素的 border-radius，基准为分别为自身的height、width<br>元素的 background-size，基准为分别为自身的height、width<br>元素的 translateX、translateY，基准为分别为自身的height、width<br>元素的 line-height，基准为自身的 font-size<br><br>元素的 font-size，基准为父元素字体<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML总结</title>
    <link href="/2023/11/16/HTML%E6%80%BB%E7%BB%93/"/>
    <url>/2023/11/16/HTML%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="HTML-面试知识点总结"><a href="#HTML-面试知识点总结" class="headerlink" title="HTML 面试知识点总结"></a>HTML 面试知识点总结</h3><h4 id="1-DOCTYPE的作用是什么"><a href="#1-DOCTYPE的作用是什么" class="headerlink" title="1. DOCTYPE的作用是什么"></a>1. DOCTYPE的作用是什么</h4><p>相关知识点: </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的。<br><br>&lt;!DOCTYPE&gt;声明位于 HTML文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。<br><br>DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。<br></code></pre></td></tr></table></figure><p>回答(参考1-5)：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;!DOCTYPE&gt;  声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。<br><br>在 html5 之后不再需要指定 DTD 文档，因为 html5 以前的 html 文档都是基于 SGML 的，所以需要通过指定 DTD 来定义文档中允许的属性以及一些规则。而 html5 不再基于 SGML 了，所以不再需要使用 DTD。<br></code></pre></td></tr></table></figure><h4 id="2-标准模式与兼容模式有什么区别"><a href="#2-标准模式与兼容模式有什么区别" class="headerlink" title="2. 标准模式与兼容模式有什么区别?"></a>2. 标准模式与兼容模式有什么区别?</h4><p>&nbsp;&nbsp;标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</p><h4 id="3-HEML为什么只需写-，而无需引入DTD"><a href="#3-HEML为什么只需写-，而无需引入DTD" class="headerlink" title="3. HEML为什么只需写 ，而无需引入DTD"></a>3. HEML为什么只需写 <!DOCTYPE HTML>，而无需引入DTD</h4><p>&nbsp;&nbsp;HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行(让浏览器按照它们应该的方式来运行)。而 HTML4.01 基于 SGML ，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。</p><h4 id="4-SGML-、-HTML-、XML-和-XHTML-的区别？"><a href="#4-SGML-、-HTML-、XML-和-XHTML-的区别？" class="headerlink" title="4. SGML 、 HTML 、XML 和 XHTML 的区别？"></a>4. SGML 、 HTML 、XML 和 XHTML 的区别？</h4><p>&nbsp;&nbsp;SGML 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。<br>&nbsp;&nbsp;HTML 是超文本标记语言，主要是用于规定怎么显示网页。<br>&nbsp;&nbsp;XML 是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，而 HTML 的标签都是固定的而且数量有限。<br>&nbsp;&nbsp;XHTML 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML 更严格，比如标签必须都用小写，标签都必须有闭合标签等。</p><h4 id="5-DTD-介绍"><a href="#5-DTD-介绍" class="headerlink" title="5. DTD 介绍"></a>5. DTD 介绍</h4><p>&nbsp;&nbsp;DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML 或 HTML 的特定版本中所有允许元素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。<br>&nbsp;&nbsp;DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式(工作模式)。</p><h4 id="6-行内元素定义"><a href="#6-行内元素定义" class="headerlink" title="6. 行内元素定义"></a>6. 行内元素定义</h4><p>&nbsp;&nbsp;HTML4 中，元素被分成两大类: inline （内联元素）与 block（块级元素）。一个行内元素只占据它对应标签的边框所包含的空间。<br>&nbsp;&nbsp;常见的行内元素有 <strong>a b span img strong sub sup button input label select textarea</strong></p><h4 id="7-块级元素定义"><a href="#7-块级元素定义" class="headerlink" title="7. 块级元素定义"></a>7. 块级元素定义</h4><p>&nbsp;&nbsp;块级元素占据其父元素（容器）的整个宽度，因此创建了一个“块”。<br>&nbsp;&nbsp;常见的块级元素有<strong>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</strong></p><h4 id="8-行内元素与块级元素的区别？"><a href="#8-行内元素与块级元素的区别？" class="headerlink" title="8. 行内元素与块级元素的区别？"></a>8. 行内元素与块级元素的区别？</h4><p>HTML4中，元素被分成两大类：inline （内联元素）与 block （块级元素）。</p><ol><li>格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。</li><li>内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。</li><li>行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素不支持设置宽高；行内元素支持水平方向的padding、border、margin；</li><li>行内元素可以设置垂直方向的padding、border、margin，但是不会影响布局。</li></ol><h4 id="9-HTML5-元素的分类"><a href="#9-HTML5-元素的分类" class="headerlink" title="9. HTML5 元素的分类"></a>9. HTML5 元素的分类</h4><p>&nbsp;&nbsp;HTML4中，元素被分成两大类: inline（内联元素）与 block（块级元素）。但在实际的开发过程中，因为页面表现的需要，前端工程师经常把 inline 元素的 display 值设定为 block （比如 a 标签），也经常把 block 元素的display 值设定为inline 之后更是出现了 inline-block 这一对外呈现 inline 对内呈现 block 的属性。因此，简单地把 HTML 元素划分为inline 与 block 已经不再符合实际需求。</p><p>HTML5中，元素主要分为7类：Metadata Flow Sectioning Heading Phrasing Embedded Interactive。</p><ul><li>Metadata（元数据型）：位于head中，决定其他内容的样式或行为。包括：<code>&lt;meta&gt; &lt;link&gt; &lt;title&gt;</code>等</li><li>Flow（文档流型）：大部分文档body内的元素</li><li>Sectioning（区块型）：定义区块内容范围的元素</li><li>Heading（标题型）：定义节的标题。包括<code>&lt;hgroup&gt; &lt;h1&gt;-&lt;h6&gt;</code></li><li>Phrasing（语句型）: 包含许多HTML4中的inline层次的元素。包括<code>&lt;span&gt; &lt;img&gt; &lt;sub&gt; &lt;sup&gt;</code>等</li><li>Embedded（内嵌型）：将其他资源导入（嵌入）到文档中。 包括<code>&lt;audio&gt; &lt;video&gt; &lt;canvas&gt;</code>等</li><li>Interactive（交互型）：专门用来与用户交互。包括<code>&lt;input&gt; &lt;a&gt; &lt;select&gt;</code>等</li></ul><h4 id="10-空元素定义"><a href="#10-空元素定义" class="headerlink" title="10. 空元素定义"></a>10. 空元素定义</h4><p>标签内没有内容的 HTML 标签被称为空元素。空元素是在开始标签中关闭的。<br>常见的空元素有：<code>br hr img input link meta</code></p><h4 id="11-link-标签定义"><a href="#11-link-标签定义" class="headerlink" title="11. link 标签定义"></a>11. link 标签定义</h4><p>link 标签定义文档与外部资源的关系。<br>link 元素是空元素，它仅包含属性。 此元素只能存在于 head 部分，不过它可出现任何次数。<br>link 标签中的 rel 属性定义了当前文档与被链接文档之间的关系。常见的 stylesheet 指的是定义一个外部加载的样式表。</p><h4 id="12-页面导入样式时，使用-link-和-import-有什么区别？"><a href="#12-页面导入样式时，使用-link-和-import-有什么区别？" class="headerlink" title="12. 页面导入样式时，使用 link 和 @import 有什么区别？"></a>12. 页面导入样式时，使用 link 和 @import 有什么区别？</h4><ol><li>从属关系区别。 @import 是 CSS 提供的语法规则，只有导入样式表的作用；link 是 HTML 提供的标签，不仅可以加<br>载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。</li><li>加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。</li><li>兼容性区别。@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容<br>性问题。</li><li>DOM 可控性区别。可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用<br>@import 的方式插入样式。</li></ol><h4 id="13-你对浏览器的理解？"><a href="#13-你对浏览器的理解？" class="headerlink" title="13. 你对浏览器的理解？"></a>13. 你对浏览器的理解？</h4><ol><li>浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。</li><li>HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。</li><li>但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。</li><li>简单来说浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。内核才是浏览器的核心。内核是基于标记语言显示内容的程序或模块。也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。</li></ol><h4 id="14-介绍一下你对浏览器内核的理解？"><a href="#14-介绍一下你对浏览器内核的理解？" class="headerlink" title="14. 介绍一下你对浏览器内核的理解？"></a>14. 介绍一下你对浏览器内核的理解？</h4><p>&nbsp;&nbsp;主要分成两部分：渲染引擎和 JS引擎。</p><p><strong>渲染引擎</strong>: 渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。<br><strong>JS 引擎</strong>：解析和执行 javascript 来实现网页的动态效果。<br>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p><h4 id="15-常见的浏览器内核比较"><a href="#15-常见的浏览器内核比较" class="headerlink" title="15. 常见的浏览器内核比较"></a>15. 常见的浏览器内核比较</h4><ol><li><p>Trident：这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。</p></li><li><p>Gecko：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</p></li><li><p>Presto：Opera曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</p></li><li><p>Webkit：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。</p></li><li><p>Blink：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</p></li></ol><h4 id="16-常见浏览器所用内核"><a href="#16-常见浏览器所用内核" class="headerlink" title="16. 常见浏览器所用内核"></a>16. 常见浏览器所用内核</h4><ol><li><p>IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；</p></li><li><p>Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；</p></li><li><p>Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；</p></li><li><p>Safari 浏览器内核：Webkit 内核；</p></li><li><p>Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；</p></li><li><p>360浏览器、猎豹浏览器内核：IE + Chrome 双内核；</p></li><li><p>搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；</p></li><li><p>百度浏览器、世界之窗内核：IE 内核；</p></li><li><p>2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；</p></li><li><p>UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说<br>是基于火狐内核。</p></li></ol><h4 id="17-浏览器的渲染原理？"><a href="#17-浏览器的渲染原理？" class="headerlink" title="17. 浏览器的渲染原理？"></a>17. 浏览器的渲染原理？</h4><ol><li><p>首先解析收到的文档，根据文档定义构建一颗DOM树，DOM树是由DOM元素及属性节点组成的。</p></li><li><p>然后对CSS进行解析，生成CSSOM规则树。</p></li><li><p>根据 DOM树 和 CSSOM规则树 构建渲染树。渲染树的节点被称为渲染节点，渲染对象是一个包含颜色和大小等属性的矩形，渲染对象和 DOM元素 相对应，但这种对应关系不是一对一的，不可见的DOM元素不会被插入渲染树，还有一些DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</p></li><li><p>但渲染对象被创建并添加到DOM树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局(也可叫做回流)。这一阶段浏览器要做的事就是弄清楚各个节点在页面中的确切位置和大小。通常这一行为叫做”自动重排”。</p></li><li><p>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p></li><li><p>详细资料可以参考:</p><p> <a href="https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc7207f265da613c09425d">浏览器渲染原理</a><br> <a href="https://coolshell.cn/articles/9666.html">浏览器渲染原理简介</a><br> <a href="https://kb.cnblogs.com/page/129756">前端必读:浏览器内部工作原理</a><br> <a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering">深入浅出浏览器渲染原理</a></p></li></ol><h4 id="18-渲染过程中遇到-JS-文件怎么处理？（浏览器解析过程）"><a href="#18-渲染过程中遇到-JS-文件怎么处理？（浏览器解析过程）" class="headerlink" title="18. 渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）"></a>18. 渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）</h4><p>&ensp;&ensp;JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给script 标签添加 defer 或者 async 属性。</p><h4 id="19-async-和-defer-的作用是什么？有什么区别？（浏览器解析过程）"><a href="#19-async-和-defer-的作用是什么？有什么区别？（浏览器解析过程）" class="headerlink" title="19. async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）"></a>19. async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）</h4><ol><li><p>js脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</p></li><li><p>defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。</p></li><li><p>async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。</p></li></ol><p>&ensp;&ensp;资料: <a href="https://segmentfault.com/q/1010000000640869">《defer和async的区别》</a></p><h4 id="20-什么是文档的预解析？（浏览器解析过程）"><a href="#20-什么是文档的预解析？（浏览器解析过程）" class="headerlink" title="20. 什么是文档的预解析？（浏览器解析过程）"></a>20. 什么是文档的预解析？（浏览器解析过程）</h4><p>&ensp;&ensp;Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p><h4 id="21-CSS-如何阻塞文档解析？（浏览器解析过程）"><a href="#21-CSS-如何阻塞文档解析？（浏览器解析过程）" class="headerlink" title="21. CSS 如何阻塞文档解析？（浏览器解析过程）"></a>21. CSS 如何阻塞文档解析？（浏览器解析过程）</h4><p>&ensp;&ensp;理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们，然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。<br>&ensp;&ensp;所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。</p><h4 id="22-渲染页面时常见哪些不良现象？（浏览器渲染过程）"><a href="#22-渲染页面时常见哪些不良现象？（浏览器渲染过程）" class="headerlink" title="22. 渲染页面时常见哪些不良现象？（浏览器渲染过程）"></a>22. 渲染页面时常见哪些不良现象？（浏览器渲染过程）</h4><ul><li><p>FOUC：主要指的是样式闪烁的问题，由于浏览器渲染机制（比如firefox），在 CSS 加载之前，先呈现了 HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。会出现这个问题的原因主要是 css 加载时间过长，或者 css 被放在了文档底部。</p></li><li><p>白屏：有些浏览器渲染机制（比如chrome）要先构建 DOM 树和 CSSOM 树，构建完成后再进行渲染，如果 CSS 部分放在 HTML 尾部，由于 CSS 未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把 js 文件放在头部，脚本的加载会阻塞后面文档内容的解析，从而页面迟迟未渲染出来，出现白屏问题。</p></li></ul><p>&ensp;&ensp;资料:<br>&ensp;&ensp;<a href="https://juejin.im/entry/58f867045c497d0058e2ff3a">《前端魔法堂：解秘 FOUC》</a><br>&ensp;&ensp;<a href="https://www.jianshu.com/p/6617efa874b0">《白屏问题和 FOUC》</a></p><h4 id="23-如何优化关键渲染路径？（浏览器渲染过程）"><a href="#23-如何优化关键渲染路径？（浏览器渲染过程）" class="headerlink" title="23. 如何优化关键渲染路径？（浏览器渲染过程）"></a>23. 如何优化关键渲染路径？（浏览器渲染过程）</h4><p>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：<br>&ensp;&ensp;1. 关键资源的数量。<br>&ensp;&ensp;2. 关键路径长度。<br>&ensp;&ensp;3. 关键字节的数量。</p><p>&ensp;&ensp;关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。<br>&ensp;&ensp;最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p><p>优化关键渲染路径的常规步骤如下：<br>&ensp;&ensp;1. 对关键路径进行分析和特性描述：资源数、字节数、长度。<br>&ensp;&ensp;2. 最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。<br>&ensp;&ensp;3. 优化关键字节数以缩短下载时间（往返次数）。<br>&ensp;&ensp;4. 优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。</p><p>&ensp;&ensp;资料:<br>&ensp;&ensp;<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path?hl=zh-cn">《优化关键渲染路径》</a></p><h4 id="24-什么是重绘和重排（回流）？（浏览器绘制过程）"><a href="#24-什么是重绘和重排（回流）？（浏览器绘制过程）" class="headerlink" title="24. 什么是重绘和重排（回流）？（浏览器绘制过程）"></a>24. 什么是重绘和重排（回流）？（浏览器绘制过程）</h4><p>&ensp;&ensp;重绘: 当渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的操作，比如 background-color，我们将这样的操作称为重绘。</p><p>&ensp;&ensp;重排（回流）：当渲染树中的一部分（或全部）因为元素的规模尺寸、布局、隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称为回流。</p><p>&ensp;&ensp;常见引起回流属性和方法：<br>&ensp;&ensp;任何会改变元素几何信息（元素的位置和尺寸大小）的操作，都会触发回流。<br>&ensp;&ensp;&ensp;1. 添加或者删除可见的 DOM 元素；<br>&ensp;&ensp;&ensp;2. 元素尺寸改变——边距、填充、边框、宽度和高度<br>&ensp;&ensp;&ensp;3. 内容变化，比如用户在 input 框中输入文字<br>&ensp;&ensp;&ensp;4. 浏览器窗口尺寸改变——resize事件发生时<br>&ensp;&ensp;&ensp;5. 计算 offsetWidth 和 offsetHeight 属性<br>&ensp;&ensp;&ensp;6. 置 style 属性的值<br>&ensp;&ensp;&ensp;7. 当你修改网页的默认字体时。</p><p>&ensp;&ensp;回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p><h4 id="25-如何减少回流？（浏览器绘制过程）"><a href="#25-如何减少回流？（浏览器绘制过程）" class="headerlink" title="25. 如何减少回流？（浏览器绘制过程）"></a>25. 如何减少回流？（浏览器绘制过程）</h4><ol><li><p>使用 transform 替代 top</p></li><li><p>不要把节点的属性值放在一个循环里当成循环里的变量</p></li><li><p>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</p></li><li><p>把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM</p></li><li><p>不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。</p></li></ol><h4 id="26-为什么操作-DOM-慢？（浏览器绘制过程）"><a href="#26-为什么操作-DOM-慢？（浏览器绘制过程）" class="headerlink" title="26. 为什么操作 DOM 慢？（浏览器绘制过程）"></a>26. 为什么操作 DOM 慢？（浏览器绘制过程）</h4><p>&ensp;&ensp;一些 DOM 的操作或者属性访问可能会引起页面的回流和重绘，从而引起性能上的消耗。</p><h4 id="27-DOMContentLoaded-事件和-Load-事件的区别？"><a href="#27-DOMContentLoaded-事件和-Load-事件的区别？" class="headerlink" title="27. DOMContentLoaded 事件和 Load 事件的区别？"></a>27. DOMContentLoaded 事件和 Load 事件的区别？</h4><p>&ensp;&ensp;当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的加载完成。<br>&ensp;&ensp;Load 事件是当所有资源加载完成后触发的。</p><h4 id="28-HTML5-有哪些新特性、移除了那些元素？"><a href="#28-HTML5-有哪些新特性、移除了那些元素？" class="headerlink" title="28. HTML5 有哪些新特性、移除了那些元素？"></a>28. HTML5 有哪些新特性、移除了那些元素？</h4><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。<br>新增的有：</p><ul><li>画布： canvas;</li><li>音视频： video 和 audio 元素;\</li><li>web存储：本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;</li><li>sessionStorage 的数据在浏览器关闭后自动删除;</li><li>语义化更好的内容元素，比如 article、footer、header、main、nav、section;</li><li>表单控件，calendar、date、time、email、url、search;</li><li>新的技术 webworker, websocket;</li><li>新的文档属性 document.visibilityState</li></ul><p>移除的元素有：</p><ul><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li><li>对可用性产生负面影响的元素：frame，frameset，noframes；</li></ul><h4 id="29-简述一下你对-HTML-语义化的理解？"><a href="#29-简述一下你对-HTML-语义化的理解？" class="headerlink" title="29. 简述一下你对 HTML 语义化的理解？"></a>29. 简述一下你对 HTML 语义化的理解？</h4><ol><li><p>用正确的标签做正确的事情。</p></li><li><p>html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</p></li><li><p>即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;</p></li><li><p>搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO（搜索引擎优化）;</p></li><li><p>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p></li></ol><p>回答：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">我认为 <span class="hljs-selector-tag">html</span> 语义化主要指的是我们应该使用合适的标签来划分网页内容的结构。<span class="hljs-selector-tag">html</span> 的本质作用其实就是定义网页文档的结构，一个语义化的文档，能够使页面的结构更加清晰，易于理解。这样不仅有利于开发者的维护和理解，同时也能够使机器对文档内容进行正确的解读。比如说我们常用的 <span class="hljs-selector-tag">b</span> 标签和 <span class="hljs-selector-tag">strong</span> 标签，它们在样式上都是文字的加粗，但是 <span class="hljs-selector-tag">strong</span> 标签拥有强调的语义。<br>对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。如果用户使用的是屏幕阅读器来访问网页的话，使用 <span class="hljs-selector-tag">strong</span> 标签就会有明显的语调上的变化，而 <span class="hljs-selector-tag">b</span> 标签则没有。如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会依赖于 <span class="hljs-selector-tag">html</span> 标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的，从而有利于我们网站的 SEO 。从 html5 我们可以看出，标准是倾向于以语义化的方式来构建网页的，比如新增了 <span class="hljs-selector-tag">header</span> 、<span class="hljs-selector-tag">footer</span> 这些语义标签，删除了 big 、<span class="hljs-attribute">font</span> 这些没有语义的标签。<br></code></pre></td></tr></table></figure><h4 id="30-b-与-strong-的区别和-i-与-em-的区别？"><a href="#30-b-与-strong-的区别和-i-与-em-的区别？" class="headerlink" title="30. b 与 strong 的区别和 i 与 em 的区别？"></a>30. b 与 strong 的区别和 i 与 em 的区别？</h4><p>&ensp;&ensp;从页面显示效果来看，被 <code>&lt;b&gt;</code> 和 <code>&lt;strong&gt;</code> 包围的文字将会被加粗，而被 <code>&lt;i&gt;</code> 和 <code>&lt;em&gt;</code> 包围的文字将以斜体的形式呈现。但是 <code>&lt;b&gt; &lt;i&gt;</code> 是自然样式标签，分别表示无意义的加粗，无意义的斜体，表现样式为 { font-weight: bolder}，仅仅表示「这里应该用粗体显示」或者「这里应该用斜体显示」，此两个标签在 HTML4.01 中并不被推荐使用。而 <code>&lt;em&gt;</code> 和 <code>&lt;strong&gt;</code> 是语义样式标签。 <code>&lt;em&gt;</code> 表示一般的强调文本，而 <code>&lt;strong&gt;</code> 表示比 <code>&lt;em&gt;</code> 语义更强的强调文本。使用阅读设备阅读网页时：<code>&lt;strong&gt;</code> 会重读，而 <code>&lt;b&gt;</code> 是展示强调内容。</p><h4 id="31-前端需要注意哪些-SEO-？"><a href="#31-前端需要注意哪些-SEO-？" class="headerlink" title="31. 前端需要注意哪些 SEO ？"></a>31. 前端需要注意哪些 SEO ？</h4><ol><li><p>合理的 title、description、keywords：搜索对这三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可。</p></li><li><p>语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。</p></li><li><p>重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被抓取。</p></li><li><p>重要内容不要用 js 输出：爬虫不会执行 js 获取内容</p></li><li><p>少用 iframe：搜索引擎不会抓取 iframe 中的内容</p></li><li><p>非装饰性图片必须加 alt</p></li><li><p>提高网站速度：网站速度是搜索引擎排序的一个重要指标</p></li></ol><h4 id="32-HTML5-的离线储存怎么使用，工作原理能不能解释一下？"><a href="#32-HTML5-的离线储存怎么使用，工作原理能不能解释一下？" class="headerlink" title="32. HTML5 的离线储存怎么使用，工作原理能不能解释一下？"></a>32. HTML5 的离线储存怎么使用，工作原理能不能解释一下？</h4><p>&ensp;&ensp;在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。<br>&ensp;&ensp;原理：HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制（不是存储技术），通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p><p>如何使用：</p><ul><li><p>创建一个和 html 同名的 manifest 文件，然后在页面头部像下面一样加入一个 manifest 的属性。<html lang="en" manifest="index.manifest"></p></li><li><p>在如下 cache.manifest 文件的编写离线存储的资源。</p></li></ul><ol><li>CACHE: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li><li>NETWORK: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 C<br> ACHE 的优先级更高。</li><li>FALLBACK: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</li></ol><ul><li>在离线状态时，操作 window.applicationCache 进行离线缓存的操作。<br> 如何更新缓存：</li></ul><ol><li>更新 manifest 文件</li><li>通过 javascript 操作</li><li>清除浏览器缓存</li></ol><p> 注意事项：</p><ol><li>浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</li><li>如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。</li><li>引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。</li><li>FALLBACK 中的资源必须和 manifest 文件同源。</li><li>当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</li><li>站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</li><li>当 manifest 文件发生改变时，资源请求本身也会触发更新。</li></ol><h4 id="33-浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的呢？"><a href="#33-浏览器是怎么对-HTML5-的离线储存资源进行管理和加载的呢？" class="headerlink" title="33. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？"></a>33. 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢？</h4><p>&ensp;&ensp;在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。<br>&ensp;&ensp;离线的情况下，浏览器就直接使用离线存储的资源。</p><h4 id="34-常见的浏览器端的存储技术有哪些？"><a href="#34-常见的浏览器端的存储技术有哪些？" class="headerlink" title="34. 常见的浏览器端的存储技术有哪些？"></a>34. 常见的浏览器端的存储技术有哪些？</h4><ul><li>浏览器常见的存储技术有 cookie、localStorage 和 sessionStorage。</li><li>还有两种存储技术用于大规模数据存储，webSQL（已被废除）和 indexDB。</li><li>IE 支持 userData 存储数据，但是基本很少使用到，除非有很强的浏览器兼容需求。</li></ul><h4 id="35-请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#35-请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="35. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>35. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h4><p>&ensp;&ensp;SessionStorage， LocalStorage， Cookie 这三者都可以被用来在浏览器端存储数据，而且都是字符串类型的键值对。区别在于前两者属于 HTML5 WebStorage，创建它们的目的便于客户端存储数据。而 cookie 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密）。cookie 数据始终在同源（协议、主机、端口相同）的 http 请求中携带（即使不需要），会在浏览器和服务器间来回传递。</p><p>存储大小：</p><ul><li>cookie 数据大小不能超过4 k 。</li><li>sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</li></ul><p>有期时间：</p><ul><li>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。</li><li>sessionStorage 数据在页面会话结束时会被清除。页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会<br>保持原来的页面会话。在新标签或窗口打开一个页面时会在顶级浏览上下文中初始化一个新的会话。</li><li>cookie 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</li></ul><p>作用域：</p><ul><li>sessionStorage 只在同源的同窗口（或标签页）中共享数据，也就是只在当前会话中共享。</li><li>localStorage 在所有同源窗口中都是共享的。</li><li>cookie 在所有同源窗口中都是共享的。</li></ul><p>回答：</p><ul><li>浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。</li><li>cookie 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</li><li>sessionStorage 是 html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。</li><li>localStorage 也是 html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</li></ul><p>上面几种方式都是存储少量数据的时候的存储方式，当我们需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。</p><p>详细的资料可以参考：<br><a href="https://segmentfault.com/a/1190000017423117">请描述一下 cookies，sessionStorage 和 localStorage 的区别？</a><br><a href="http://www.ruanyifeng.com/blog/2018/07/indexeddb.html">浏览器数据库 IndexedDB 入门教程</a></p><h4 id="36-iframe-有那些缺点？"><a href="#36-iframe-有那些缺点？" class="headerlink" title="36. iframe 有那些缺点？"></a>36. iframe 有那些缺点？</h4><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。<br>主要缺点有：</p><ol><li>iframe 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 src 可以避免这种阻塞情况。</li><li>搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。</li><li>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li><li>浏览器的后退按钮失效。</li><li>小型的移动设备无法完全显示框架。</li></ol><p>详细的资料可以参考：<br><a href="https://blog.csdn.net/yintianqin/article/details/72625785">使用 iframe 的优缺点</a><br><a href="https://segmentfault.com/a/1190000009891683">iframe 简单探索以及 iframe 跨域处理</a></p><h4 id="37-Label-的作用是什么？是怎么用的？"><a href="#37-Label-的作用是什么？是怎么用的？" class="headerlink" title="37. Label 的作用是什么？是怎么用的？"></a>37. Label 的作用是什么？是怎么用的？</h4><p>label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。<br><code>&lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt;</code><br><code>&lt;input type=“text“ name=&quot;Name&quot; id=&quot;Name&quot;/&gt;</code></p><h4 id="38-HTML5-的-form-的自动完成功能是什么？"><a href="#38-HTML5-的-form-的自动完成功能是什么？" class="headerlink" title="38. HTML5 的 form 的自动完成功能是什么？"></a>38. HTML5 的 form 的自动完成功能是什么？</h4><p>&ensp;&ensp;autocomplete 属性规定输入字段是否应该启用自动完成功能。默认为启用，设置为 autocomplete&#x3D;off 可以关闭该功能。<br>&ensp;&ensp;自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。<br>&ensp;&ensp;autocomplete 属性适用于 <code>&lt;form&gt;</code>，以及下面的 <code>&lt;input&gt;</code> 类型：text, search, url, telephone, email, password, datepickers, range 以及 color。</p><h4 id="39-如何实现浏览器内多个标签页之间的通信"><a href="#39-如何实现浏览器内多个标签页之间的通信" class="headerlink" title="39. 如何实现浏览器内多个标签页之间的通信?"></a>39. 如何实现浏览器内多个标签页之间的通信?</h4><p>相关资料：</p><ol><li>使用 WebSocket，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端。</li><li>使用 SharedWorker （只在 chrome 浏览器实现了），两个页面共享同一个线程，通过向线程发送数据和接收数据来实现标签页之间的双向通行。</li><li>可以调用 localStorage、cookies 等本地存储方式，localStorge 另一个浏览上下文里被添加、修改或删除时，它都会触发一个 storage 事件，我们通过监听 storage 事件，控制它的值来进行页面信息通信；</li><li>如果我们能够获得对应标签页的引用，通过 postMessage 方法也是可以实现多个标签页通信的。</li></ol><p>回答：<br>&ensp;&ensp;实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。<br>&ensp;&ensp;第一种实现的方式是使用 websocket 协议，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。<br>&ensp;&ensp;第二种是使用 SharedWorker 的方式，sharedWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。<br>&ensp;&ensp;第三种方式是使用 localStorage 的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。<br>&ensp;&ensp;还有一种方式是使用 postMessage 方法，如果我们能够获得对应标签页的引用，我们就可以使用 postMessage 方法，进行通信。</p><p>详细的资料可以参考：</p><p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 教程</a><br><a href="https://www.cnblogs.com/chyingp/p/websocket-deep-in.html">WebSocket 协议：5分钟从入门到精通</a><br><a href="https://segmentfault.com/a/1190000011538416">WebSocket 学习（一）——基于 socket.io 实现简单多人聊天室</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API">使用 Web Storage API</a><br><a href="https://www.zhuwenlong.com/blog/article/590ea64fe55f0f385f9a12e5">JavaScript 的多线程，Worker 和 SharedWorker</a><br><a href="https://juejin.im/post/5acdba01f265da23826e5633#heading-1">实现多个标签页之间通信的几种方法</a></p><h4 id="40-webSocket-如何兼容低版本浏览器？"><a href="#40-webSocket-如何兼容低版本浏览器？" class="headerlink" title="40. webSocket 如何兼容低版本浏览器？"></a>40. webSocket 如何兼容低版本浏览器？</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">Adobe Flash Socket 、<br>ActiveX HTMLFile <span class="hljs-comment">(IE)</span> 、<br>基于 multipart 编码发送 XHR 、<br>基于长轮询的 XHR<br></code></pre></td></tr></table></figure><h4 id="41-页面可见性（Page-Visibility-API）-可以有哪些用途？"><a href="#41-页面可见性（Page-Visibility-API）-可以有哪些用途？" class="headerlink" title="41. 页面可见性（Page Visibility API） 可以有哪些用途？"></a>41. 页面可见性（Page Visibility API） 可以有哪些用途？</h4><p>&ensp;&ensp;这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户不看网页，下面这些网页行为都是可以暂停的。</p><ol><li>对服务器的轮询</li><li>网页动画</li><li>正在播放的音频或视频</li></ol><p>详细资料可以参考：<br><a href="http://www.ruanyifeng.com/blog/2018/10/page_visibility_api.html">Page Visibility API 教程</a></p><h4 id="42-如何在页面上实现一个圆形的可点击区域？"><a href="#42-如何在页面上实现一个圆形的可点击区域？" class="headerlink" title="42. 如何在页面上实现一个圆形的可点击区域？"></a>42. 如何在页面上实现一个圆形的可点击区域？</h4><ol><li><p>纯 html 实现，使用 <code>&lt;area&gt;</code> 来给 <code>&lt;img&gt;</code> 图像标记热点区域的方式，<code>&lt;map&gt;</code> 标签用来定义一个客户端图像映射，<code>&lt;area&gt;</code> 标签用来定义图像映射中的区域，area 元素永远嵌套在 map 元素内部，我们可以将 area 区域设置为圆形，从而实现可点击的圆形区域。</p></li><li><p>纯 css 实现，使用 border-radius ，当 border-radius 的长度等于宽高相等的元素值的一半时，即可实现一个圆形的点击区域。</p></li><li><p>纯 js 实现，判断一个点在不在圆上的简单算法，通过监听文档的点击事件，获取每次点击时鼠标的位置，判断该位置是否在我们规定的圆形区域内。</p></li></ol><p>详细资料可以参考：<br><a href="https://maizi93.github.io/2017/08/29/%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9C%86%E5%BD%A2%E7%9A%84%E5%8F%AF%E7%82%B9%E5%87%BB%E5%8C%BA%E5%9F%9F%EF%BC%9F/">如何在页面上实现一个圆形的可点击区域？</a><br><a href="https://www.zhangxinxu.com/wordpress/2017/05/html-area-map/">HTML <area><map> 标签及在实际开发中的应用</a></p><h4 id="43-实现不使用-border-画出-1-px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"><a href="#43-实现不使用-border-画出-1-px-高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。" class="headerlink" title="43. 实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"></a>43. 实现不使用 border 画出 1 px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;height:1px;overflow:hidden;background:red&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="44-title-与-h1-的区别？"><a href="#44-title-与-h1-的区别？" class="headerlink" title="44. title 与 h1 的区别？"></a>44. title 与 h1 的区别？</h4><p>&ensp;&ensp;title 属性没有明确意义只表示是个标题，h1 则表示层次明确的标题，对页面信息的抓取也有很大的影响。</p><h4 id="45-的-title-和-alt-有什么区别？"><a href="#45-的-title-和-alt-有什么区别？" class="headerlink" title="45. &lt;img&gt; 的 title 和 alt 有什么区别？"></a>45. <code>&lt;img&gt;</code> 的 title 和 alt 有什么区别？</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">title 通常当鼠标滑动到元素上的时候显示<br>alt 是 <span class="hljs-tag">&lt;<span class="hljs-name">img</span>&gt;</span> 的特有属性，是图片内容的等价描述，用于图片无法加载时显示（图片无法加载时显示文字）、读屏器阅读图片。可提高图片可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。<br></code></pre></td></tr></table></figure><h4 id="46-Canvas-和-SVG-有什么区别？"><a href="#46-Canvas-和-SVG-有什么区别？" class="headerlink" title="46. Canvas 和 SVG 有什么区别？"></a>46. Canvas 和 SVG 有什么区别？</h4><p>&ensp;&ensp;Canvas 是一种通过 JavaScript 来绘制 2D 图形的方法。Canvas 是逐像素来进行渲染的，因此当我们对 Canvas 进行缩放时，会出现锯齿或者失真的情况。<br>&ensp;&ensp;SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。我们可以为某个元素附加 JavaScript 事件监听函数。并且 SVG 保存的是图形的绘制方法，因此当 SVG 图形缩放时并不会失真。</p><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/19690014">SVG 与 HTML5 的 canvas 各有什么优点，哪个更有前途？</a></p><h4 id="47-网页验证码是干嘛的，是为了解决什么安全问题？"><a href="#47-网页验证码是干嘛的，是为了解决什么安全问题？" class="headerlink" title="47. 网页验证码是干嘛的，是为了解决什么安全问题？"></a>47. 网页验证码是干嘛的，是为了解决什么安全问题？</h4><ol><li><p>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</p></li><li><p>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</p></li></ol><h4 id="48-渐进增强和优雅降级的定义"><a href="#48-渐进增强和优雅降级的定义" class="headerlink" title="48. 渐进增强和优雅降级的定义"></a>48. 渐进增强和优雅降级的定义</h4><ul><li>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li><li>优雅降级：一开始就根据高版本浏览器构建完整的功能，然后再针对低版本浏览器进行兼容。</li></ul><h4 id="49-attribute-和-property-的区别是什么？"><a href="#49-attribute-和-property-的区别是什么？" class="headerlink" title="49. attribute 和 property 的区别是什么？"></a>49. attribute 和 property 的区别是什么？</h4><ul><li>attribute 是 dom 元素在文档中作为 html 标签拥有的属性；</li><li>property 就是 dom 元素在 js 中作为对象拥有的属性。</li><li>对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的，但是对于自定义的属性来说，他们是不同步的。</li></ul><h4 id="50-对-web-标准可用性、可访问性、可维护性的理解"><a href="#50-对-web-标准可用性、可访问性、可维护性的理解" class="headerlink" title="50. 对 web 标准可用性、可访问性、可维护性的理解"></a>50. 对 web 标准可用性、可访问性、可维护性的理解</h4><p>&ensp;&ensp;可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力</p><p>可访问性（Accessibility）：Web 内容对于残障用户的可阅读和可理解性<br>可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。<br>二是代码是否容易被人理解，是否容易修改和增强功能。</p><h4 id="51-IE-各版本和-Chrome-可以并行下载多少个资源？"><a href="#51-IE-各版本和-Chrome-可以并行下载多少个资源？" class="headerlink" title="51. IE 各版本和 Chrome 可以并行下载多少个资源？"></a>51. IE 各版本和 Chrome 可以并行下载多少个资源？</h4><ol><li>IE6 2 个并发</li><li>iE7 升级之后的 6 个并发，之后版本也是 6 个</li><li>Firefox，chrome 也是6个</li></ol><h4 id="52-Flash、Ajax-各自的优缺点，在使用中如何取舍？"><a href="#52-Flash、Ajax-各自的优缺点，在使用中如何取舍？" class="headerlink" title="52. Flash、Ajax 各自的优缺点，在使用中如何取舍？"></a>52. Flash、Ajax 各自的优缺点，在使用中如何取舍？</h4><p>Flash：</p><ol><li>Flash 适合处理多媒体、矢量图形、访问机器</li><li>对 CSS、处理文本上不足，不容易被搜索</li></ol><p>Ajax：</p><ol><li>Ajax 对 CSS、文本支持很好，支持搜索</li><li>媒体、矢量图形、机器访问不足</li></ol><p>共同点：</p><ol><li>与服务器的无刷新传递消息</li><li>可以检测用户离线和在线状态</li><li>操作 DOM</li></ol><h4 id="53-怎么重构页面？"><a href="#53-怎么重构页面？" class="headerlink" title="53. 怎么重构页面？"></a>53. 怎么重构页面？</h4><ol><li>编写 CSS</li><li>让页面结构更合理化，提升用户体验</li><li>实现良好的页面效果和提升性能</li></ol><h4 id="54-浏览器架构"><a href="#54-浏览器架构" class="headerlink" title="54. 浏览器架构"></a>54. 浏览器架构</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 用户界面<br><span class="hljs-bullet">      *</span> 主进程<br><span class="hljs-bullet">      *</span> 内核<br><span class="hljs-bullet">          *</span> 渲染引擎<br><span class="hljs-bullet">          *</span> JS 引擎<br><span class="hljs-bullet">              *</span> 执行栈<br><span class="hljs-bullet">          *</span> 事件触发线程<br><span class="hljs-bullet">              *</span> 消息队列<br><span class="hljs-bullet">                  *</span> 微任务<br><span class="hljs-bullet">                  *</span> 宏任务<br><span class="hljs-bullet">          *</span> 网络异步线程<br><span class="hljs-bullet">          *</span> 定时器线程<br></code></pre></td></tr></table></figure><h4 id="55-常用的-meta-标签"><a href="#55-常用的-meta-标签" class="headerlink" title="55. 常用的 meta 标签"></a>55. 常用的 meta 标签</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta&gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。<br>&lt;meta&gt; 标签位于文档的头部，不包含任何内容。&lt;meta&gt; 标签的属性定义了与文档相关联的名称/值对。<br>&lt;!DOCTYPE html&gt;  H5标准声明，使用 HTML5 doctype，不区分大小写<br>&lt;head <span class="hljs-attribute">lang</span>=”en”&gt; 标准的 lang 属性写法<br>&lt;meta <span class="hljs-attribute">charset</span>=’utf-8′&gt;    声明文档使用的字符编码<br>&lt;meta <span class="hljs-attribute">http-equiv</span>=”X-UA-Compatible” <span class="hljs-attribute">content</span>=”IE=edge,chrome=1″/&gt;   优先使用 IE 最新版本和 Chrome<br>&lt;meta <span class="hljs-attribute">name</span>=”description” <span class="hljs-attribute">content</span>=”不超过150个字符”/&gt;       页面描述<br>&lt;meta <span class="hljs-attribute">name</span>=”keywords” <span class="hljs-attribute">content</span>=””/&gt;      页面关键词者<br>&lt;meta <span class="hljs-attribute">name</span>=”author” <span class="hljs-attribute">content</span>=”name, email@gmail.com”/&gt;    网页作<br>&lt;meta <span class="hljs-attribute">name</span>=”robots” <span class="hljs-attribute">content</span>=”index,follow”/&gt;      搜索引擎抓取<br>&lt;meta <span class="hljs-attribute">name</span>=”viewport” <span class="hljs-attribute">content</span>=”initial-scale=1, <span class="hljs-attribute">maximum-scale</span>=3, <span class="hljs-attribute">minimum-scale</span>=1, <span class="hljs-attribute">user-scalable</span>=<span class="hljs-literal">no</span>”&gt; 为移动设备添加 viewport<br>&lt;meta <span class="hljs-attribute">name</span>=”apple-mobile-web-app-title” <span class="hljs-attribute">content</span>=”标题”&gt; iOS 设备 begin<br>&lt;meta <span class="hljs-attribute">name</span>=”apple-mobile-web-app-capable” <span class="hljs-attribute">content</span>=”yes”/&gt;  添加到主屏后的标题（iOS 6 新增）<br>是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏<br>&lt;meta <span class="hljs-attribute">name</span>=”apple-itunes-app” <span class="hljs-attribute">content</span>=”app-id=myAppStoreID, <span class="hljs-attribute">affiliate-data</span>=myAffiliateData, <span class="hljs-attribute">app-argument</span>=myURL”&gt;<br>添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）<br>&lt;meta <span class="hljs-attribute">name</span>=”apple-mobile-web-app-status-bar-style” <span class="hljs-attribute">content</span>=”black”/&gt;<br>&lt;meta <span class="hljs-attribute">name</span>=”format-detection” <span class="hljs-attribute">content</span>=”telphone=no, <span class="hljs-attribute">email</span>=<span class="hljs-literal">no</span>”/&gt;  设置苹果工具栏颜色<br>&lt;meta <span class="hljs-attribute">name</span>=”renderer” <span class="hljs-attribute">content</span>=”webkit”&gt;  启用360浏览器的极速模式(webkit)<br>&lt;meta <span class="hljs-attribute">http-equiv</span>=”X-UA-Compatible” <span class="hljs-attribute">content</span>=”IE=edge”&gt;     避免IE使用兼容模式<br>&lt;meta <span class="hljs-attribute">http-equiv</span>=”Cache-Control” <span class="hljs-attribute">content</span>=”no-siteapp” /&gt;    不让百度转码<br>&lt;meta <span class="hljs-attribute">name</span>=”HandheldFriendly” <span class="hljs-attribute">content</span>=”true”&gt;     针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓<br>&lt;meta <span class="hljs-attribute">name</span>=”MobileOptimized” <span class="hljs-attribute">content</span>=”320″&gt;   微软的老式浏览器<br>&lt;meta <span class="hljs-attribute">name</span>=”screen-orientation” <span class="hljs-attribute">content</span>=”portrait”&gt;   uc强制竖屏<br>&lt;meta <span class="hljs-attribute">name</span>=”x5-orientation” <span class="hljs-attribute">content</span>=”portrait”&gt;    QQ强制竖屏<br>&lt;meta <span class="hljs-attribute">name</span>=”full-screen” <span class="hljs-attribute">content</span>=”yes”&gt;              UC强制全屏<br>&lt;meta <span class="hljs-attribute">name</span>=”x5-fullscreen” <span class="hljs-attribute">content</span>=”true”&gt;       QQ强制全屏<br>&lt;meta <span class="hljs-attribute">name</span>=”browsermode” <span class="hljs-attribute">content</span>=”application”&gt;   UC应用模式<br>&lt;meta <span class="hljs-attribute">name</span>=”x5-page-mode” <span class="hljs-attribute">content</span>=”app”&gt;    QQ应用模式<br>&lt;meta <span class="hljs-attribute">name</span>=”msapplication-tap-highlight” <span class="hljs-attribute">content</span>=”no”&gt;    windows phone 点击无高光<br>设置页面不缓存<br>&lt;meta <span class="hljs-attribute">http-equiv</span>=”pragma” <span class="hljs-attribute">content</span>=”no-cache”&gt;<br>&lt;meta <span class="hljs-attribute">http-equiv</span>=”cache-control” <span class="hljs-attribute">content</span>=”no-cache”&gt;<br>&lt;meta <span class="hljs-attribute">http-equiv</span>=”expires” <span class="hljs-attribute">content</span>=”0″&gt;<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="http://www.cnblogs.com/qiumohanyu/p/5431859.html">Meta 标签用法大全</a></p><h4 id="56-css-reset-和-normalize-css-有什么区别？"><a href="#56-css-reset-和-normalize-css-有什么区别？" class="headerlink" title="56. css reset 和 normalize.css 有什么区别？"></a>56. css reset 和 normalize.css 有什么区别？</h4><p>相关知识点：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs stylus">为什么会有 CSS Reset 的存在呢？那是因为早期的浏览器支持和理解的 CSS 规范不同，导致渲染页面时效果不一致，会出现很多<br>兼容性问题。<br><br>reset 的目的，是将所有的浏览器的自带样式重置掉，这样更易于保持各浏览器渲染的一致性。<br><br>normalize 的理念则是尽量保留浏览器的默认样式，不进行太多的重置，而尽力让这些样式保持一致并尽可能与现代标准相符合。<br><br><span class="hljs-number">1</span><span class="hljs-selector-class">.Normalize</span><span class="hljs-selector-class">.css</span> 保护了有价值的默认值<br><br>Reset 通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。 相比之下，Normalize<span class="hljs-selector-class">.css</span> 保持了许多默认的浏<br>览器样式。 这就意味着你不用再为所有公共的排版元素重新设置样式。 当一个元素在不同的浏览器中有不同的默认值时，Normali<br>ze<span class="hljs-selector-class">.css</span> 会力求让这些样式保持一致并尽可能与现代标准相符合。<br><br><span class="hljs-number">2</span><span class="hljs-selector-class">.Normalize</span><span class="hljs-selector-class">.css</span> 修复了浏览器的 bug<br><br>它修复了常见的桌面端和移动端浏览器的 bug。这往往超出了 Reset 所能做到的范畴。关于这一点，Normalize<span class="hljs-selector-class">.css</span> 修复的问题<br>包含了 HTML5 元素的显示设置、预格式化文字的 <span class="hljs-attribute">font-size</span> 问题、在 IE9 中 SVG 的溢出、许多出现在各浏览器和操作系统中<br>的与表单相关的 bug。<br><br><span class="hljs-number">3</span><span class="hljs-selector-class">.Normalize</span><span class="hljs-selector-class">.css</span> 没有复杂的继承链<br><br>使用 Reset 最让人困扰的地方莫过于在浏览器调试工具中大段大段的继承链。在 Normalize<span class="hljs-selector-class">.css</span> 中就不会有这样的问题，因为在<br>我们的准则中对多选择器的使用是非常谨慎的，我们仅会有目的地对目标元素设置样式。<br><br><span class="hljs-number">4</span><span class="hljs-selector-class">.Normalize</span><span class="hljs-selector-class">.css</span> 是模块化的<br><br>这个项目已经被拆分为多个相关却又独立的部分，这使得你能够很容易也很清楚地知道哪些元素被设置了特定的值。因此这能让你自己<br>选择性地移除掉某些永远不会用到部分（比如表单的一般化）。<br><br><span class="hljs-number">5</span><span class="hljs-selector-class">.Normalize</span><span class="hljs-selector-class">.css</span> 拥有详细的文档<br><br>Normalize<span class="hljs-selector-class">.css</span> 的代码基于详细而全面的跨浏览器研究与测试。这个文件中拥有详细的代码说明并在 Github Wiki 中有进一步的<br>说明。这意味着你可以找到每一行代码具体完成了什么工作、为什么要写这句代码、浏览器之间的差异，并且你可以更容易地进行自己<br>的测试。<br></code></pre></td></tr></table></figure><p>回答：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">css reset 是最早的一种解决浏览器间样式不兼容问题的方案，它的基本思想是将浏览器的所有样式都重置掉，从而达到所有浏览器<br>样式保持一致的效果。但是使用这种方法，可能会带来一些性能上的问题，并且对于一些元素的不必要的样式的重置，其实反而会造成<br>画蛇添足的效果。<br><br>后面出现一种更好的解决浏览器间样式不兼容的方法，就是 <span class="hljs-keyword">normalize.css </span>，它的思想是尽量的保留浏览器自带的样式，通过在原<br>有的样式的基础上进行调整，来保持各个浏览器间的样式表现一致。相对与 css reset，<span class="hljs-keyword">normalize.css </span>的方法保留了有价值的默<br>认值，并且修复了一些浏览器的 <span class="hljs-keyword">bug，而且使用 </span><span class="hljs-keyword">normalize.css </span>不会造成元素复杂的继承链。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://segmentfault.com/a/1190000003021766#articleHeader0">关于CSS Reset 那些事（一）之 历史演变与 Normalize.css</a><br><a href="https://segmentfault.com/q/1010000000117189">Normalize.css 和 Reset CSS 有什么本质区别没？</a></p><h4 id="57-用于预格式化文本的标签是？"><a href="#57-用于预格式化文本的标签是？" class="headerlink" title="57. 用于预格式化文本的标签是？"></a>57. 用于预格式化文本的标签是？</h4><p>&ensp;&ensp;预格式化就是保留文字在源码中的格式 最后显示出来样式与源码中的样式一致 所见即所得。<br>&ensp;&ensp;<code>&lt;pre&gt;</code> 定义预格式文本，保持文本原有的格式</p><h4 id="58-DHTML-是什么？"><a href="#58-DHTML-是什么？" class="headerlink" title="58. DHTML 是什么？"></a>58. DHTML 是什么？</h4><p>&ensp;&ensp;DHTML 将 HTML、JavaScript、DOM 以及 CSS 组合在一起，用于创造动态性更强的网页。通过 JavaScript 和 HTML DOM，能够动态地改变 HTML 元素的样式。</p><p>&ensp;&ensp;DHTML 实现了网页从 Web 服务器下载后无需再经过服务器的处理，而在浏览器中直接动态地更新网页的内容、排版样式和动画的功能。例如，当鼠标指针移到文章段落中时，段落能够变成蓝色，或者当鼠标指针移到一个超级链接上时，会自动生成一个下拉式子链接目录等。</p><p>包括：</p><ol><li>动态内容（Dynamic Content）：动态地更新网页内容，可“动态”地插入、修改或删除网页的元件，如文字、图像、标记等。</li><li>动态排版样式（Dynamic Style Sheets）：W3C 的 CSS 样式表提供了设定 HTML 标记的字体大小、字形、样式、粗细、文字颜色、行高度、加底线或加中间横线、缩排、与边缘距离、靠左右或置中、背景图片或颜色等排版功能，而“动态排版样式”即可以“动态”地改变排版样式。</li></ol><h4 id="59-head-标签中必不少的是？"><a href="#59-head-标签中必不少的是？" class="headerlink" title="59. head 标签中必不少的是？"></a>59. head 标签中必不少的是？</h4><p>&ensp;&ensp;<code>&lt;head&gt;</code> 标签用于定义文档的头部，它是所有头部元素的容器。<code>&lt;head&gt;</code> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。<br>&ensp;&ensp;文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。<br>&ensp;&ensp;下面这些标签可用在 head 部分：<code>&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;</code>, 以及 <code>&lt;title&gt;。&lt;title&gt;</code> 定义文档的标题，它是 head 部分中唯一必需的元素。</p><h4 id="60-HTML5-新增的表单元素有？"><a href="#60-HTML5-新增的表单元素有？" class="headerlink" title="60. HTML5 新增的表单元素有？"></a>60. HTML5 新增的表单元素有？</h4><p>&ensp;&ensp;datalist 规定输入域的选项列表，通过 option 创建！<br>&ensp;&ensp; keygen 提供一种验证用户的可靠方法，密钥对生成器，私钥存于客户端，公钥发到服务器，用于之后验证客户端证书！<br>&ensp;&ensp; output 元素用于不同类型的输出！</p><h4 id="61-在-HTML5-中，哪个方法用于获得用户的当前位置？"><a href="#61-在-HTML5-中，哪个方法用于获得用户的当前位置？" class="headerlink" title="61. 在 HTML5 中，哪个方法用于获得用户的当前位置？"></a>61. 在 HTML5 中，哪个方法用于获得用户的当前位置？</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">getCurrentPosition</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><h4 id="62-文档的不同注释方式？"><a href="#62-文档的不同注释方式？" class="headerlink" title="62. 文档的不同注释方式？"></a>62. 文档的不同注释方式？</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">HTML 的注释方法 <span class="hljs-comment">&lt;!--注释内容--&gt;</span> <br>  <br>CSS 的注释方法 /*注释内容*/ <br>  <br>JavaScript 的注释方法 /* 多行注释方式 */ //单行注释方式<br></code></pre></td></tr></table></figure><h4 id="63-disabled-和-readonly-的区别？"><a href="#63-disabled-和-readonly-的区别？" class="headerlink" title="63. disabled 和 readonly 的区别？"></a>63. disabled 和 readonly 的区别？</h4><p>&ensp;&ensp;disabled 指当 input 元素加载时禁用此元素。input 内容不会随着表单提交。<br>&ensp;&ensp;readonly 规定输入字段为只读。input 内容会随着表单提交。<br>&ensp;&ensp;无论设置 readonly 还是 disabled，通过 js 脚本都能更改 input 的 value</p><h4 id="64-主流浏览器内核私有属性-css-前缀？"><a href="#64-主流浏览器内核私有属性-css-前缀？" class="headerlink" title="64. 主流浏览器内核私有属性 css 前缀？"></a>64. 主流浏览器内核私有属性 css 前缀？</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">mozilla 内核 （firefox,<span class="hljs-keyword">flock</span> 等）    -moz<br>webkit  内核 （safari,chrome 等）   -webkit<br>opera   内核 （opera 浏览器）        -o<br>trident 内核 （ie 浏览器）           -ms<br></code></pre></td></tr></table></figure><h4 id="65-前端性能优化？"><a href="#65-前端性能优化？" class="headerlink" title="65. 前端性能优化？"></a>65. 前端性能优化？</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。<br><br>第一个方面是页面的内容方面<br><br>  （<span class="hljs-number">1</span>）通过文件合并、css 雪碧图、使用 <span class="hljs-keyword">base64 </span>等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。<br><br>  （<span class="hljs-number">2</span>）通过 DNS 缓存等机制来减少 DNS 的查询次数。<br><br>  （<span class="hljs-number">3</span>）通过设置缓存策略，对常用不变的资源进行缓存。<br><br>  （<span class="hljs-number">4</span>）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。<br><br>  （<span class="hljs-number">5</span>）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。<br><br>第二个方面是服务器方面<br><br>  （<span class="hljs-number">1</span>）使用 CDN 服务，来提高用户对于资源请求时的响应速度。<br><br>  （<span class="hljs-number">2</span>）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。<br><br>  （<span class="hljs-number">3</span>）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie<br><br>第三个方面是 CSS 和 <span class="hljs-keyword">JavaScript </span>方面<br><br>  （<span class="hljs-number">1</span>）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。<br><br>  （<span class="hljs-number">2</span>）避免使用 @import 标签。<br><br>  （<span class="hljs-number">3</span>）尽量把 <span class="hljs-keyword">js </span>脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。<br><br>  （<span class="hljs-number">4</span>）通过对 <span class="hljs-keyword">JavaScript </span>和 CSS 的文件进行压缩，来减小文件的体积。<br></code></pre></td></tr></table></figure><p>详细的资料可以参考：<br><a href="https://juejin.im/post/5b73ef38f265da281e048e51#heading-10">前端性能优化之雅虎35条军规</a><br><a href="https://juejin.im/entry/58709b9a128fe1006b29cd5d">你真的了解 gzip 吗？</a><br><a href="https://segmentfault.com/a/1190000012571492">前端性能优化之 gzip</a></p><h4 id="66-Chrome-中的-Waterfall-？"><a href="#66-Chrome-中的-Waterfall-？" class="headerlink" title="66. Chrome 中的 Waterfall ？"></a>66. Chrome 中的 Waterfall ？</h4><p>详细资料可以参考：<br><a href="https://blog.csdn.net/carian_violet/article/details/84954360">前端性能之 Chrome 的 Waterfall</a><br><a href="https://blog.csdn.net/csdn_girl/article/details/54911632">教你读懂网络请求的瀑布图</a><br><a href="https://www.zhihu.com/question/27085552/answer/35194131">前端妹子跟我抱怨她们的页面加载很慢的时候，如何在她面前优雅地装逼？</a></p><h4 id="67-扫描二维码登录网页是什么原理，前后两个事件是如何联系的？"><a href="#67-扫描二维码登录网页是什么原理，前后两个事件是如何联系的？" class="headerlink" title="67. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？"></a>67. 扫描二维码登录网页是什么原理，前后两个事件是如何联系的？</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs applescript">核心过程应该是：浏览器获得一个临时 <span class="hljs-built_in">id</span>，通过长连接等待客户端扫描带有此 <span class="hljs-built_in">id</span> 的二维码后，从长连接中获得客户端上报给 serv<br>er的帐号信息进行展示。并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。在超时、网络断开、其他设备<br>上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。<br><br>我的理解<br><br>二维码登录网页的基本原理是，用户进入登录网页后，服务器生成一个 uid 来标识一个用户。对应的二维码对应了一个对应 uid <br>的链接，任何能够识别二维码的应用都可以获得这个链接，但是它们没有办法和对应登录的服务器响应。比如微信的二维码登录，只<br>有用微信识这个二维码才有效。当微信客户端打开这个链接时，对应的登录服务器就获得了用户的相关信息。这个时候登录网页根据<br>先前的长连接获取到服务器传过来的用户信息进行显示。然后提前预加载一些登录后可能用到的信息。当客户端点击确认授权登陆后，<br>服务器生成一个权限令牌给网页，网页之后使用这个令牌进行信息的交互过程。由于整个授权的过程都是在手机端进行的，因此能够<br>很好的防止 PC 上泛滥的病毒。并且在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程能够形成<br>有效的安全防护。<br></code></pre></td></tr></table></figure><p>详细资料可以参考：<br><a href="https://www.zhihu.com/question/20368066">微信扫描二维码登录网页</a></p><h4 id="68-Html-规范中为什么要求引用资源不加协议头http或者https？"><a href="#68-Html-规范中为什么要求引用资源不加协议头http或者https？" class="headerlink" title="68. Html 规范中为什么要求引用资源不加协议头http或者https？"></a>68. Html 规范中为什么要求引用资源不加协议头<code>http</code>或者<code>https</code>？</h4><p>&ensp;&ensp;如果用户当前访问的页面是通过 HTTPS 协议来浏览的，那么网页中的资源也只能通过 HTTPS 协议来引用，否则浏览器会出现警告信息，不同浏览器警告信息展现形式不同。</p><p>&ensp;&ensp;为了解决这个问题，我们可以省略 URL 的协议声明，省略后浏览器照样可以正常引用相应的资源，这项解决方案称为protocol-relative URL，暂且可译作协议相对 URL。</p><p>&ensp;&ensp;如果使用协议相对 URL，无论是使用 HTTPS，还是 HTTP 访问页面，浏览器都会以相同的协议请求页面中的资源，避免弹出类似的警告信息，同时还可以节省5字节的数据量。</p><p>详细资料可以参考：<br><a href="https://www.ludou.org/the-protocol-relative-url.html">协议相对 URL</a><br><a href="https://www.tuicool.com/articles/nEjU7b">Why you need protocol-relative URLs <em>now</em></a></p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Worker详解</title>
    <link href="/2023/10/24/Worker%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/10/24/Worker%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>Web Worker是一项 HTML5 的新特性，可以再web页面中创建后台线程，从而可以让 JavaSscript 在主线程运行的同时，在后台线程中执行耗时的操作。这使得 Web 应用程序更加的流畅，而不会出现 UI 卡顿或其它性能问题。在本文中，我们将详细讨论 Web Worker，包括用法、示例和使用场景。</p><h3 id="什么是Web-Worker"><a href="#什么是Web-Worker" class="headerlink" title="什么是Web Worker?"></a>什么是Web Worker?</h3><p>Web Worker是浏览器提供的JavaScript API，它允许在后台进程中运行脚本，而不会阻塞主线程。这意味着，及时脚本运行了很长时间，Web应用程序的UI仍然保持响应。</p><p>Web Worker有两种类型: Dedicated Worker 和 Shared Worker。Dedicated Worker 是指与一个页面绑定的 Worker，它仅能由该页面的脚本使用。而 Shared Worker 则可以被多个页面共享使用，这使得多个页面可以同时访问同一个后台线程。</p><h3 id="Web-Worker-的用法"><a href="#Web-Worker-的用法" class="headerlink" title="Web Worker 的用法"></a>Web Worker 的用法</h3><p>Web Worker 的用法非常简单，只需要调用 Worker() 构造函数即可创建一个 Worker 对象。例如，以下代码创建了一个 Dedicated Worker：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建 Dedicated Worker</span><br><span class="hljs-keyword">const</span> myWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;worker.js&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们将 Worker() 构造函数传递给要执行的脚本的 URL。此时，浏览器会创建一个新的后台线程，加载该 URL 指定的脚本，并在该线程中执行。</p><p>然后，我们可以在主线程中使用 postMessage() 方法向后台线程发送消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 向 Dedicated Worker 发送消息</span><br>myWorker.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在后台线程中，我们可以通过监听 message 事件来接收消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 监听消息</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;收到消息：&#x27;</span> + e.<span class="hljs-property">data</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用 addEventListener() 方法来监听 message 事件，并在事件处理程序中打印收到的消息。</p><h3 id="Web-Worker-的示例"><a href="#Web-Worker-的示例" class="headerlink" title="Web Worker 的示例"></a>Web Worker 的示例</h3><p>下面是一个使用 Web Worker 的简单示例。该示例中，我们将使用 Dedicated Worker 计算斐波那契数列的第 n 项，以展示 Web Worker 的使用方法。</p><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;title&gt;Web Worker 示例&lt;/title&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;h1&gt;Web Worker 示例&lt;/h1&gt;<br>    &lt;p&gt;计算斐波那契数列的第 &lt;input type=&quot;number&quot; id=&quot;num&quot; min=&quot;1&quot; value=&quot;1&quot;&gt; 项&lt;/p&gt;<br>    &lt;button id=&quot;calculate&quot;&gt;计算&lt;/button&gt;<br>    &lt;p id=&quot;result&quot;&gt;&lt;/p&gt;<br>    &lt;script src=&quot;worker.js&quot;&gt;&lt;/script&gt;<br>    &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-comment">// 获取元素</span><br><span class="hljs-keyword">const</span> numInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;num&#x27;</span>);<br><span class="hljs-keyword">const</span> calculateButton = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;calculate&#x27;</span>);<br><span class="hljs-keyword">const</span> resultElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;result&#x27;</span>);<br><br><span class="hljs-comment">// 创建 Dedicated Worker</span><br><span class="hljs-keyword">const</span> myWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;worker.js&#x27;</span>);<br><br><span class="hljs-comment">// 监听消息</span><br>myWorker.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  resultElement.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;结果：&#x27;</span> + e.<span class="hljs-property">data</span>;<br>&#125;);<br><br><span class="hljs-comment">// 监听错误</span><br>myWorker.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Worker 错误：&#x27;</span> + e.<span class="hljs-property">filename</span> + <span class="hljs-string">&#x27;:&#x27;</span> + e.<span class="hljs-property">lineno</span> + <span class="hljs-string">&#x27;: &#x27;</span> + e.<span class="hljs-property">message</span>);<br>&#125;);<br><br><span class="hljs-comment">// 处理点击事件</span><br>calculateButton.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> num = <span class="hljs-title class_">Number</span>(numInput.<span class="hljs-property">value</span>);<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(num) || num &lt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;请输入一个大于等于 1 的数字！&#x27;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 向 Dedicated Worker 发送消息</span><br>  myWorker.<span class="hljs-title function_">postMessage</span>(num);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="worker-js"><a href="#worker-js" class="headerlink" title="worker.js"></a>worker.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 监听消息</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-keyword">const</span> num = e.<span class="hljs-property">data</span>;<br><br>  <span class="hljs-comment">// 计算斐波那契数列的第 num 项</span><br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">fibonacci</span>(num);<br><br>  <span class="hljs-comment">// 向主线程发送消息</span><br>  self.<span class="hljs-title function_">postMessage</span>(result);<br>&#125;);<br><br><span class="hljs-comment">// 计算斐波那契数列的第 n 项</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span> || n === <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fibonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title function_">fibonacci</span>(n - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们首先获取页面中的一些元素，并创建了一个 Dedicated Worker。然后，我们监听了 message 事件和 error 事件，并分别在事件处理程序中更新页面中的结果元素或打印错误消息。</p><p>在处理点击事件时，我们首先验证了用户输入的数字，并向 Dedicated Worker 发送了一个消息。在后台线程中，我们计算了斐波那契数列的第 n 项，并向主线程发送了一个消息。最后，在 message 事件处理程序中，我们更新了页面中的结果元素。</p><h3 id="Web-Worker-的使用场景"><a href="#Web-Worker-的使用场景" class="headerlink" title="Web Worker 的使用场景"></a>Web Worker 的使用场景</h3><p>Web Worker 可以在很多场景下使用，特别是在需要处理大量数据或计算密集型任务时。以下是一些 Web Worker 的使用场景：</p><ul><li><strong>图像处理</strong>：Web Worker 可以用于处理图像操作，如旋转、裁剪、缩放、滤镜等。这可以提高图像处理的性能和响应速度。</li><li><strong>数据处理</strong>：Web Worker 可以用于处理大量数据，如数据集的过滤、排序、归纳、转换等。这可以提高数据处理的效率和准确性。</li><li><strong>计算密集型任务</strong>：Web Worker 可以用于处理计算密集型任务，如模拟、优化、预测、统计等。这可以提高计算任务的速度和精度。</li><li><strong>实时通信</strong>：Web Worker 可以用于实现实时通信，如聊天室、游戏、视频会议等。这可以提高实时通信的稳定性和性能。</li><li><strong>离线缓存</strong>：Web Worker 可以用于离线缓存，可以将常用的资源预先下载到客户端本地缓存中，并在无法访问互联网时使用缓存中的资源。这可以提高应用程序的可用性和响应速度，尤其是在移动设备上。</li><li><strong>多线程处理</strong>：Web Worker 可以用于实现多线程处理，如并行计算、任务分发、负载均衡等。这可以提高系统的并发性和可伸缩性。</li></ul><p>总之，Web Worker 可以用于任何需要在后台执行长时间运行的任务，以避免阻塞 UI 线程和提高应用程序的性能和响应速度。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>Web Worker 是一个非常有用的 API，它可以使我们在浏览器中使用多线程处理和提高应用程序的性能。虽然 Web Worker 的使用并不复杂，但我们需要注意一些事项，如数据传递、脚本加载、生命周期管理等。希望可以帮助你理解 Web Worker，并在实际项目中应用它。</p>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue3-hooks方法</title>
    <link href="/2023/09/16/Vue3-hooks%E6%96%B9%E6%B3%95/"/>
    <url>/2023/09/16/Vue3-hooks%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1-hooks定义"><a href="#1-hooks定义" class="headerlink" title="1. hooks定义"></a>1. hooks定义</h3><p>一些可复用的方法像钩子一样挂着，可以随时被引入和调用以实现高内聚低耦合的目标，应该都能算是hook</p><h3 id="2-为什么Vue3要用自定义Hook？"><a href="#2-为什么Vue3要用自定义Hook？" class="headerlink" title="2. 为什么Vue3要用自定义Hook？"></a>2. 为什么Vue3要用自定义Hook？</h3><p>结论：就是为了让Compoosition Api更好用更丰满，让写Vue3更畅快！像写诗一样写代码！<br>其实这个问题更深意义是为什么Vue3比Vue2更好！无外呼性能大幅度提升，其实编码体验也是Vue3的优点<strong>Composition Api的引入（解决Option Api在代码量大的情况下的强耦合）</strong> 让开发者有更好的开发体验。<br>个人碎碎念：但是这些所谓的提高开发体验都是需要开发者不断学习养成编码好习惯</p><h3 id="3-定义表格请求-hooks-uselist"><a href="#3-定义表格请求-hooks-uselist" class="headerlink" title="3. 定义表格请求 hooks uselist"></a>3. 定义表格请求 hooks uselist</h3><h4 id="3-1-js版"><a href="#3-1-js版" class="headerlink" title="3.1 js版"></a>3.1 js版</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElMessage</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus&#x27;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取数据操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> Function </span>&#125; api 请求的方法 required</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; <span class="hljs-variable">page</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; <span class="hljs-variable">size</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; isAuto 是否是分页请求</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; key  返回数据的键值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> callback </span>&#125; <span class="hljs-variable">cb</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type"> Object </span>&#125; &#123;<span class="hljs-type"> page,size,total,showSearch,loading,query,tableData,getList,reset </span>&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useList</span>(<span class="hljs-params">api, params, cb</span>) &#123;<br>  <span class="hljs-keyword">if</span>(!api) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;api is not found&#x27;</span>)<br>  <span class="hljs-keyword">const</span> page = <span class="hljs-title function_">ref</span>(params.<span class="hljs-property">page</span> || <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">const</span> size = <span class="hljs-title function_">ref</span>(params.<span class="hljs-property">size</span> || <span class="hljs-number">10</span>)<br>  <span class="hljs-keyword">const</span> total = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> query = <span class="hljs-title function_">ref</span>(&#123;&#125;)<br>  <span class="hljs-keyword">const</span> loading = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)<br>  <span class="hljs-keyword">const</span> showSearch = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">const</span> isAuto = <span class="hljs-title function_">ref</span>(params.<span class="hljs-property">isAuto</span> || <span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">const</span> tableData = <span class="hljs-title function_">ref</span>([])<br>  <span class="hljs-keyword">const</span> key = params.<span class="hljs-property">key</span> || <span class="hljs-string">&#x27;rows&#x27;</span><br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getList</span>(<span class="hljs-params">obj = &#123;&#125;</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!loading.<span class="hljs-property">value</span>) &#123;<br>      loading.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">const</span> defaultParams = params.<span class="hljs-property">params</span> || &#123;&#125;<br>      <span class="hljs-keyword">const</span> data = isAuto.<span class="hljs-property">value</span> ? <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(obj, &#123; <span class="hljs-attr">pageNum</span>: page.<span class="hljs-property">value</span>, <span class="hljs-attr">pageSize</span>: size.<span class="hljs-property">vlaue</span> &#125;, query.<span class="hljs-property">value</span>, defaultParams) : <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(obj, query.<span class="hljs-property">value</span>, defaultParams)<br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title function_">api</span>(data).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span><br>        tableData.<span class="hljs-property">value</span> = cb ? <span class="hljs-title function_">cb</span>(res[key]) : res[key]<br>        total.<span class="hljs-property">value</span> = res.<span class="hljs-property">total</span> || <span class="hljs-number">0</span><br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> &#123;<br>        loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span><br>        <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(c)<br>      &#125;)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params"></span>) &#123;<br>    query.<span class="hljs-property">value</span> = &#123;&#125;<br>    <span class="hljs-title function_">getList</span>()<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    page,<br>    size,<br>    total,<br>    query,<br>    loading,<br>    showSearch,<br>    tableData,<br>    getList,<br>    reset<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-ts版"><a href="#3-2-ts版" class="headerlink" title="3.2 ts版"></a>3.2 ts版</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; ref, <span class="hljs-title class_">Ref</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElMessage</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus&#x27;</span><br><br><span class="hljs-keyword">interface</span> resultData&lt;T&gt; &#123;<br>  <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span><br>  rows?: <span class="hljs-title class_">Array</span>&lt;T&gt;<br>  <span class="hljs-attr">data</span>: <span class="hljs-title class_">Array</span>&lt;T&gt;<br>  total?: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">msg</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> paramsFace &#123;<br>  page?: <span class="hljs-built_in">number</span><br>  size?: <span class="hljs-built_in">number</span><br>  isAuto?: <span class="hljs-built_in">boolean</span><br>  key?: <span class="hljs-built_in">string</span><br>  params?: <span class="hljs-built_in">any</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> resultFn&lt;searchForm, tableForm&gt; &#123;<br>  <span class="hljs-attr">page</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">number</span>&gt;<br>  <span class="hljs-attr">size</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">number</span>&gt;<br>  <span class="hljs-attr">total</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">number</span>&gt;<br>  <span class="hljs-attr">loading</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">boolean</span>&gt;<br>  <span class="hljs-attr">showSearch</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">boolean</span>&gt;<br>  <span class="hljs-attr">query</span>: <span class="hljs-title class_">Ref</span>&lt;searchForm&gt;<br>  <span class="hljs-attr">tableData</span>: <span class="hljs-title class_">Ref</span>&lt;tableForm[]&gt;<br>  <span class="hljs-attr">getList</span>: <span class="hljs-title class_">Function</span><br>  <span class="hljs-attr">reset</span>: <span class="hljs-title class_">Function</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取数据操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> Function </span>&#125; api 请求的方法 required</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> paramsFace </span>&#125; <span class="hljs-variable">params</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> callback </span>&#125; <span class="hljs-variable">cb</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type"> resultFn </span>&#125; &#123;<span class="hljs-type"> page,size,total,loading,query,tableData,getList,reset </span>&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> useList&lt;searchForm, tableForm&gt;(<span class="hljs-attr">api</span>: <span class="hljs-title class_">Function</span>, <span class="hljs-attr">params</span>: paramsFace, <span class="hljs-attr">cb</span>: <span class="hljs-title class_">Function</span>): resultFn &#123;<br>  <span class="hljs-keyword">if</span>(!api) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;api is not found&#x27;</span>)<br>  <span class="hljs-keyword">const</span> page = ref&lt;<span class="hljs-built_in">number</span>&gt;(params.<span class="hljs-property">page</span> || <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">const</span> size = ref&lt;<span class="hljs-built_in">number</span>&gt;(params.<span class="hljs-property">size</span> || <span class="hljs-number">10</span>)<br>  <span class="hljs-keyword">const</span> total = ref&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> query = ref&lt;searchForm&gt;(&#123;&#125;)<br>  <span class="hljs-keyword">const</span> loading = ref&lt;<span class="hljs-built_in">boolean</span>&gt;(<span class="hljs-literal">false</span>)<br>  <span class="hljs-keyword">const</span> showSearch = ref&lt;<span class="hljs-built_in">boolean</span>&gt;(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">const</span> isAuto = ref&lt;<span class="hljs-built_in">boolean</span>&gt;(params.<span class="hljs-property">isAuto</span> || <span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">const</span> tableData = ref&lt;tableForm[]&gt;([])<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span> = params.<span class="hljs-property">key</span> || <span class="hljs-string">&#x27;rows&#x27;</span><br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getList</span>(<span class="hljs-params">obj = &#123;&#125;</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!loading.<span class="hljs-property">value</span>) &#123;<br>      loading.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span><br>      <span class="hljs-keyword">const</span> <span class="hljs-attr">defaultParams</span>: searchForm = params.<span class="hljs-property">params</span> || &#123;&#125;<br>      <span class="hljs-keyword">const</span> data = isAuto.<span class="hljs-property">value</span> ? <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(obj, &#123; <span class="hljs-attr">pageNum</span>: page.<span class="hljs-property">value</span>, <span class="hljs-attr">pageSize</span>: size.<span class="hljs-property">vlaue</span> &#125;, query.<span class="hljs-property">value</span>, defaultParams) : <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(obj, query.<span class="hljs-property">value</span>, defaultParams)<br>      <span class="hljs-title function_">api</span>(data).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res: resultData&lt;tableForm&gt;</span>) =&gt;</span> &#123;<br>        loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span><br>        tableData.<span class="hljs-property">value</span> = cb ? <span class="hljs-title function_">cb</span>(res[key]) : res[key]<br>        total.<span class="hljs-property">value</span> = res.<span class="hljs-property">total</span> || <span class="hljs-number">0</span><br>      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> &#123;<br>        loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span><br>        <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(c)<br>      &#125;)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params"></span>) &#123;<br>    query.<span class="hljs-property">value</span> = &#123;&#125;<br>    <span class="hljs-title function_">getList</span>()<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    page,<br>    size,<br>    total,<br>    query,<br>    loading,<br>    showSearch,<br>    tableData,<br>    getList,<br>    reset<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-弹窗-useModal"><a href="#4-弹窗-useModal" class="headerlink" title="4. 弹窗 useModal"></a>4. 弹窗 useModal</h3><h4 id="4-1-js版"><a href="#4-1-js版" class="headerlink" title="4.1 js版"></a>4.1 js版</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref, <span class="hljs-title class_">Ref</span>, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 弹窗操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; defaultForm 默认参数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; add </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; edit </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type"> Object </span>&#125; &#123;<span class="hljs-type"></span></span><br><span class="hljs-type"><span class="hljs-comment"> *  visible,</span></span><br><span class="hljs-type"><span class="hljs-comment">    isTitle,</span></span><br><span class="hljs-type"><span class="hljs-comment">    modalForm,</span></span><br><span class="hljs-type"><span class="hljs-comment">    modalFormRefs,</span></span><br><span class="hljs-type"><span class="hljs-comment">    title,</span></span><br><span class="hljs-type"><span class="hljs-comment">    open,</span></span><br><span class="hljs-type"><span class="hljs-comment">    close,</span></span><br><span class="hljs-type"><span class="hljs-comment">    submit</span></span><br><span class="hljs-type"><span class="hljs-comment">    </span>&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useModal</span>(<span class="hljs-params">params</span>) &#123;<br>  <span class="hljs-keyword">const</span> visible = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)<br>  <span class="hljs-keyword">const</span> isTitle = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">const</span> modalForm = <span class="hljs-title function_">ref</span>(params.<span class="hljs-property">defaultForm</span> || &#123;&#125;)<br>  <span class="hljs-keyword">const</span> modalFormRefs = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-keyword">const</span> title = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> isTitle.<span class="hljs-property">value</span> ? <span class="hljs-string">&#x27;添加&#x27;</span> : <span class="hljs-string">&#x27;修改&#x27;</span>)<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">open</span>(<span class="hljs-params"></span>) &#123;<br>    visible.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span><br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">close</span>(<span class="hljs-params"></span>) &#123;<br>    visible.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span><br>    isTitle.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span><br>    modalForm.<span class="hljs-property">value</span> = params.<span class="hljs-property">defaultForm</span> || &#123;&#125;<br>    modalFormRefs.<span class="hljs-property">value</span> &amp;&amp; modalFormRefs.<span class="hljs-property">value</span>.<span class="hljs-title function_">resetFields</span>()<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">submit</span>(<span class="hljs-params"></span>) &#123;<br>    modalFormRefs.<span class="hljs-property">value</span> &amp;&amp; modalFormRefs.<span class="hljs-property">value</span>.<span class="hljs-title function_">validate</span>(<span class="hljs-function"><span class="hljs-params">valid</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span>(!valid) <span class="hljs-keyword">return</span><br>      isTitle.<span class="hljs-property">value</span> ? params.<span class="hljs-title function_">add</span>(modalForm.<span class="hljs-property">value</span>) : params.<span class="hljs-title function_">edit</span>(modalForm.<span class="hljs-property">value</span>)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    visible,<br>    isTitle,<br>    modalForm,<br>    modalFormRefs,<br>    title,<br>    open,<br>    close,<br>    submit<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-ts版"><a href="#4-2-ts版" class="headerlink" title="4.2 ts版"></a>4.2 ts版</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; ref, <span class="hljs-title class_">Ref</span>, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">interface</span> resultFn&lt;T&gt; &#123;<br>  <span class="hljs-attr">visible</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">boolean</span>&gt;<br>  <span class="hljs-attr">isTitle</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">boolean</span>&gt;<br>  <span class="hljs-attr">modalForm</span>: T<br>  <span class="hljs-attr">modalFormRefs</span>: <span class="hljs-built_in">any</span><br>  <span class="hljs-attr">title</span>: <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-built_in">string</span>&gt;<br>  <span class="hljs-attr">open</span>: <span class="hljs-title class_">Function</span><br>  <span class="hljs-attr">close</span>: <span class="hljs-title class_">Function</span><br>  <span class="hljs-attr">submit</span>: <span class="hljs-title class_">Function</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> defaultFace&lt;T&gt; &#123;<br>  defaultForm?: T<br>  add?: <span class="hljs-title class_">Function</span><br>  edit?: <span class="hljs-title class_">Function</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 弹窗操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; defaultForm 默认参数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; add </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"> params </span>&#125; edit </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-type"> resultFn </span>&#125; </span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> useModal&lt;paramsForm, resultForm&gt;(<span class="hljs-attr">params</span>: defaultFace&lt;paramsForm&gt;): resultFn&lt;resultForm&gt; &#123;<br>  <span class="hljs-keyword">const</span> visible = ref&lt;<span class="hljs-built_in">boolean</span>&gt;(<span class="hljs-literal">false</span>)<br>  <span class="hljs-keyword">const</span> isTitle = ref&lt;<span class="hljs-built_in">boolean</span>&gt;(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">const</span> modalForm = ref&lt;resultForm&gt;(params.<span class="hljs-property">defaultForm</span> || &#123;&#125;)<br>  <span class="hljs-keyword">const</span> modalFormRefs = ref&lt;<span class="hljs-built_in">any</span>&gt;(<span class="hljs-literal">null</span>)<br>  <span class="hljs-keyword">const</span> title = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> isTitle.<span class="hljs-property">value</span> ? <span class="hljs-string">&#x27;添加&#x27;</span> : <span class="hljs-string">&#x27;修改&#x27;</span>)<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">open</span>(<span class="hljs-params"></span>) &#123;<br>    visible.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span><br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">close</span>(<span class="hljs-params"></span>) &#123;<br>    visible.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span><br>    isTitle.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span><br>    modalForm.<span class="hljs-property">value</span> = params.<span class="hljs-property">defaultForm</span> || &#123;&#125;<br>    modalFormRefs.<span class="hljs-property">value</span> &amp;&amp; modalFormRefs.<span class="hljs-property">value</span>.<span class="hljs-property">resetFileds</span> &amp;&amp; modalFormRefs.<span class="hljs-property">value</span>.<span class="hljs-title function_">resetFileds</span>()<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">submit</span>(<span class="hljs-params"></span>) &#123;<br>    modalFormRefs.<span class="hljs-property">value</span> &amp;&amp; modalFormRefs.<span class="hljs-property">value</span>.<span class="hljs-title function_">validate</span>(<span class="hljs-function"><span class="hljs-params">valid</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span>(!valid) <span class="hljs-keyword">return</span><br>      isTitle.<span class="hljs-property">value</span> ? params.<span class="hljs-title function_">add</span>(modalForm.<span class="hljs-property">value</span>) : params.<span class="hljs-title function_">edit</span>(modalForm.<span class="hljs-property">value</span>)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    visible,<br>    isTitle,<br>    modalForm,<br>    modalFormRefs,<br>    title,<br>    open,<br>    close,<br>    submit<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue2组件通信方式</title>
    <link href="/2023/09/14/Vue2%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <url>/2023/09/14/Vue2%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-通过-props-和-emit-实现父子组件的传参"><a href="#1-通过-props-和-emit-实现父子组件的传参" class="headerlink" title="1. 通过 props 和 $emit 实现父子组件的传参"></a>1. 通过 props 和 $emit 实现父子组件的传参</h3><p>父组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">:message</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attr">update-message</span>=<span class="hljs-string">&quot;updateMessage&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Child.vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Parent&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">Child</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Parent Component&quot;</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello World&quot;</span> &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">updateMessage</span>(<span class="hljs-params">newMessage</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = newMessage</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>子组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;updateMessage&quot;</span>&gt;</span>更新<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Child&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">message</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">default</span>: <span class="hljs-string">&#x27;&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">updateMessage</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update-message&#x27;</span>, <span class="hljs-string">&#x27;更新了&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="2-通过-parent-和-children-实现父子组件通信"><a href="#2-通过-parent-和-children-实现父子组件通信" class="headerlink" title="2. 通过 $parent 和 $children 实现父子组件通信"></a>2. 通过 $parent 和 $children 实现父子组件通信</h3><ul><li>通过 $parent 访问到的是上一级父组件的实例，可以使用 $root 来访问根组件的实例</li><li>在组件中使用$children拿到的是所有的子组件的实例，它是一个数组，并且是无序的</li><li>在根组件 #app 上拿 $parent 得到的是 new Vue()的实例，在这实例上再拿 $parent 得到的是undefined，而在最底层的子组件拿 $children 是个空数组<br>$children 的值是数组，而 $parent是个对象</li></ul><p>父组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Child.vue&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Parent&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">Child</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;Parent Component&quot;</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello World&quot;</span> &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>子组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Child&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;测试&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello word&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>.<span class="hljs-property">title</span></span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="3-兄弟组件传值-eventBus-事件总线"><a href="#3-兄弟组件传值-eventBus-事件总线" class="headerlink" title="3. 兄弟组件传值 eventBus 事件总线"></a>3. 兄弟组件传值 eventBus 事件总线</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">新建一个.<span class="hljs-property">js</span>的文件作为中间件，作为事件中心管理组件之间的通信，通过 $emit 自定义事件，$on 监听自定义事件<br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">// 定义一个新的vue实例作为事件中心，利用它来监听本身的自定义事件</span><br><span class="hljs-keyword">const</span> tmpCom = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> tmpCom<br></code></pre></td></tr></table></figure><p>A组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>A组件<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;我是A组件&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;maxbrother&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-comment">//引入中间件</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> tmpCom <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/router/middleware&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  data () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">brotherdata</span>: <span class="hljs-string">&#x27;我是大兄弟&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    maxbrother () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-comment">// 触发事件中心的max-brother事件 </span></span></span><br><span class="language-javascript"><span class="language-xml">      tmpCom.$emit(<span class="hljs-string">&#x27;max-brother&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">brotherdata</span>)</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">brotherdata</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  created () &#123;&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>B组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>B组件<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;brother&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">//引入中间件</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> tmpCom <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/router/middleware&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  data () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">brother</span>: <span class="hljs-string">&#x27;我是B组件&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  mounted () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 监听事件中心的max-brother事件</span></span></span><br><span class="language-javascript"><span class="language-xml">     <span class="hljs-comment">// 这里的第二个参数必须使用箭头函数</span></span></span><br><span class="language-javascript"><span class="language-xml">    tmpCom.$on(<span class="hljs-string">&#x27;max-brother&#x27;</span>, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">brother</span> = val</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="4-注入依赖-provide-inject-使用"><a href="#4-注入依赖-provide-inject-使用" class="headerlink" title="4. 注入依赖 provide&#x2F;inject 使用"></a>4. 注入依赖 provide&#x2F;inject 使用</h3><p>这种方式就是vue中依赖注入，该方法用于 父子组件之间 的通信。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方式来进行传值。就不用一层一层的传递数据了。</p><p>provide和inject是vue提供的两个钩子，和data、methods是同级的。并且provide的书写形式和data一样。</p><ul><li>provide 钩子用来发送数据或方法。</li><li>inject钩子用来接收数据或方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//父组件  </span><br>data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">pimsg</span>: <span class="hljs-string">&#x27;我是父组件的值&#x27;</span>,<br>      <span class="hljs-attr">num</span>: <span class="hljs-number">99999</span><br>    &#125;<br>  &#125;,<br>  provide () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">num</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span><br>    &#125;<br>  &#125;<br><br><span class="hljs-comment">//子组件</span><br> <span class="hljs-attr">inject</span>: [<span class="hljs-string">&#x27;num&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="5-ref-refs"><a href="#5-ref-refs" class="headerlink" title="5. ref &#x2F; $refs"></a>5. ref &#x2F; $refs</h3><p>这种方式也是实现父子组件之间的通信</p><p>ref：这个属性用在子组件上，它的用法就指向了子组件的实例，可以通过实例来访问组件的数据和方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//子组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;我是张三&#x27;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    sayHello () &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是李四&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//父组件</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">components</span>: &#123; child &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    mounted () &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">child</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// &#x27;我是张三&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">child</span>.<span class="hljs-title function_">sayHello</span>();  <span class="hljs-comment">// 我是李四</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>markdown基础语法</title>
    <link href="/2023/09/12/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/09/12/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>之前写文章做记录都是直接码字，码字虽然方便，但是遇到代码部分就很dan疼，尤其是代码格式化很麻烦，开始用markdown之后就觉得特别方便，简单记录下基础语法。</p><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h3><p>标题主要是通过在文字前边加不同数量的 # 去完成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">一级标题</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 二级标题</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## 三级标题</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">### 四级标题</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">#### 五级标题</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">##### 六级标题</span></span><br></code></pre></td></tr></table></figure><img src="/images/markdown/title.png" /><h3 id="2-正文内容"><a href="#2-正文内容" class="headerlink" title="2. 正文内容"></a>2. 正文内容</h3><p>正文内容直接去打字写就可以了，需要注意的是如果要另起一段的话，是需要按两次回车的，也就是两段之间需要空一行</p><h3 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3. 代码块"></a>3. 代码块</h3><p>代码块内容直接放在两个 中间即可，可以在上边后边加上语言类型，会高亮显示语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span> is javascript language<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">name</span>(<span class="hljs-params"></span>)&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="4-行内代码"><a href="#4-行内代码" class="headerlink" title="4. 行内代码"></a>4. 行内代码</h3><p>行内代码讲代码写在行内的 &#96;&#96; 中间即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">行内代码可以直接书写，`this is inline code` 样式<br></code></pre></td></tr></table></figure><p>行内代码可以直接书写，<code>this is inline code</code> 样式</p><h3 id="5-有序列表和无序列表"><a href="#5-有序列表和无序列表" class="headerlink" title="5. 有序列表和无序列表"></a>5. 有序列表和无序列表</h3><p>有序列表通过文字前边添加1.2.3.4等即可，二级结构通过前边加空格或tab就可以</p><p>无序列表通过文字前边添加 * 或者 - 就可以，二级结构同样的方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">有序列表: <br>1. 第一个<br>2. 第二个<br>3. 第三个<br>  1. 第三点的第一个<br>  2. 第三点的第二个<br><br>无序列表: <br>* 第一个<br>- 第二个<br>  - 第二个的第一个<br>  - 第二个的第二个<br>- 第三个<br></code></pre></td></tr></table></figure><p>有序列表: </p><ol><li>第一个</li><li>第二个</li><li>第三个</li><li>第三点的第一个</li><li>第三点的第二个</li></ol><p>无序列表: </p><ul><li>第一个</li></ul><ul><li>第二个<ul><li>第二个的第一个</li><li>第二个的第二个</li></ul></li><li>第三个</li></ul><h3 id="6-文本加粗、倾斜和删除线"><a href="#6-文本加粗、倾斜和删除线" class="headerlink" title="6. 文本加粗、倾斜和删除线"></a>6. 文本加粗、倾斜和删除线</h3><p>文本的特殊格式比较简单，加粗是文本两侧加<strong>，倾斜是文本两侧加<em>，加粗和倾斜一起是文本两侧加</em></strong>，删除线是文本两侧加~~</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">**加粗**<br>*倾斜*<br>***加粗和倾斜***<br>~~删除线~~<br></code></pre></td></tr></table></figure><p><strong>加粗</strong><br><em>倾斜</em><br><em><strong>加粗和倾斜</strong></em><br><del>删除线</del></p><h3 id="7-引用文本"><a href="#7-引用文本" class="headerlink" title="7. 引用文本"></a>7. 引用文本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">引用文本</span><br></code></pre></td></tr></table></figure><blockquote><p>引用文本</p></blockquote><h3 id="8-分割线"><a href="#8-分割线" class="headerlink" title="8. 分割线"></a>8. 分割线</h3><p>分割线写法很简单，只需要使用三个或三个以上 *** 或者 — 即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">***<br>******<br>---<br>------<br></code></pre></td></tr></table></figure><hr><hr><hr><hr><h3 id="9-图片"><a href="#9-图片" class="headerlink" title="9. 图片"></a>9. 图片</h3><ol><li>[alt](url title)方式</li></ol><p>图片的引用的基本语法是：[alt](url title)，alt为图片下方文字，title为图片说明，即鼠标放上去后显示文案，url为图片路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">![风景图](https://gimg2.baidu.com/image_search/src=http%3A%2F%2F1812.img.pp.sohu.com.cn%2Fimages%2Fblog%2F2009%2F11%2F18%2F18%2F8%2F125b6560a6ag214.jpg&amp;refer=http%3A%2F%2F1812.img.pp.sohu.com.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1621561120&amp;t=d99b987e1a68ed50f149aa611e2ab62a &quot;风景图片&quot;)<br></code></pre></td></tr></table></figure><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F1812.img.pp.sohu.com.cn%2Fimages%2Fblog%2F2009%2F11%2F18%2F18%2F8%2F125b6560a6ag214.jpg&refer=http%3A%2F%2F1812.img.pp.sohu.com.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1621561120&t=d99b987e1a68ed50f149aa611e2ab62a" alt="风景图" title="风景图片"></p><ol start="2"><li>html标签方式</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;div align=center&gt;&lt;img width=400 src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2F1812.img.pp.sohu.com.cn%2Fimages%2Fblog%2F2009%2F11%2F18%2F18%2F8%2F125b6560a6ag214.jpg&amp;refer=http%3A%2F%2F1812.img.pp.sohu.com.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1621561120&amp;t=d99b987e1a68ed50f149aa611e2ab62a&quot; /&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><div align=center><img width=400 src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F1812.img.pp.sohu.com.cn%2Fimages%2Fblog%2F2009%2F11%2F18%2F18%2F8%2F125b6560a6ag214.jpg&refer=http%3A%2F%2F1812.img.pp.sohu.com.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1621561120&t=d99b987e1a68ed50f149aa611e2ab62a" /></div><h3 id="10-超链接"><a href="#10-超链接" class="headerlink" title="10. 超链接"></a>10. 超链接</h3><p>超链接的格式和图片结构基本差不多，[超链接名称](url title)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[程序员学习圣地: 掘金](https://juejin.cn/)<br></code></pre></td></tr></table></figure><p><a href="https://juejin.cn/">程序员学习圣地: 掘金</a></p><h3 id="11-表格"><a href="#11-表格" class="headerlink" title="11. 表格"></a>11. 表格</h3><p>表格的写法看上去很有意思，第一行可以写标题，然后第二行通过特殊标识区分表头和表内容，同时默认表格文字左对齐，如果想文本居中，可以通过第二行标识进行控制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">默认表格：<br>姓名 | 年龄 | 班级 | 成绩<br>-|:-|:-|:-|<br>张三 | 20 | 一班 | 90<br>张三 | 20 | 一班 | 80<br>张三 | 20 | 一班 | 70<br>张三 | 20 | 一班 | 99<br><br>表格文本居中：(注意第二行变化)<br>姓名 | 年龄 | 班级 | 成绩<br>:-:|:-:|:-:|:-:|<br>张三 | 20 | 一班 | 90<br>张三 | 20 | 一班 | 80<br>张三 | 20 | 一班 | 70<br>张三 | 20 | 一班 | 99<br></code></pre></td></tr></table></figure><p>默认表格：</p><table><thead><tr><th>姓名</th><th align="left">年龄</th><th align="left">班级</th><th align="left">成绩</th></tr></thead><tbody><tr><td>张三</td><td align="left">20</td><td align="left">一班</td><td align="left">90</td></tr><tr><td>张三</td><td align="left">20</td><td align="left">一班</td><td align="left">80</td></tr><tr><td>张三</td><td align="left">20</td><td align="left">一班</td><td align="left">70</td></tr><tr><td>张三</td><td align="left">20</td><td align="left">一班</td><td align="left">99</td></tr></tbody></table><p>表格文本居中：(注意第二行变化)</p><table><thead><tr><th align="center">姓名</th><th align="center">年龄</th><th align="center">班级</th><th align="center">成绩</th></tr></thead><tbody><tr><td align="center">张三</td><td align="center">20</td><td align="center">一班</td><td align="center">90</td></tr><tr><td align="center">张三</td><td align="center">20</td><td align="center">一班</td><td align="center">80</td></tr><tr><td align="center">张三</td><td align="center">20</td><td align="center">一班</td><td align="center">70</td></tr><tr><td align="center">张三</td><td align="center">20</td><td align="center">一班</td><td align="center">99</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>函数节流与防抖</title>
    <link href="/2023/09/12/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/"/>
    <url>/2023/09/12/%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/</url>
    
    <content type="html"><![CDATA[<h3 id="1-初步了解函数节流与防抖"><a href="#1-初步了解函数节流与防抖" class="headerlink" title="1. 初步了解函数节流与防抖"></a>1. 初步了解函数节流与防抖</h3><blockquote><p>函数节流与防抖是优化高频执行js代码的一种手段，js中的一些事件，如浏览器的: resize、scroll、鼠标的mousemove、mouseover、input输入框的keypress等事件<br>在触发时，会不断的调用绑定的回调函数，极大的浪费了资源，降低前端性能，为了优化体验，需要对这类事件进行调用次数的限制。即: 限制函数的执行次数</p></blockquote><blockquote><p>节流: 减少一段时间的触发频率(控制触发次数)<br>防抖: 通过setTimeout的方式，在一定时间间隔内，将多次触发变为最后一次触发</p></blockquote><h3 id="2-函数防抖"><a href="#2-函数防抖" class="headerlink" title="2. 函数防抖"></a>2. 函数防抖</h3><ol><li>为什么需要防抖</li></ol><blockquote><p>前端开发过程中，有一些事件，常见的例如，onresize，scroll，mousemove ,mousehover等，会被频繁触发（短时间内多次触发），不做限制的话，有可能一秒之内执<br>行几十次、几百次，如果在这些函数内部执行了其他函 数，尤其是执行了操作DOM 的函数（浏览器操作 DOM 是很耗费性能的），那不仅会浪费计算机资源，还会降低程<br>序运行速度，甚至造成浏览器卡死、崩溃。</p></blockquote><ol start="2"><li>概念与应用</li></ol><blockquote><p>概念：函数防抖（debounce），就是指触发事件后，在 n 秒内函数只能执行一次，如果触发事件后在 n 秒内又触发了事件，则会重新计算函数延执行时间。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> id=<span class="hljs-string">&quot;test&quot;</span> /&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> test = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#test&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span></span></span><br><span class="language-javascript"><span class="language-xml">  test.<span class="hljs-property">oninput</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">if</span>(timer) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-built_in">clearTimeout</span>(timer)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;, <span class="hljs-number">400</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>进行封装</li></ol><blockquote><p>对函数进行封装，封装后：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> id=<span class="hljs-string">&quot;test&quot;</span> /&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> test = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#test&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span></span></span><br><span class="language-javascript"><span class="language-xml">  test.<span class="hljs-property">oninput</span> = <span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, time = <span class="hljs-number">500</span></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">if</span>(timer) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-built_in">clearTimeout</span>(timer)</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        fn.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;, time)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="4"><li>函数防抖应用场景</li></ol><ul><li>搜索框搜索输入。只需用户最后一次输入完，再发送请求；</li><li>用户名、手机号、邮箱输入验证；</li><li>浏览器窗口大小改变后，只需窗口调整完后，再执行 resize 事件中的代码，防止重复渲染</li></ul><h3 id="3-函数节流"><a href="#3-函数节流" class="headerlink" title="3. 函数节流"></a>3. 函数节流</h3><ol><li>函数节流概念与应用</li></ol><blockquote><p>概念： 限制一个函数在一定时间内只能执行一次。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body style=<span class="hljs-string">&quot;height: 2000px;&quot;</span>&gt;&lt;/body&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span>= <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">if</span>(flag)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;@&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">              flag = <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">          &#125;,<span class="hljs-number">500</span>)  </span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      flag = <span class="hljs-literal">false</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="2"><li>函数封装</li></ol><blockquote><p>对函数进行封装，封装后：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body style=<span class="hljs-string">&quot;height: 2000px;&quot;</span>&gt;&lt;/body&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span>= <span class="hljs-title function_">throttle</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;@&#x27;</span>)</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, time = <span class="hljs-number">500</span></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">if</span>(flag) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">           flag = <span class="hljs-literal">false</span></span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">             fn.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)</span></span><br><span class="language-javascript"><span class="language-xml">             flag = <span class="hljs-literal">true</span></span></span><br><span class="language-javascript"><span class="language-xml">          &#125;, time)</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>节流的应用场景</li></ol><ul><li>懒加载、滚动加载、加载更多或监听滚动条位置；</li><li>百度搜索框，搜索联想功能；</li><li>防止高频点击提交，防止表单重复提交；</li></ul><h3 id="4-函数防抖和节流的比较"><a href="#4-函数防抖和节流的比较" class="headerlink" title="4. 函数防抖和节流的比较"></a>4. 函数防抖和节流的比较</h3><ol><li>相同点</li></ol><blockquote><p>都可以通过使用 setTimeout 实现。<br>目的都是，降低回调执行频率，节省计算资源。</p></blockquote><ol start="2"><li>不同点</li></ol><blockquote><p>函数防抖: 在一段连续操作结束后，处理回调，关注一定时间连续触发的事件只在最后执行一次。<br>函数节流: 在一段连续操作中，每一段时间只执行一次，侧重于一段时间内只执行一次。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 博客搭建和使用教程</title>
    <link href="/2023/08/28/init-hexo/"/>
    <url>/2023/08/28/init-hexo/</url>
    
    <content type="html"><![CDATA[<p>从零搭建一个属于自己的静态博客网站，使用Hexo博客框架并部署到 Github，让您可以在不用购买云服务器的情况下拥有一个属于自己的博客网站。</p><h3 id="Hexo-介绍"><a href="#Hexo-介绍" class="headerlink" title="Hexo 介绍"></a>Hexo 介绍</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br>官方地址: <u><a href="https://hexo.io/zh-cn/index.html">Hexo</a></u></p><h3 id="第一章-前期准备"><a href="#第一章-前期准备" class="headerlink" title="第一章 前期准备"></a>第一章 前期准备</h3><h4 id="1-1-安装前所需环境介绍"><a href="#1-1-安装前所需环境介绍" class="headerlink" title="1.1 安装前所需环境介绍"></a>1.1 安装前所需环境介绍</h4><p>安装 Hexo 之前，需要确保您的 PC 中已经安装以下工具:</p><ul><li>Node.js <u><a href="https://nodejs.org/en">地址: Node.js (nodejs.org)</a></u></li><li>Git <u><a href="https://git-scm.com/">地址: Git (git-scm.com)</a></u></li></ul><p>如果您的电脑已经具备所需工具，那么您可以直接进入第二章开始安装 Hexo 了。</p><p>如果您还未安装这两款工具，那么请按照以下步骤进行安装。</p><h4 id="1-2-安装-Git"><a href="#1-2-安装-Git" class="headerlink" title="1.2 安装 Git"></a>1.2 安装 Git</h4><ul><li>官方下载地址: <u><a href="https://git-scm.com/download/win">Git - Downloading Package (git-scm.com)</a></u></li><li>注意事项: 建议选择 64-bit Git for Windows Setup，并且安装时要勾选 Add to PATH 选项</li></ul><img src="/images/initHexo/Git.png" /><ul><li>安装后验证: 在 cmd 中输入命令 git –version, 查看 Git 版本</li></ul><h4 id="1-3-安装-Node-js"><a href="#1-3-安装-Node-js" class="headerlink" title="1.3 安装 Node.js"></a>1.3 安装 Node.js</h4><ul><li>官方下载地址: <u><a href="https://nodejs.org/en">Node.js (nodejs.org)</a></u></li><li>注意事项: 使用 Node.js 官方安装程序时，请确保勾选 Add to PATH 选项（默认已勾选）</li></ul><img src="/images/initHexo/Node.png" /><ul><li>安装后验证: 在 cmd 中输入命令 node -v, 查看 Node 版本</li></ul><hr><p>至此，您已经完成了安装 Hexo 所需的所有额外环境，接下来就可以安装 Hexo 了</p><h3 id="第二章-安装-Hexo"><a href="#第二章-安装-Hexo" class="headerlink" title="第二章 安装 Hexo"></a>第二章 安装 Hexo</h3><h4 id="2-1-安装-Hexo"><a href="#2-1-安装-Hexo" class="headerlink" title="2.1 安装 Hexo"></a>2.1 安装 Hexo</h4><ul><li>命令: npm install -g hexo-cli<br>说明: -g 表示全局安装，hexo-cli 为所安装的包</li><li>安装后验证: 在 cmd 中输入命令 hexo -v, 可查看 hexo 版本</li></ul><img src="/images/initHexo/hexo.png" /><h4 id="2-2-注意事项"><a href="#2-2-注意事项" class="headerlink" title="2.2 注意事项"></a>2.2 注意事项</h4><p>建议永远安装最新版本的 Hexo，以及 <u><a href="https://hexo.io/zh-cn/docs/index.html#%E5%AE%89%E8%A3%85%E5%89%8D%E6%8F%90">推荐的 Node.js 版本</a></u></p><table><thead><tr><th>Hexo版本</th><th>Node版本</th></tr></thead><tbody><tr><td>6.0+</td><td>12.13.0</td></tr><tr><td>5.0+</td><td>10.13.0</td></tr><tr><td>4.1 - 4.2</td><td>8.10</td></tr><tr><td>4.0</td><td>8.6</td></tr><tr><td>3.3 - 3.9</td><td>6.9</td></tr><tr><td>3.2 - 3.3</td><td>0.12</td></tr><tr><td>3.0 - 3.1</td><td>0.10 or iojs</td></tr><tr><td>0.01 - 2.8</td><td>0.10</td></tr></tbody></table><hr><p>至此，您已成成功安装了 Hexo，接下来进入 Github 的配置吧!</p><h3 id="第三章-配置-Github"><a href="#第三章-配置-Github" class="headerlink" title="第三章 配置 Github"></a>第三章 配置 Github</h3><p>如果您还没有 Gihub 账户，请注册一个 Github 账户吧!</p><h4 id="3-1-在-Github-上创建仓库"><a href="#3-1-在-Github-上创建仓库" class="headerlink" title="3.1 在 Github 上创建仓库"></a>3.1 在 Github 上创建仓库</h4><ul><li>新建一个名为: <u><a href="http://username.github.io/">http://username.github.io</a></u> 的仓库(username 为您的 Github 用户名)</li><li>比如，如果您的 github 用户名是 test，那么您就新建名为 <u><a href="http://test.github.io/">http://test.github.io</a></u> 的仓库（必须是您的用户名，其它名称无效），将来你的网站访问地址就是 <u><a href="https://test.github.io/">https://test.github.io</a></u> 了。由此可见，每一个 github 账户最多只能创建一个这样可以直接使用域名访问的仓库。</li></ul><img style="display: flex;width:80%;margin: 0 auto;" src="/images/initHexo/github.png"/><ul><li>注意事项:<br>注册的邮箱一定要验证，否则不会成功;<br>仓库名字必须是：<u><a href="http://username.github.io/">http://username.github.io</a></u>，其中 username 是你的用户名;<br>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久</li></ul><h4 id="3-2-配置-SSH-免密登录"><a href="#3-2-配置-SSH-免密登录" class="headerlink" title="3.2 配置 SSH 免密登录"></a>3.2 配置 SSH 免密登录</h4><p>为什么要配置这个呢？因为您提交代码肯定要拥有您的 github 权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用 ssh key 来解决本地和服务器的连接问题。<br>注: 如果您已经配置过 SSH，可跳过此步骤</p><p>步骤:</p><ol><li><p>首先打开电脑文件夹，找到 C:\Users\您的用户名\ .ssh文件夹并删除(如果没有，则直接进入第二步)</p></li><li><p>在 C:\Users\您的用户名 文件夹下右键打开 Git Bash Here 输入命令: ssh-keygen -t rsa -C “你的github登录邮箱” 生成.ssh秘钥，输入后连敲三次回车，出现下图情况代表成功</p></li></ol><img src="/images/initHexo/github-ssh.png" /><ol start="3"><li><p>生成了一个新的 C:\Users\您的用户名\ .ssh文件夹，打开这个文件夹，找到 .ssh\id_rsa.pub 文件，记事本打开并复制里面的内容</p></li><li><p>打开您的 github 主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key，把复制的内容粘贴进去，title 随便填，保存即可，我们的公钥就添加成功了，设置好如下图:</p></li></ol><img src="/images/initHexo/github-key.png" /><ol start="5"><li>检测是否设置成功:</li></ol><p>输入命令: ssh -T <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#x74;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;">&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#x74;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;</a></p><img src="/images/initHexo/github-success.png" /><p>看到以上信息说明 SSH 已配置成功!</p><ol start="6"><li>此外您还需要如下配置:</li></ol><p>命令: git config –global user.name “您的 Github username” &#x2F;&#x2F; 注意是 username, 而非昵称</p><p>命令: git config –global user.email “<a href="mailto:&#x78;&#120;&#x78;&#64;&#x71;&#113;&#46;&#99;&#111;&#x6d;">&#x78;&#120;&#x78;&#64;&#x71;&#113;&#46;&#99;&#111;&#x6d;</a>“ &#x2F;&#x2F; 填写您的 github 注册邮箱</p><hr><p>至此，您已经成功配置好了 Github，接下来开始搭建个人博客吧!</p><h3 id="第四章-使用-Hexo-搭建博客"><a href="#第四章-使用-Hexo-搭建博客" class="headerlink" title="第四章 使用 Hexo 搭建博客"></a>第四章 使用 Hexo 搭建博客</h3><h4 id="4-1-初始化"><a href="#4-1-初始化" class="headerlink" title="4.1 初始化"></a>4.1 初始化</h4><ol><li><p>在电脑的某个磁盘或路径新建一个名为 hexo 的文件夹(名字可以随便取)，比如我的是 D:\hexo，由于这个文件夹将来就作为您存放代码的地方，所以最好不要随便放</p></li><li><p>在 D:\hexo 文件夹下右键打开 Git Bash Here(控制台)，输入命令: hexo init 进行初始化</p></li></ol><img src="/images/initHexo/hexo-init.png" /><ul><li>hexo 会自动下载一些文件到这个目录，包括 node_modules，目录结构如下图:</li></ul><img src="/images/initHexo/hexo-file.png" /><ol start="3"><li><p>执行命令: hexo g 会在 public 文件夹下生成相关的 html 文件，这些文件将来需要提交到 Github 上</p></li><li><p>执行命令: hexo s 可以开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到博客内容</p></li></ol><h4 id="4-2-将博客部署到-Github"><a href="#4-2-将博客部署到-Github" class="headerlink" title="4.2 将博客部署到 Github"></a>4.2 将博客部署到 Github</h4><ol><li>在 D:\hexo 目录下安装 hexo-deployer-git 插件</li></ol><ul><li>命令: <code>npm install hexo-deployer-git --save</code></li></ul><ol start="2"><li>编辑 D:\hexo 目录下的 _config.yml 文件，在文件末尾添加如下内容:</li></ol><img src="/images/initHexo/upload-git.png" /><ul><li>注意: 其中 repository 中的内容即为 github 个人主页链接地址</li></ul><ol start="3"><li>在 D:\hexo 目录下，输入命令: hexo d 将本地 blog 推送到 github 远程仓库，也可能需要输入 username &amp; pwd</li></ol><p>推送成功后，即可通过 <a href="https://jqstudy.gitee.io/">https://jqstudy.gitee.io/</a> 访问个人博客了!</p><hr><p>至此，您已经会使用 Hexo 搭建博客了，但是您会发现此时访问博客主页，页面很不美观，那么接下来就对您的博客进行美化吧!</p><h3 id="第五章-更换主题"><a href="#第五章-更换主题" class="headerlink" title="第五章 更换主题"></a>第五章 更换主题</h3><p>在 D:\hexo 目录下有一个 themes 文件夹，该文件夹下存放着 hexo 所使用的主题</p><h4 id="5-1-搜索主题"><a href="#5-1-搜索主题" class="headerlink" title="5.1 搜索主题"></a>5.1 搜索主题</h4><ul><li>hexo 官方提供了很多主题供我们使用，地址: <a href="https://hexo.io/themes/">Themes | Hexo</a>, 选择喜欢的主题并点击即可跳转至 github</li><li>笔者使用了 github 上面一个大佬制作的主题，地址: <a href="https://github.com/JoeyBling/hexo-theme-yilia-plus">JoeyBling&#x2F;hexo-theme-yilia-plus: 一个简洁优雅的hexo主题 A simple and elegant theme for hexo. (github.com)</a></li><li>您可以在 github 中直接搜索 hexo 主题</li></ul><h4 id="5-2-下载主题"><a href="#5-2-下载主题" class="headerlink" title="5.2 下载主题"></a>5.2 下载主题</h4><ol><li><p>在 D:\hexo 目录下右键 Git Bash Here(控制台)</p></li><li><p>执行命令: <code>git clone 主题http链接 themes/主题名称</code> 将主题下载至 themes 文件夹下</p></li></ol><img src="/images/initHexo/git-clone.png" /><ul><li>可以在该文件夹下查看是否下载成功</li></ul><img src="/images/initHexo/git-clone-file.png" /><h4 id="5-3-使用主题"><a href="#5-3-使用主题" class="headerlink" title="5.3 使用主题"></a>5.3 使用主题</h4><ul><li>打开 D:\hexo 目录下的 _config.yml 文件，在里面找到 theme: landscape改为theme: yilia-plus(yilia-plus为我们要使用的主题名)，然后执行 <code>hexo clean</code> 先删除旧的 html 文件，再执行 <code>hexo g</code> 重新生成，再执行 <code>hexo d</code> 推送到远程仓库</li></ul><img src="/images/initHexo/theme.png" /><ul><li>在浏览器输入相应域名，发现主题已更换</li><li>注意: 可能需要等一段时间刷新才更换 please be patient</li></ul><h4 id="5-4-修改主题内容"><a href="#5-4-修改主题内容" class="headerlink" title="5.4 修改主题内容"></a>5.4 修改主题内容</h4><p>您可以在 themes&#x2F;fluid 文件夹中查看该主题的内容，并可编辑该文件夹中的 _config.yml 文件修改主题样式</p><img src="/images/initHexo/update-theme.png" /><ul><li>注意: 记得编辑根目录下的 _config.yml 文件，将信息修改为自己的</li></ul><img src="/images/initHexo/Site.png" /><h3 id="第六章-使用-Typora-编写博客"><a href="#第六章-使用-Typora-编写博客" class="headerlink" title="第六章 使用 Typora 编写博客"></a>第六章 使用 Typora 编写博客</h3><h4 id="6-1-Typora-介绍"><a href="#6-1-Typora-介绍" class="headerlink" title="6.1 Typora 介绍"></a>6.1 Typora 介绍</h4><p>Typora 是一款轻便简洁的 Markdown 编辑器，支持即时渲染技术，这也是与其他 Markdown 编辑器最显著的区别。即时渲染使得你写Markdown 就像是写 Word 文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。</p><p>优点:</p><ul><li>简洁美观</li><li>实时预览</li><li>扩展语法</li><li>跨平台</li></ul><h4 id="6-2-安装-Typora"><a href="#6-2-安装-Typora" class="headerlink" title="6.2 安装 Typora"></a>6.2 安装 Typora</h4><p>官网: <a href="https://typoraio.cn/">Typora 官方中文站 (typoraio.cn)</a></p><p>遗憾的是去年 Typora 还是免费的，今年的新版居然开始收费了。</p><p>为此，我为大家准备了旧版免费的安装包 <a href="https://www.aliyundrive.com/s/7Mfocz2n4fc">typora-setup-x64.exe</a> 提取码: <code>ah61</code></p><h4 id="6-3-写博客"><a href="#6-3-写博客" class="headerlink" title="6.3 写博客"></a>6.3 写博客</h4><ol><li><p>在 D:\hexo 目录下，通过输入命令: hexo new “文章 title” 会在 &#x2F;source 文件夹下生成对应文章的 .md 文件，然后就可以通过 Typora 打开此文件编写文章并保存了</p></li><li><p>当您写完该篇文章后，依次输入以下命令:</p></li></ol><p><code>hexo clean</code> 删除 public 文件夹，即删除旧的博客文章</p><p><code>hexo g</code> 生成 public 文件夹，即生成新的博客文章相关 html 文件</p><p><code>hexo d</code> 将博客推送到 github</p><h4 id="6-4-向-Hexo-博客中插入图片"><a href="#6-4-向-Hexo-博客中插入图片" class="headerlink" title="6.4 向 Hexo 博客中插入图片"></a>6.4 向 Hexo 博客中插入图片</h4><p>Hexo 有多种图片插入方式，可以将图片存放在本地引用或者将图片放在 CDN 上引用。</p><ol><li>本地引用–绝对路径</li></ol><p>当 Hexo 项目中只用到少量图片时，可以将图片统一放在 source&#x2F;images 文件夹中，通过 markdown 语法访问它们。</p><p><code>![可以写关于图片的描述](/images/image.jpg)</code></p><p>图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p><ol start="2"><li>本地引用–相对路径</li></ol><p>图片除了可以放在统一的 images 文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置 _config.yml 来生成。</p><p>打开项目根目录中的 _config.yml 文件，将 _config.yml文件中的配置项 post_asset_folder 设为 true 后，执行命令 hexo new “post_name”，在 source&#x2F;posts 中会生成文章 post_name.md 和同名文件夹 post_name。</p><img src="/images/initHexo/post_name.png" /><p>将图片资源放在 post_name 文件夹中，文章就可以使用相对路径引用图片资源了。</p><p><code>![](image.jpg)</code></p><p>但是使用这种引用方式，图片只能在文章中显示，但无法在首页中正常显示。</p><p>如果希望图片在文章和首页中同时显示，可以使用标签插件语法(推荐使用这种引用方法)。</p><p><code>&#123;% asset_img image.jpg This is an image %&#125;</code></p><ol start="3"><li>CDN 引用(不推荐)</li></ol><p>除了在本地存储图片，还可以将图片上传到一些免费的 CDN 服务中。</p><p>比如Cloudinary （梯子访问）提供的图片CDN服务，在 Cloudinary 中上传图片后，会生成对应的 url 地址，将地址直接拿来引用即可。或者上传到路过图床（不用梯子）。</p><h3 id="第七章-总结"><a href="#第七章-总结" class="headerlink" title="第七章 总结"></a>第七章 总结</h3><p>以上就是本人搭建博客的过程以及遇到的一些问题和解决办法，按照本人搭建博客的步骤就可以搭建一个相当不错的静态博客网站了。</p><p>如果想要让 baidu 和 google 搜索引擎收录自己的网站地址，可自行必应搜索。</p><p>谢谢大家!</p><p>参考教程: <a href="https://www.bilibili.com/video/BV1Yb411a7ty/?share_source=copy_web&vd_source=d698f3adeb829e7ec38eaffd67915950">www.bilibili.com/video</a></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
